 /* Copyright (c) 2013-2014, Hisilicon Tech. Co., Ltd. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
#include "hisi_display_effect.h"
#include "hisi_fb.h"
#include <linux/fb.h>
#include "global_ddr_map.h"
#include <linux/hisi/hw_cmdline_parse.h>

//lint -e747, -e838, -e774

#define COUNT_LIMIT_TO_PRINT_DELAY			(200)

typedef struct time_interval {
	long start; 				// microsecond
	long stop;
} time_interval_t;

typedef struct delay_record {
	const char *name;
	long max;
	long min;
	long sum;
	int count;
} delay_record_t;

static int hisifb_ce_do_contrast(struct hisi_fb_data_type *hisifd);
static void hisifb_ce_service_init(void);
static void hisifb_ce_service_deinit(void);

#define DEBUG_EFFECT_LOG					HISI_FB_ERR

#define _EFFECT_DEBUG_LOG(message, ...) \
	do { printk("%s: "message, __func__, ## __VA_ARGS__); } while (0)
#define EFFECT_DEBUG_LOG(feature, message, ...) \
	do { if (g_debug_effect & feature) \
		printk("%s: "message, __func__, ## __VA_ARGS__); } while (0)

#define EFFECT_GRADUAL_REFRESH_FRAMES		(30)

static bool g_is_effect_init = false;
static bool g_is_ce_service_init = false;
static struct mutex g_ce_service_lock;
static ce_service_t g_hiace_service;

static bool g_is_effect_lock_init = false;
spinlock_t g_gmp_effect_lock;
static spinlock_t g_igm_effect_lock;
static spinlock_t g_xcc_effect_lock;
static spinlock_t g_gamma_effect_lock;
static spinlock_t g_hiace_table_lock;
extern struct mutex g_rgbw_lock;
static uint32_t g_table_update = 0;
static uint32_t g_sel_gamma_ab_shadow_hdr_lut = 0;


static time_interval_t interval_wait_hist = {0};
static time_interval_t interval_algorithm = {0};
static delay_record_t delay_wait_hist = {"event hist waiting", 0, 0xFFFFFFFF, 0, 0};
static delay_record_t delay_algorithm = {"algorithm processing", 0, 0xFFFFFFFF, 0, 0};

static uint32_t xcc_table_temp[12] = {0};
static uint32_t xcc_enable_state = 0;

int g_enable_effect = ENABLE_EFFECT_HIACE | ENABLE_EFFECT_BL;
int g_debug_effect = 0;
static bool hiace_enable_status = false;

#define DBV_MAP_INDEX 3
#define DBV_MAP_COUNTS 1024
extern unsigned short dbv_curve_noliner_to_liner_map[DBV_MAP_INDEX][DBV_MAP_COUNTS];

/***GMP LUT**/

static u32 gmp_lut_table_low32bit_init[4913] = {
	0x00000000, 0x02001105, 0x06004207, 0x08005309, 0x0900640a, 0x0800450d, 0x06000610, 0x08000712, 0x0b000814, 0x0e000916, 0x12000a19, 0x16000b1b, 0x1b000c1e, 0x20000d20, 0x26000e22, 0x2c000f24, 0x33000fff,
	0x0c101005, 0x0e101101, 0x10102205, 0x10100307, 0x110ff40a, 0x0f0fc50b, 0x0e0f860f, 0x100f5712, 0x120f1814, 0x150ec916, 0x190e7a18, 0x1d0e0b1b, 0x220d9c1d, 0x270d0d20, 0x2d0c7e22, 0x340bcf24, 0x3a0b0fff,
	0x2120300c, 0x202030fd, 0x1e201202, 0x1d200306, 0x1c200408, 0x1c1fe50b, 0x1c1fc60e, 0x1e1fb710, 0x201f8813, 0x231f6916, 0x261f3a18, 0x2b1efb1a, 0x2f1ecc1d, 0x341e8d1f, 0x3a1e3e21, 0x411ddf24, 0x481d8fff,
	0x33302009, 0x333020f0, 0x323021fb, 0x33301301, 0x33301405, 0x33300509, 0x322fe60c, 0x342fd70f, 0x362fb812, 0x392fa914, 0x3c2f8a17, 0x402f6b19, 0x452f4c1c, 0x4a2f1d1e, 0x502ede21, 0x562eaf23, 0x5d2e6fff,
	0x49401000, 0x494010d9, 0x4b4011ef, 0x4f4012fb, 0x53401401, 0x53401505, 0x54400609, 0x543fe70d, 0x563fd80f, 0x583fc913, 0x5c3fba15, 0x5f3f9b18, 0x643f8c1b, 0x693f6d1d, 0x6f3f3e1f, 0x753f1f22, 0x7c3eefff,
	0x72502000, 0x745010bf, 0x765011e3, 0x7a5012f3, 0x7f5023fc, 0x7e502502, 0x7e500605, 0x7d4ff709, 0x7e4fe80d, 0x824fe910, 0x844fca13, 0x884fbb16, 0x8d4fac19, 0x944f8d1b, 0x9b4f7e1d, 0xa24f6f1f, 0xab4f4ffc,
	0xa7602000, 0xaa602099, 0xac6021d4, 0xb16022e9, 0xb86023f5, 0xb56024fc, 0xb2600600, 0xb2600705, 0xb25ff80a, 0xb45ff90d, 0xb85fea11, 0xbc5fdb14, 0xc05fcc17, 0xc95fbd19, 0xd05fae1a, 0xd95f9f1b, 0xe15f7ffa,
	0xe1702002, 0xe2702067, 0xe37021bc, 0xe77022dc, 0xeb7023eb, 0xec7014f5, 0xef7015fc, 0xee700700, 0xec700806, 0xed70090a, 0xef6ffa0e, 0xf26feb11, 0xf56fdc15, 0xfd6fcd17, 0x056fbe19, 0x0d6fbf1a, 0x146faffa,
	0x1c802004, 0x1b80202d, 0x1980219e, 0x1b8022c9, 0x1d8023de, 0x238024ec, 0x2b8025f6, 0x288016fc, 0x26801801, 0x26800906, 0x26800a0a, 0x297ffb0e, 0x2c7fec12, 0x337fdd14, 0x397fce17, 0x427fcf18, 0x497fbffa,
	0x54903002, 0x53903001, 0x5290317b, 0x549022b5, 0x569023d0, 0x5b9024e2, 0x609025ee, 0x609016f5, 0x5e9017fc, 0x5f901901, 0x5f900a06, 0x618ffb0a, 0x628ffc0e, 0x678fed12, 0x6d8fde15, 0x738fdf17, 0x7a8fcffc,
	0x8ba03000, 0x8ba03000, 0x8ba0314e, 0x8ea0329c, 0x90a033c0, 0x93a024d5, 0x96a025e3, 0x96a026ed, 0x97a017f5, 0x98a018fb, 0x99a01a01, 0x99a00b06, 0x98a00c0a, 0x9c9ffd0f, 0x9f9ffe12, 0xa59fef15, 0xaa9fdffd,
	0xc4b03000, 0xc4b03000, 0xc4b03114, 0xc5b03280, 0xc8b033ad, 0xcbb034c7, 0xceb035d8, 0xcdb026e5, 0xcfb027ee, 0xd6b028f5, 0xdfb019fc, 0xddb01b01, 0xdcb00c05, 0xd8b00d0a, 0xd5affe0f, 0xd9afef13, 0xddafeffe,
	0xfdc03000, 0xfdc03000, 0xfdc030c5, 0xfec0325e, 0xffc03396, 0x01c034b7, 0x04c035cc, 0x05c036db, 0x06c037e5, 0x16c018f0, 0x26c019f8, 0x24c00afc, 0x20c00c01, 0x17c00d05, 0x0cc00e0b, 0x0ebfff0f, 0x11bfefff,
	0x36d04000, 0x36d04000, 0x36d04056, 0x36d04235, 0x38d0337d, 0x39d034a4, 0x3bd035bc, 0x3cd036ce, 0x3dd037db, 0x48d018e8, 0x54d019f0, 0x5cd00af7, 0x63cffbfc, 0x5ad00d00, 0x51cffe05, 0x4dd00f0a, 0x4acfffff,
	0x6fe04000, 0x6fe04000, 0x6fe04000, 0x6fe04204, 0x70e0435f, 0x70e0448e, 0x70e045ac, 0x71e036c0, 0x73e037d0, 0x7ae038dd, 0x82e019e8, 0x94e00af1, 0xa7dffbf8, 0xa0dffcfc, 0x99dffe00, 0x8edfff05, 0x83e00fff,
	0xa8f04000, 0xa8f04000, 0xa8f04000, 0xa8f041ca, 0xa9f0433e, 0xa9f04477, 0xa9f0459a, 0xaaf046b2, 0xabf047c4, 0xb0f038d3, 0xb4f029de, 0xc0f02ae9, 0xcdf00bf1, 0xcdf00cf6, 0xcff00dfb, 0xc7f00f00, 0xc0f00ffe,
	0xe0fff000, 0xe1fff000, 0xe1fff000, 0xe1fff181, 0xe1fff319, 0xe2fff45d, 0xe2fff586, 0xe3fff6a2, 0xe4fff7b7, 0xe4fff8c6, 0xe5fff9d3, 0xeafffadf, 0xf0ffebe8, 0xfaffdcef, 0x05ffddf6, 0x01ffdefb, 0xfdffeffe,
	0xfb005002, 0xfc006105, 0xfd007207, 0xfd007309, 0xfe00640a, 0xfe00350c, 0xff000610, 0x00000712, 0x02000814, 0x05000916, 0x07000a19, 0x0a000b1b, 0x0d000c1e, 0x11000d20, 0x15000e22, 0x1a000f24, 0x1e000fff,
	0x03103009, 0x00100100, 0x02102205, 0x03100307, 0x040ff40a, 0x040fc50b, 0x040f860f, 0x060f4712, 0x080f1814, 0x0a0ec916, 0x0d0e7a18, 0x0f0e0b1b, 0x130d9c1d, 0x160d0d20, 0x1b0c7e22, 0x1f0bcf24, 0x240affff,
	0x12205016, 0x11204100, 0x0f202203, 0x0f201306, 0x0d200408, 0x0d1fe50b, 0x0d1fc60e, 0x0f1fa710, 0x111f8813, 0x131f6916, 0x161f3a18, 0x191efb1a, 0x1c1ecc1d, 0x1f1e7d1f, 0x231e3e21, 0x281ddf24, 0x2c1d8fff,
	0x23304015, 0x223030f5, 0x213031fd, 0x1f302302, 0x1e301406, 0x1f300509, 0x202ff60c, 0x202fe70e, 0x212fb812, 0x232fa914, 0x242f8a17, 0x272f6b19, 0x2a2f3c1c, 0x2e2f1d1e, 0x312ede21, 0x362eaf23, 0x3a2e6fff,
	0x3440200c, 0x354020e2, 0x384031f5, 0x364022fd, 0x36401402, 0x37401506, 0x38400609, 0x373ff70b, 0x363fd80e, 0x373fc913, 0x383fba15, 0x3b3f9b18, 0x3e3f8c1b, 0x413f6d1d, 0x453f3e1f, 0x483f1f22, 0x4d3eefff,
	0x4c503008, 0x4e5020c5, 0x505021e8, 0x515022f5, 0x525023fd, 0x51502502, 0x51501605, 0x50500709, 0x504fe80d, 0x504fe910, 0x514fca13, 0x544fbb16, 0x584fac19, 0x5c4f8d1b, 0x5f4f7e1d, 0x644f6f1f, 0x694f4ffc,
	0x66602001, 0x6960209a, 0x6b6021d5, 0x6f6022ea, 0x736023f6, 0x716024fc, 0x6e600601, 0x6d600705, 0x6d5ff80a, 0x6d5fe90d, 0x6f5fea11, 0x735fdb14, 0x755fcc17, 0x7b5fad19, 0x805fae1a, 0x865f9f1b, 0x8b5f7ffa,
	0x8a702003, 0x8b702069, 0x8c7021bd, 0x8f7022dd, 0x937023ec, 0x937014f6, 0x957025fd, 0x92700701, 0x91700806, 0x9170090a, 0x916ffa0e, 0x946feb11, 0x976fdc15, 0x9c6fcd17, 0xa26fce18, 0xa76fbf1a, 0xad6faffa,
	0xb1802005, 0xb080202d, 0xb080219f, 0xb18022ca, 0xb48023df, 0xba8024ed, 0xc18025f7, 0xbd8016fc, 0xb8801801, 0xb8800906, 0xb8800a0a, 0xba7ffb0e, 0xbc7fec12, 0xc27fdd14, 0xc87fce16, 0xce7fcf18, 0xd37fbffa,
	0xd9903003, 0xd8903002, 0xd990317b, 0xda9022b5, 0xdd9023d1, 0xe29024e3, 0xe89025ef, 0xe59016f6, 0xe29017fc, 0xe1901901, 0xe2900a06, 0xe38ffb0a, 0xe48ffc0e, 0xe88fed11, 0xed8fde15, 0xf28fdf17, 0xf78fcffc,
	0x03a03000, 0x03a03000, 0x03a0314e, 0x06a0329d, 0x09a033c1, 0x0ba024d6, 0x0fa025e4, 0x0ea026ee, 0x0da017f5, 0x0da018fb, 0x0fa01a01, 0x0da00b06, 0x0da00c0a, 0x109ffd0f, 0x139fee12, 0x189fef15, 0x1d9fdffd,
	0x30b03000, 0x30b03000, 0x31b03114, 0x33b03280, 0x34b033ad, 0x38b034c8, 0x3ab035d9, 0x3ab026e5, 0x3ab027ee, 0x41b028f5, 0x48b019fc, 0x46b01b01, 0x45b00c05, 0x42b00d0a, 0x3faffe0f, 0x42afef13, 0x46afeffe,
	0x5fc03000, 0x5fc03000, 0x5fc030c5, 0x61c0325e, 0x61c03396, 0x64c034b7, 0x66c035cc, 0x67c036db, 0x68c037e5, 0x76c018f0, 0x85c019f8, 0x83c00afc, 0x80c00c01, 0x76c00d05, 0x6cc00e0b, 0x6ebfff0f, 0x70bfefff,
	0x90d04000, 0x90d04000, 0x90d04055, 0x90d04235, 0x91d0337d, 0x93d034a4, 0x95d035bc, 0x95d036ce, 0x96d037db, 0xa1d018e8, 0xacd019f0, 0xb3d00af7, 0xbacffbfc, 0xb1d00d00, 0xa8cffe05, 0xa6d00f0a, 0xa2cfffff,
	0xc1e04000, 0xc1e04000, 0xc2e04000, 0xc2e04204, 0xc2e0435f, 0xc2e0448e, 0xc3e045ab, 0xc4e036c0, 0xc5e037d0, 0xcbe038dd, 0xd2e019e8, 0xe5e00af2, 0xf7dffbf8, 0xf0dffcfc, 0xe8dffe00, 0xdedfff05, 0xd4e00fff,
	0xf4f04000, 0xf4f04000, 0xf4f04000, 0xf4f041ca, 0xf4f0433e, 0xf5f04477, 0xf5f0459a, 0xf6f046b2, 0xf7f047c4, 0xfbf038d3, 0xfff029de, 0x0bf01ae9, 0x17f00bf1, 0x18f00cf6, 0x19f00dfb, 0x11f00f00, 0x09f00ffe,
	0x27fff000, 0x27fff000, 0x27fff000, 0x27fff181, 0x28fff319, 0x28fff45d, 0x28fff586, 0x29fff6a2, 0x2afff7b7, 0x2afff8c6, 0x2bfff9d3, 0x30fffadf, 0x35ffebe8, 0x40ffdcef, 0x49ffddf6, 0x45ffdefb, 0x40ffeffe,
	0xf800e007, 0xf800e106, 0xf900d207, 0xf900a309, 0xfa00740b, 0xf900450c, 0xfa000610, 0xfb000712, 0xfc000814, 0xfd000916, 0xff000a19, 0x00000b1b, 0x02000c1d, 0x04000d20, 0x06000e22, 0x09000f24, 0x0c000fff,
	0xfd107010, 0xfd106104, 0xfd104206, 0xfc102307, 0xfc0ff40a, 0xfd0fb50c, 0xfd0f860f, 0xfe0f4711, 0xff0f0814, 0x000ec916, 0x020e6a18, 0x030e0b1b, 0x050d8c1d, 0x070d0d20, 0x090c6e22, 0x0c0bcf24, 0x0f0affff,
	0x07208021, 0x05206102, 0x00200200, 0x03202306, 0x02200408, 0x031fe50b, 0x021fc60e, 0x031fa710, 0x041f8813, 0x051f6916, 0x071f3a18, 0x081efb1a, 0x0b1ebc1d, 0x0d1e7d1f, 0x0f1e2e21, 0x111ddf24, 0x141d8fff,
	0x11306021, 0x103050fa, 0x0f305200, 0x0e303303, 0x0c301406, 0x0d301509, 0x0d2ff60b, 0x0e2fe70e, 0x0e2fb811, 0x0e2fa914, 0x0f2f8a17, 0x112f6b19, 0x132f3c1c, 0x152f1d1e, 0x172ede21, 0x1a2eaf23, 0x1c2e6fff,
	0x1c404018, 0x1f4040ea, 0x214051fb, 0x1e404300, 0x1d402402, 0x1d402506, 0x1e401609, 0x1d40070b, 0x1b3fe80e, 0x1b3fc912, 0x1b3faa15, 0x1d3f9b18, 0x1f3f7c1b, 0x213f6d1d, 0x233f3e1f, 0x263f1f22, 0x283eefff,
	0x2a502010, 0x2c5030cc, 0x2f5031ed, 0x2e5032f7, 0x2f5033fe, 0x2e502503, 0x2e501605, 0x2c500709, 0x2a4fe80d, 0x2b4fe910, 0x2b4fca13, 0x2d4fbb16, 0x2f4fac18, 0x314f8d1b, 0x344f7e1c, 0x374f6f1f, 0x3a4f4ffc,
	0x39602003, 0x3b60209b, 0x3c6031d5, 0x406022ec, 0x446023f7, 0x416024fc, 0x3e601601, 0x3d600705, 0x3d5ff80a, 0x3d5fe90d, 0x3e5fea11, 0x415fdb14, 0x435fcc16, 0x465fbd18, 0x4a5fae1a, 0x4e5f9f1a, 0x515f7ffa,
	0x51702004, 0x5270206a, 0x527021be, 0x557022de, 0x587033ed, 0x597024f6, 0x5a7025fd, 0x58700701, 0x55700806, 0x5570090a, 0x556ffa0e, 0x576feb11, 0x5a6fdc14, 0x5e6fcd16, 0x626fce18, 0x666fbf19, 0x6a6f9ffa,
	0x6c802006, 0x6b80202e, 0x6b8021a0, 0x6d8022ca, 0x6e8023e0, 0x748024ee, 0x7b8035f8, 0x768016fd, 0x71801801, 0x70800906, 0x70800a0a, 0x717ffb0e, 0x737fec12, 0x797fdd13, 0x7e7fde16, 0x827fcf17, 0x857fbffa,
	0x89903003, 0x88903002, 0x8890217b, 0x8a9022b6, 0x8c9023d2, 0x929024e4, 0x989025f0, 0x939016f6, 0x8f9017fc, 0x8f901901, 0x8e900a06, 0x8f8ffb0a, 0x908ffc0e, 0x948fed11, 0x978fde14, 0x9c8fdf16, 0xa08fcffb,
	0xa7a03000, 0xa7a03000, 0xa7a0314e, 0xaaa0329d, 0xada033c2, 0xb0a024d8, 0xb5a025e6, 0xb2a026ee, 0xb0a017f5, 0xb0a018fb, 0xb0a01a01, 0xb0a00b06, 0xafa00c0a, 0xb19ffd0f, 0xb39fee12, 0xb79fef15, 0xbb9fdffd,
	0xcab03000, 0xcab03000, 0xcab03114, 0xccb03280, 0xceb033ae, 0xd1b034c9, 0xd4b035da, 0xd3b026e5, 0xd2b027ee, 0xd8b028f6, 0xdfb019fc, 0xddb01b01, 0xdbb00c05, 0xd8b00d0a, 0xd5affe0f, 0xd8afef13, 0xdbafeffe,
	0xefc03000, 0xefc03000, 0xefc030c4, 0xf0c0325e, 0xf0c03396, 0xf3c034b7, 0xf6c035cc, 0xf6c036db, 0xf7c037e5, 0x04c018f0, 0x11c009f9, 0x0ec00afc, 0x0bc00c01, 0x03c00d05, 0xf9c00e0b, 0xfbbfff0f, 0xfdbfefff,
	0x16d04000, 0x16d04000, 0x16d04055, 0x16d04234, 0x18d0337d, 0x19d034a4, 0x1bd035bc, 0x1bd036ce, 0x1cd037db, 0x26d018e8, 0x30d019f1, 0x36d00af7, 0x3ccffbfc, 0x34d00d00, 0x2ccffe05, 0x28d00f0a, 0x25cfffff,
	0x3fe04000, 0x3fe04000, 0x3fe04000, 0x40e04204, 0x40e0435f, 0x40e0448e, 0x41e045ab, 0x41e036c0, 0x43e037d0, 0x49e028dd, 0x4ee019e8, 0x60e00af2, 0x70dffbf8, 0x69dffcfc, 0x62dffe00, 0x59dfff05, 0x4fe00fff,
	0x6af04000, 0x6af04000, 0x6af04000, 0x6af041ca, 0x6af0433e, 0x6bf04477, 0x6bf0459a, 0x6cf046b2, 0x6cf047c3, 0x70f038d3, 0x74f029df, 0x80f01ae9, 0x8beffbf1, 0x8bf00cf6, 0x8bf00dfb, 0x84f00f00, 0x7df00ffe,
	0x96fff000, 0x96fff000, 0x96fff000, 0x96fff181, 0x96fff318, 0x97fff45d, 0x97fff586, 0x97fff6a2, 0x98fff7b7, 0x99fff8c6, 0x9afff9d3, 0x9ffffadf, 0xa3ffebe8, 0xadffdcef, 0xb6ffddf6, 0xb1ffdefb, 0xadffeffe,
	0xf602c016, 0xf501c107, 0xf500d207, 0xf5009308, 0xf500540b, 0xf500350d, 0xf6001610, 0xf6001712, 0xf7000814, 0xf8000916, 0xf9000a19, 0xfa000b1b, 0xfb000c1d, 0xfd000d20, 0xff000e22, 0x00000f24, 0x02000fff,
	0xfa11b02c, 0xfa11910c, 0xf911620a, 0xf910a308, 0xf70ff40a, 0xf70fc50c, 0xf80f760f, 0xf80f4711, 0xf90f0814, 0xfa0eb916, 0xfb0e6a18, 0xfc0dfb1b, 0xfd0d8c1d, 0xff0d0d20, 0x000c6e22, 0x020bbf24, 0x040affff,
	0x0421a05b, 0x0521b11d, 0x0621d214, 0x0120f30a, 0xfb201408, 0xfc1ff50b, 0xfb1fc60e, 0xfc1fa710, 0xfd1f8813, 0xfe1f5915, 0xff1f2a18, 0x001efb1a, 0x011ebc1d, 0x021e7d1f, 0x041e2e21, 0x061ddf24, 0x071d7fff,
	0x0c30f04d, 0x0e310116, 0x0f311212, 0x00300300, 0x04303407, 0x05303508, 0x0530360a, 0x0530070d, 0x042fc811, 0x042fb913, 0x042f8a17, 0x062f6b19, 0x072f3c1c, 0x082f0d1e, 0x0a2ede21, 0x0b2eaf23, 0x0d2e6fff,
	0x10405024, 0x124070f6, 0x15408204, 0x13407305, 0x12406405, 0x14407507, 0x16407608, 0x12403709, 0x0e3ff80d, 0x0e3fd911, 0x0d3faa15, 0x0e3f9b18, 0x0f3f7c1b, 0x103f5d1d, 0x123f3e1f, 0x133f1f22, 0x153eeffe,
	0x1a50301b, 0x1e5050d9, 0x215061f9, 0x23506301, 0x24507405, 0x21505505, 0x1f504606, 0x1c502708, 0x194ff80c, 0x184fe90f, 0x174fca13, 0x194fbb15, 0x1b4fac18, 0x1c4f9d1a, 0x1e4f8e1c, 0x204f6f1e, 0x234f4ffb,
	0x2460300d, 0x296040ac, 0x2d6041e5, 0x356052fb, 0x3c606405, 0x31604501, 0x26601601, 0x26601705, 0x2660080a, 0x265fe90d, 0x265fea11, 0x275fdb13, 0x295fdc15, 0x2c5fbd17, 0x2f5fae19, 0x315f9f19, 0x345f8ff9,
	0x3470200b, 0x38703076, 0x3b7031ca, 0x417042e9, 0x477043f9, 0x447034fd, 0x427035ff, 0x3c701702, 0x37700806, 0x366ff90a, 0x366ffa0e, 0x386feb10, 0x3a6fdc14, 0x3d6fdd15, 0x416fce16, 0x436fbf18, 0x466faff8,
	0x46802009, 0x46802031, 0x468021a3, 0x4b8022cf, 0x508033e6, 0x5b8034f7, 0x67803600, 0x588026ff, 0x4a801801, 0x4a800906, 0x48800a0a, 0x4a7ffb0d, 0x4d7fec11, 0x517fed12, 0x557fde14, 0x597fcf14, 0x5b7fbff8,
	0x5b903005, 0x5b903005, 0x5b90217d, 0x5f9022ba, 0x639023d7, 0x6b9024ea, 0x749025f7, 0x6b9016f9, 0x609017fc, 0x60901901, 0x5f900a06, 0x608ffb0a, 0x628ffc0d, 0x658fed11, 0x698fde13, 0x6b8fdf15, 0x6f8fcffa,
	0x71a03000, 0x71a03000, 0x71a0314d, 0x74a0329f, 0x77a033c3, 0x7ca024da, 0x80a025e8, 0x7ca026f0, 0x79a017f5, 0x79a018fc, 0x79a01a01, 0x79a00b06, 0x78a00c0a, 0x7a9ffd0d, 0x7c9fee11, 0x7f9fdf14, 0x829fdffd,
	0x8bb03000, 0x8bb03000, 0x8bb03113, 0x8eb03281, 0x90b033af, 0x93b034ca, 0x98b035dc, 0x96b026e7, 0x95b027ee, 0x99b028f6, 0x9fb009fc, 0x9db01b01, 0x9bb00c05, 0x98b00d0a, 0x96affe0f, 0x98afef12, 0x9aafeffe,
	0xa8c03000, 0xa8c03000, 0xa9c030c4, 0xaac0325d, 0xaac03396, 0xadc034b8, 0xafc035ce, 0xb1c036db, 0xb2c037e6, 0xbec018f1, 0xcac009f9, 0xc6c00afd, 0xc2c00c01, 0xb9bffd05, 0xb0c00e0b, 0xb2bfff0f, 0xb3bfefff,
	0xc7d04000, 0xc7d04000, 0xc7d04054, 0xc8d04235, 0xc9d0337d, 0xcad034a4, 0xccd035bd, 0xcdd036cf, 0xcdd037dc, 0xd7d018e9, 0xe1d009f1, 0xe6d00af8, 0xebcffbfc, 0xe3d00d00, 0xdacffe05, 0xd6d00f0a, 0xd2cfffff,
	0xe8e04000, 0xe8e04000, 0xe8e04000, 0xe8e04204, 0xe9e0435f, 0xe9e0448e, 0xeae045ab, 0xebe036c0, 0xebe037cf, 0xf1e028dd, 0xf7e019e9, 0x07e00af2, 0x18dfebf8, 0x10dffcfc, 0x09dffe00, 0xffdfff04, 0xf5e00fff,
	0x0bf04000, 0x0bf04000, 0x0bf04000, 0x0cf041c9, 0x0cf0433e, 0x0cf04477, 0x0cf0459a, 0x0df046b2, 0x0df047c3, 0x11f038d2, 0x14f029df, 0x1ff01ae9, 0x2aeffbf1, 0x2aeffcf7, 0x2beffdfb, 0x23efff00, 0x1cf00ffe,
	0x30fff000, 0x30fff000, 0x30fff000, 0x30fff181, 0x30fff318, 0x30fff45d, 0x31fff586, 0x31fff6a2, 0x32fff7b6, 0x33fff8c6, 0x33fff9d3, 0x38ffeadf, 0x3dffebe8, 0x45ffdcf0, 0x4effcdf6, 0x4affdefb, 0x45ffeffe,
	0xf105702c, 0xf103010a, 0xf1009207, 0xf1005308, 0xf200140b, 0xf200150d, 0xf2001610, 0xf3001712, 0xf3001814, 0xf4001916, 0xf5000a19, 0xf6000b1b, 0xf6000c1d, 0xf8000d20, 0xf9000e22, 0xfa000f24, 0xfb000fff,
	0xf3140053, 0xf313b118, 0xf3137210, 0xf311c30a, 0xf30ff40a, 0xf30fb50c, 0xf40f860f, 0xf40f5711, 0xf50f1814, 0xf60eb916, 0xf60e5a18, 0xf70dfb1b, 0xf80d7c1d, 0xf90cfd1f, 0xfa0c5e22, 0xfb0baf24, 0xfc0aefff,
	0xfc23b09d, 0xfd241140, 0xff247228, 0xfb22530f, 0xf7202408, 0xf620050b, 0xf61fc60e, 0xf71fb710, 0xf81f8813, 0xf81f5915, 0xf91f2a18, 0xfa1efb1a, 0xfa1ebc1c, 0xfc1e7d1f, 0xfc1e2e21, 0xfe1ddf24, 0xff1d7fff,
	0x0531c07d, 0x07320136, 0x08324226, 0x03316310, 0xfd307408, 0xfe308508, 0xff307609, 0xfe30370c, 0xfd2fd810, 0xfd2fa913, 0xfd2f8a17, 0xfe2f5b19, 0xff2f3c1c, 0x002f0d1e, 0x012ede21, 0x022eaf23, 0x032e6ffe,
	0x06408030, 0x0940b101, 0x0b40d20d, 0x0a40d30a, 0x00400400, 0x0c40c509, 0x0f40e608, 0x0a408708, 0x0540180c, 0x043fe910, 0x033faa15, 0x043f9b18, 0x053f7c1b, 0x053f5d1d, 0x073f3e1f, 0x083f1f21, 0x093eeffe,
	0x0f505027, 0x135070e8, 0x1750a205, 0x1950b30b, 0x1b50c40c, 0x18509508, 0x15507607, 0x11504708, 0x0e50080b, 0x0c4fe90f, 0x0c4fca13, 0x0d4fbb15, 0x0d4fbc18, 0x0f4f9d1a, 0x104f8e1b, 0x124f6f1d, 0x134f5ffb,
	0x16604018, 0x1c6050bd, 0x226061f5, 0x2b60930b, 0x3360c413, 0x25607506, 0x17601601, 0x17601705, 0x17600808, 0x175ff90c, 0x165fea10, 0x175feb13, 0x195fdc15, 0x1c5fbd16, 0x1e5fbe17, 0x1f5f9f18, 0x215f8ff7,
	0x23703013, 0x27704083, 0x2b7041d5, 0x327062f6, 0x3a707405, 0x36705504, 0x31705602, 0x2b702703, 0x24701805, 0x2370090a, 0x226ffa0e, 0x246ffb10, 0x266fec13, 0x286fdd14, 0x2c6fde15, 0x2e6fbf16, 0x2f6faff6,
	0x2f80200c, 0x30802036, 0x308021a6, 0x368032d6, 0x3c8033ed, 0x498054ff, 0x57805608, 0x44803702, 0x32800801, 0x31800906, 0x31800a0a, 0x337ffb0d, 0x357ffc10, 0x397fed11, 0x3d7fde12, 0x3f7fdf13, 0x417fcff6,
	0x3e902007, 0x3e902007, 0x3f90217f, 0x439022be, 0x499023dc, 0x539034f1, 0x5d9025fd, 0x509026fb, 0x439017fc, 0x43901901, 0x41900a06, 0x438ffb09, 0x458ffc0d, 0x488fed10, 0x4a8fee12, 0x4c8fef14, 0x4f8fcff9,
	0x4fa03000, 0x4fa03000, 0x4fa0314d, 0x52a032a0, 0x55a033c5, 0x5aa024dc, 0x5fa025ea, 0x5aa026f1, 0x57a017f6, 0x56a018fc, 0x55a01a01, 0x55a00b06, 0x559ffc0a, 0x589ffd0d, 0x599fee10, 0x5c9fdf14, 0x5e9fdffc,
	0x63b03000, 0x63b03000, 0x64b03113, 0x66b03281, 0x69b033b0, 0x6cb034cc, 0x70b035de, 0x6eb026e7, 0x6cb027ef, 0x71b018f7, 0x76b019fd, 0x73b01b01, 0x71b00c05, 0x6fb00d0a, 0x6caffe0e, 0x6eafef12, 0x6fafeffe,
	0x7ac03000, 0x7ac03000, 0x7ac030c3, 0x7bc0325d, 0x7dc03397, 0x80c034b9, 0x82c025cf, 0x83c026dc, 0x84c017e7, 0x90c018f2, 0x9ac009fa, 0x96c00afd, 0x92c00c01, 0x89c00d05, 0x80c00e0b, 0x82bfff0f, 0x83bfefff,
	0x93d04000, 0x93d04000, 0x93d04054, 0x93d03235, 0x94d0337d, 0x97d034a5, 0x98d035be, 0x99d036d0, 0x9ad037dc, 0xa2d018e9, 0xabd009f2, 0xafd00af8, 0xb3cffbfc, 0xabd00d00, 0xa3cffe05, 0xa0d00f0a, 0x9ccfffff,
	0xade04000, 0xaee04000, 0xaee04000, 0xaee04204, 0xaee0435f, 0xaee0448e, 0xafe045ab, 0xb0e036c0, 0xb0e037d0, 0xb6e028dd, 0xbbe019e8, 0xcadffaf3, 0xd9dfebf9, 0xd2dffcfc, 0xcbdffe00, 0xc2dfff04, 0xb9e00fff,
	0xcaf04000, 0xcaf04000, 0xcaf04000, 0xcaf041c9, 0xcaf0433e, 0xcbf04477, 0xcbf0459a, 0xcbf046b1, 0xcdf047c3, 0xcff038d2, 0xd3f029df, 0xddf01aea, 0xe7effbf2, 0xe7effcf7, 0xe7effdfb, 0xe0efff00, 0xd8f00ffe,
	0xe8fff000, 0xe8fff000, 0xe8fff000, 0xe8fff181, 0xe9fff318, 0xe9fff45d, 0xe9fff586, 0xeafff6a2, 0xeafff7b6, 0xeafff8c6, 0xebfff9d3, 0xf0ffeade, 0xf4ffebe9, 0xfcffdcf0, 0x05ffcdf6, 0x00ffdefb, 0xfbffeffe,
	0xeb042022, 0xed027108, 0xee00b207, 0xee008308, 0xee00440b, 0xef00350d, 0xef00360f, 0xef002712, 0xf0001814, 0xf1001916, 0xf1001a19, 0xf1000b1b, 0xf2000c1d, 0xf3000d20, 0xf4000e22, 0xf5000f24, 0xf6000fff,
	0xeb13b043, 0xeb139115, 0xeb13720e, 0xee11e30a, 0xef10540a, 0xf010150b, 0xf00fd60e, 0xf10f7710, 0xf10f0814, 0xf10eb916, 0xf20e5a18, 0xf30deb1b, 0xf30d7c1d, 0xf40ced1f, 0xf50c5e22, 0xf60baf24, 0xf70adfff,
	0xef23807a, 0xee23f133, 0xee246221, 0xf022830e, 0xf2209409, 0xf220650a, 0xf220360c, 0xf31fd70e, 0xf31f8813, 0xf31f6915, 0xf41f2a18, 0xf51eeb1a, 0xf51ebc1c, 0xf61e6d1f, 0xf71e2e21, 0xf81dcf24, 0xf91d7fff,
	0xf832708e, 0xf932f146, 0xfa337233, 0xf932b31a, 0xf832040e, 0xf931c509, 0xf9319606, 0xf830e708, 0xf730280e, 0xf82fd911, 0xf72f7a17, 0xf82f5b19, 0xf92f3c1c, 0xfa2f0d1e, 0xfa2ede21, 0xfb2e9f22, 0xfc2e7ffe,
	0x0441e09e, 0x0842615b, 0x0b42f24c, 0x0b42e331, 0x0c42e420, 0x0b42b512, 0x0a428608, 0x05418703, 0xff407809, 0xfd40190d, 0xfc3fba14, 0xfc3f9b18, 0xfd3f7c1a, 0xfe3f5d1d, 0xff3f3e1f, 0x003f1f21, 0x013efffd,
	0x0c50f072, 0x12516137, 0x1951d242, 0x1d521338, 0x2052642d, 0x00500500, 0x1151260a, 0x0d50d707, 0x08506808, 0x0650290b, 0x044fea11, 0x054fdb13, 0x044fcc16, 0x064fad17, 0x074f8e19, 0x084f7f1b, 0x094f6ff9,
	0x0e60602d, 0x1760a0eb, 0x2060f223, 0x2c616338, 0x3961e43b, 0x24610514, 0x0e604603, 0x11605706, 0x14606807, 0x11603909, 0x0e601a0e, 0x0e5ffb10, 0x0f5fec12, 0x115fdd13, 0x125fce14, 0x135fbf15, 0x145faff5,
	0x17704024, 0x1d7060a4, 0x257081f7, 0x3070c319, 0x3c70f426, 0x3270c514, 0x29709609, 0x23706705, 0x1d704805, 0x1b702908, 0x19700a0b, 0x1a700b0d, 0x1b6ffc0f, 0x1d6ffd10, 0x1f6fee10, 0x206fcf12, 0x216fcff3,
	0x21803017, 0x22803042, 0x238031b0, 0x2a8042e2, 0x318053f9, 0x4080850f, 0x5180a617, 0x3b806707, 0x26801802, 0x26801906, 0x25800a08, 0x27801b0b, 0x2a800c0c, 0x2b7ffd0d, 0x2e7ffe0d, 0x2f7fef0d, 0x307fdff2,
	0x2c90200d, 0x2d902010, 0x2d902185, 0x349032c8, 0x3a9033e6, 0x479044fe, 0x5590460b, 0x49903703, 0x3c902800, 0x37902902, 0x33901a06, 0x34900b08, 0x35900c0b, 0x368ffd0d, 0x398fee0f, 0x3a8fdf11, 0x3b8fcff6,
	0x37a03002, 0x37a03002, 0x38a0314d, 0x3da032a5, 0x42a023cc, 0x4aa024e6, 0x51a025f5, 0x55a026fb, 0x58a01800, 0x4ba018ff, 0x40a01a01, 0x41a00b06, 0x409ffc09, 0x429ffd0c, 0x439fee0f, 0x459fdf12, 0x469fdffb,
	0x48b03001, 0x48b03001, 0x48b03113, 0x4bb03285, 0x50b033b5, 0x56b024d3, 0x5cb015e6, 0x5fb016ef, 0x61b017f7, 0x5fb008fa, 0x5db019fe, 0x5ab01b01, 0x57b00c05, 0x55b00d08, 0x51affe0e, 0x52afef11, 0x53afeffd,
	0x5bc03000, 0x5bc03000, 0x5bc030c2, 0x5cc0325e, 0x5dc03398, 0x61c034bb, 0x64c025d1, 0x66c026e0, 0x69c017eb, 0x73c008f5, 0x7fc009fb, 0x78bffafd, 0x71c00c01, 0x69bffd05, 0x60c00e0b, 0x60bfff0f, 0x63bfefff,
	0x6fd04000, 0x6fd04000, 0x6fd04053, 0x70d03234, 0x70d0337d, 0x72d034a6, 0x74d025c0, 0x76d026d2, 0x78d017de, 0x80d018ea, 0x89d009f4, 0x8dd00af9, 0x90cfebfd, 0x87cffd00, 0x7ecffe05, 0x7ad00f0a, 0x76cfffff,
	0x84e04000, 0x84e04000, 0x84e04000, 0x84e04204, 0x85e0435f, 0x85e0448d, 0x85e035ab, 0x87e036c1, 0x87e037d0, 0x8ce028de, 0x91e019e8, 0xa2dffaf4, 0xb3dfdbfa, 0xa8dfecfc, 0x9fdffe00, 0x96dfff04, 0x8de00fff,
	0x9cf04000, 0x9cf04000, 0x9cf04000, 0x9cf041c9, 0x9cf0433e, 0x9df04477, 0x9df04599, 0x9df046b1, 0x9ef037c4, 0xa1f038d3, 0xa4f029df, 0xb0f01aeb, 0xbbefebf3, 0xb9effcf7, 0xb8effdfb, 0xafefff00, 0xa8f00ffe,
	0xb5fff000, 0xb5fff000, 0xb5fff000, 0xb5fff180, 0xb5fff318, 0xb6fff45d, 0xb6fff586, 0xb6fff6a2, 0xb6fff7b6, 0xb7fff8c6, 0xb8fff9d3, 0xbcffeade, 0xc0ffebe8, 0xc9ffdcf0, 0xd1ffcdf6, 0xcbffdefb, 0xc6ffeffe,
	0xe901d00f, 0xea016106, 0xea00e206, 0xeb00b308, 0xec00740a, 0xec00650d, 0xec00560f, 0xec003712, 0xec002814, 0xed002916, 0xed001a18, 0xee001b1b, 0xee000c1d, 0xef000d20, 0xf0000e22, 0xf0000f24, 0xf1000fff,
	0xe7128029, 0xe712b10e, 0xe712d20c, 0xe811d309, 0xea10c409, 0xea10950b, 0xeb10560c, 0xec0fb70f, 0xee0f0814, 0xee0ea916, 0xee0e4a18, 0xef0ddb1b, 0xef0d5c1d, 0xf00cdd1f, 0xf00c3e22, 0xf10b8f24, 0xf20acfff,
	0xe822c051, 0xe7232120, 0xe6238218, 0xe922530c, 0xeb21240a, 0xec210509, 0xec20d60b, 0xee20370d, 0xef1f7812, 0xef1f5914, 0xf01f2a18, 0xf01eeb1a, 0xf11eac1c, 0xf21e6d1f, 0xf21e1e21, 0xf31dcf24, 0xf41d6fff,
	0xeb3360a3, 0xea344159, 0xe9351242, 0xea34b327, 0xeb344417, 0xec33d50c, 0xed335605, 0xef31f703, 0xf130780b, 0xf230090f, 0xf32f8a16, 0xf32f5b19, 0xf32f2c1c, 0xf42efd1e, 0xf52ede20, 0xf62eaf22, 0xf72e7ffe,
	0xf743d112, 0xf844f1bc, 0xfa461290, 0xfa46135d, 0xfb46243c, 0xfb45751d, 0xfb44d608, 0xfa42f6ff, 0xf7410805, 0xf740690a, 0xf63fba14, 0xf73f9b17, 0xf73f7c1a, 0xf83f5d1d, 0xf93f4e1e, 0xf93f1f20, 0xfa3eeffd,
	0x0351e0c1, 0x0852c18a, 0x0d539284, 0x10541369, 0x1454a451, 0x0d537525, 0x0752360f, 0x04519706, 0x0050f806, 0xff508908, 0xfd500a0f, 0xfd4feb12, 0xfd4fdc15, 0xfe4fbd15, 0x004fae17, 0x004f8f19, 0x014f6ff7,
	0x05608043, 0x0e612119, 0x1661c252, 0x23629367, 0x2f638466, 0x1b61f524, 0x00600600, 0x0960a707, 0x0c60d806, 0x0a608906, 0x06603a0b, 0x07601b0d, 0x06600c0f, 0x075ffd10, 0x095fee10, 0x0a5fcf11, 0x0a5fbff2,
	0x0e706035, 0x1570a0c6, 0x1c70e219, 0x2871533d, 0x3471b448, 0x29715525, 0x1f70e610, 0x1a70b709, 0x15707806, 0x13705907, 0x10702a09, 0x10702b0a, 0x11702c0c, 0x13700d0c, 0x15700e0c, 0x146fef0d, 0x156fdff0,
	0x15804021, 0x1680404e, 0x188041ba, 0x1f8062ee, 0x26808407, 0x3580d51e, 0x45811626, 0x3080b70d, 0x1b803803, 0x1b803905, 0x1b802a07, 0x1d802b08, 0x1f802c09, 0x21801d08, 0x23801e07, 0x22800f08, 0x227fffee,
	0x1f903014, 0x1f903019, 0x2090318b, 0x279042d1, 0x2e9043f2, 0x3c90750d, 0x4a90861a, 0x3f90670b, 0x34905805, 0x2d903903, 0x26901a05, 0x27901b07, 0x28901c09, 0x29900d0b, 0x2b8ffe0c, 0x2b8fef0d, 0x2b8fdff4,
	0x28a03003, 0x28a03003, 0x28a0314d, 0x2da032a9, 0x32a023d2, 0x3ca034f0, 0x46a03600, 0x4da04707, 0x54a0380a, 0x42a02902, 0x30a01a02, 0x30a00b04, 0x309ffc08, 0x31a00d0b, 0x329ffe0e, 0x339fef10, 0x349feff9,
	0x34b03002, 0x34b03002, 0x34b03112, 0x38b03288, 0x3cb033b9, 0x44b034d9, 0x4cb015ee, 0x51b016f8, 0x58b017ff, 0x50b018fe, 0x49b019ff, 0x47b01b01, 0x43b00c04, 0x40b00d08, 0x3eaffe0d, 0x3eafef10, 0x3fafeffc,
	0x43c03000, 0x43c03000, 0x44c030c1, 0x45c0325e, 0x46c03397, 0x4ac034bc, 0x4ec025d4, 0x51c026e3, 0x54c017ee, 0x5ec008f8, 0x68c009fd, 0x61bffafe, 0x59c00c01, 0x51c00d05, 0x48c00e0b, 0x4abfff0f, 0x4abfeffe,
	0x54d04000, 0x54d04000, 0x54d03051, 0x55d03234, 0x55d0337d, 0x58d034a7, 0x5bd025c2, 0x5dd026d3, 0x5fd017e1, 0x67d008ec, 0x6fd009f5, 0x72cffafa, 0x75cfebfd, 0x6ccffd00, 0x61cffe04, 0x5ed00f0a, 0x5ccffffe,
	0x66e04000, 0x66e04000, 0x66e04000, 0x66e04203, 0x66e0435e, 0x66e0448d, 0x67e035ab, 0x68e036c1, 0x69e037d0, 0x6ee028de, 0x72e019e9, 0x83dffaf5, 0x95dfdbfb, 0x8adfdcfc, 0x7edffdff, 0x76dfff04, 0x6ee00fff,
	0x7af04000, 0x7af04000, 0x7af04000, 0x7af041c8, 0x7af0433d, 0x7af04476, 0x7af04599, 0x7cf046b1, 0x7cf037c4, 0x7ef028d3, 0x82f029e0, 0x8deffaeb, 0x9aefebf4, 0x96efecf7, 0x94effdfb, 0x8defff00, 0x85effffe,
	0x8ffff000, 0x8ffff000, 0x8ffff000, 0x8ffff17f, 0x8ffff318, 0x8ffff45c, 0x8ffff586, 0x90fff6a1, 0x90fff7b6, 0x91fff8c6, 0x92fff9d3, 0x95ffeadf, 0x9affebe8, 0xa2ffccf0, 0xaaffbdf6, 0xa4ffcefb, 0x9effdffe,
	0xe4029015, 0xe4028108, 0xe4028208, 0xe502030a, 0xe601940a, 0xe701250d, 0xe800b60e, 0xe8008711, 0xe9005813, 0xe9003915, 0xea002a18, 0xea001b1b, 0xeb000c1d, 0xeb000d20, 0xec000e22, 0xed000f24, 0xed000fff,
	0xe212d02b, 0xe1131110, 0xe113420d, 0xe312630a, 0xe511740a, 0xe611150b, 0xe610960c, 0xe80fd70f, 0xea0f1812, 0xea0eb915, 0xeb0e3a18, 0xeb0dcb1a, 0xeb0d4c1d, 0xec0ccd1f, 0xed0c2e22, 0xed0b7f24, 0xee0aafff,
	0xe022f04b, 0xdf23411c, 0xde239216, 0xe122930d, 0xe521a40a, 0xe621550a, 0xe721160a, 0xe920670d, 0xea1fa811, 0xeb1f6914, 0xec1f2a18, 0xec1eeb1a, 0xed1e9c1c, 0xee1e5d1f, 0xee1e0e21, 0xef1dbf24, 0xef1d5fff,
	0xdd3490b8, 0xdb35315f, 0xd935c241, 0xdb356328, 0xdd350419, 0xdf34450d, 0xe233a606, 0xe6324705, 0xeb30f809, 0xec30490e, 0xee2f9a14, 0xef2f6b17, 0xef2f3c1b, 0xf02f0d1d, 0xf02ede1f, 0xf12eaf21, 0xf22e7ffd,
	0xe345714e, 0xe14641cf, 0xdf471290, 0xdf46f35c, 0xe046f43a, 0xe345f51e, 0xe645060b, 0xea436701, 0xed41a803, 0xf040d908, 0xf13ffa11, 0xf23fbb15, 0xf23f7c19, 0xf33f5d1b, 0xf33f4e1d, 0xf43f2f1f, 0xf53f0ffb,
	0xf5533117, 0xf553f1bb, 0xf554d29a, 0xf5553373, 0xf655a456, 0xf654b52d, 0xf653c614, 0xf7532706, 0xf75277ff, 0xf7519900, 0xf650aa08, 0xf7505b0b, 0xf7500c10, 0xf84fed11, 0xf84fde13, 0xf94faf15, 0xfa4f8ff5,
	0x006190bd, 0x0462517e, 0x08631293, 0x0c63e387, 0x1064a476, 0x0c63c53e, 0x0862d61d, 0x0962d70f, 0x0a62e801, 0x0661f8fb, 0x02610a00, 0x0160bb02, 0xff606c07, 0x00604d09, 0x01603e0a, 0x01600f0c, 0x015fdfee,
	0x0870c075, 0x0c711101, 0x10716240, 0x1871e359, 0x1f72745c, 0x20727543, 0x2072762e, 0x00700700, 0x14718808, 0x11713903, 0x0e70da01, 0x0c70cb00, 0x0c709c01, 0x0c707d00, 0x0c705e02, 0x0c703f05, 0x0b700feb,
	0x09803015, 0x0a804044, 0x0b8041b7, 0x1580a301, 0x1f80f423, 0x2f81753e, 0x3f820645, 0x2b81571a, 0x17809806, 0x1980a905, 0x1c80aa03, 0x1c80aaff, 0x1d809bfb, 0x1d808cfb, 0x1c807dfb, 0x1a804efe, 0x18802fe8,
	0x1290200c, 0x13903014, 0x1390318a, 0x1d9052e0, 0x26908408, 0x3590b528, 0x45910635, 0x3b90d71c, 0x3190a80c, 0x2d908907, 0x29907a04, 0x29906b02, 0x28906c00, 0x26904d01, 0x23902e03, 0x22901f06, 0x1f8ffff0,
	0x1aa03002, 0x1ba03003, 0x1ba0314e, 0x21a032b1, 0x28a033de, 0x33a05501, 0x3fa06614, 0x49a06719, 0x54a07819, 0x45a0690b, 0x37a04a04, 0x34a03b02, 0x30a02c03, 0x2da01d05, 0x29a00e09, 0x289fff0c, 0x279feff7,
	0x25b03001, 0x25b03002, 0x26b03113, 0x2ab0328d, 0x2fb033c1, 0x38b034e6, 0x42b025fc, 0x4bb02707, 0x53b0280d, 0x4fb02908, 0x4db02a04, 0x49b02b02, 0x47b01c01, 0x3db00d03, 0x34affe09, 0x32afef0d, 0x31afdffa,
	0x32c03000, 0x32c03000, 0x32c030c1, 0x34c03260, 0x35c0339c, 0x3ac024c2, 0x3ec025da, 0x43c026ea, 0x49c017f5, 0x57c00900, 0x65bffa05, 0x63bffb02, 0x60bfebff, 0x50bffd01, 0x3ec00e08, 0x3dbfff0c, 0x3abfeffd,
	0x40d03000, 0x40d03000, 0x40d03050, 0x41d03236, 0x42d03380, 0x45d024aa, 0x48d025c5, 0x4cd026d8, 0x50d007e6, 0x5bcff8f3, 0x65cfe9fc, 0x6ccfeaff, 0x72cfdbff, 0x62cfecff, 0x52cffe03, 0x4dcfff08, 0x49cffffe,
	0x4fe04000, 0x4fe04000, 0x4fe04000, 0x4fe04202, 0x4fe0435e, 0x4fe0348d, 0x50e035ac, 0x52e036c1, 0x54e027d2, 0x5be028e1, 0x61e009ed, 0x72dfdaf8, 0x84dfbbfe, 0x75dfdcfc, 0x67dffdff, 0x5edfff04, 0x56e00ffe,
	0x60f04000, 0x60f04000, 0x60f04000, 0x60f041c7, 0x60f0433d, 0x60f04476, 0x61f04599, 0x62f046b2, 0x63f037c5, 0x67f028d5, 0x6af019e1, 0x77effaee, 0x83efdbf6, 0x7fefecf8, 0x7aefedfb, 0x72effeff, 0x6beffffe,
	0x72fff000, 0x72fff000, 0x72fff000, 0x72fff17e, 0x72fff317, 0x72fff45c, 0x72fff585, 0x73fff6a1, 0x73fff7b6, 0x73fff8c6, 0x74fff9d3, 0x79ffeadf, 0x7dffdbe9, 0x86ffccf1, 0x8fffadf7, 0x88ffcefa, 0x80ffdffe,
	0xdf03601b, 0xde03f10d, 0xdd04820c, 0xde03b30b, 0xe002f40b, 0xe102150c, 0xe401460e, 0xe500e710, 0xe5007813, 0xe6005915, 0xe7003a17, 0xe7002b1b, 0xe7000c1d, 0xe8000d1f, 0xe8000e22, 0xe9000f24, 0xe9000fff,
	0xdd13102c, 0xdc137111, 0xdb13b20f, 0xdd13030c, 0xdf12340b, 0xe011950b, 0xe210e60c, 0xe410170f, 0xe60f2812, 0xe60eb915, 0xe70e3a17, 0xe80dbb1a, 0xe80d2c1d, 0xe90cad1f, 0xe90c0e22, 0xe90b5f24, 0xea0a9fff,
	0xdb22f043, 0xda232118, 0xda236212, 0xdc22d30d, 0xde22340b, 0xdf21d50a, 0xe121660b, 0xe420970d, 0xe71fb810, 0xe71f7914, 0xe91f2a17, 0xe91eeb1a, 0xe91e9c1c, 0xe91e4d1f, 0xea1e0e21, 0xeb1daf24, 0xeb1d4fff,
	0xce3600d1, 0xcd363165, 0xcc367240, 0xce360328, 0xd035b41a, 0xd434b50e, 0xd933b608, 0xdd32a706, 0xe2319808, 0xe630b90c, 0xe92fda12, 0xea2f8b16, 0xeb2f3c1b, 0xeb2f1d1c, 0xec2eee1e, 0xec2eaf21, 0xed2e7ffc,
	0xc947b18f, 0xc847e1e4, 0xc8481290, 0xc947d35b, 0xcb47a43b, 0xd146651d, 0xd745160c, 0xdd43d703, 0xe2429801, 0xe7417905, 0xeb403a0f, 0xec3feb12, 0xed3f9c18, 0xee3f7d1a, 0xef3f5e1b, 0xef3f3f1d, 0xf03f1ffa,
	0xde54f172, 0xdd55a1f1, 0xdb5642b3, 0xda56837f, 0xd956d45a, 0xdc565536, 0xde55d61b, 0xe1552708, 0xe35487f9, 0xe85308f7, 0xec517a01, 0xee50eb04, 0xf0506c0b, 0xf1503d0c, 0xf1501e0f, 0xf14fef12, 0xf34fbff2,
	0xf163013b, 0xf063f1e9, 0xf064e2d8, 0xef6583ab, 0xf0661486, 0xf066155c, 0xf1662639, 0xf265f719, 0xf465b7fe, 0xf563f8f2, 0xf66229f7, 0xf6618af9, 0xf760ec00, 0xf760ad01, 0xf7607e04, 0xf8604f06, 0xf9600feb,
	0xfe7140b6, 0xff71b13e, 0x0172226a, 0x0472c376, 0x07736472, 0x0a741564, 0x0e74a64f, 0x0a73d725, 0x0872f80c, 0x057258ff, 0x0371b9fa, 0x03717af7, 0x02713bf5, 0x0270fcf6, 0x0270cdf9, 0x01708efd, 0x01704fe6,
	0xff803008, 0x00804039, 0x018051b2, 0x0980f314, 0x1281843f, 0x1f82755f, 0x2b836665, 0x1c824729, 0x00800800, 0x10813906, 0x138159fe, 0x14815af7, 0x15815bee, 0x13812ced, 0x1180edef, 0x0f80aef4, 0x0c805fe2,
	0x06902004, 0x0790300e, 0x08903188, 0x129082ef, 0x1b90d41f, 0x29913545, 0x3791b653, 0x2f91772e, 0x27912816, 0x2591090b, 0x2390fa02, 0x2390eafc, 0x2190dbf7, 0x1d90acf8, 0x1a907dfb, 0x17904eff, 0x15901feb,
	0x0fa02000, 0x0fa02004, 0x10a0214e, 0x16a042ba, 0x1ca053ec, 0x28a08513, 0x33a0a628, 0x3ea0c72c, 0x49a0f82a, 0x3fa0c914, 0x35a09a06, 0x30a08b00, 0x2ca06bfe, 0x26a04cff, 0x20a02e04, 0x1ea00f08, 0x1c9ffff4,
	0x19b03000, 0x19b03002, 0x1ab03113, 0x1fb03293, 0x24b033cb, 0x2db034f4, 0x36b0460b, 0x40b05717, 0x4ab0581b, 0x49b04912, 0x49b05a0a, 0x46b05b03, 0x43b04bfd, 0x36b02cfe, 0x2ab01e05, 0x28afff08, 0x25afeff8,
	0x24c03000, 0x24c03001, 0x24c030bf, 0x26c03263, 0x28c033a0, 0x2dc034c7, 0x31c025e0, 0x37c016f2, 0x3ec017fc, 0x4dc01909, 0x5cc00a0d, 0x5ec00b06, 0x5fbffbff, 0x4ac00cfe, 0x35c00e05, 0x31bfff09, 0x2ebfeffb,
	0x30d03000, 0x30d03000, 0x30d0304f, 0x31d03237, 0x33d03382, 0x35d024ae, 0x38d025c8, 0x3ed016dd, 0x42d007eb, 0x4fcff8fb, 0x5bcfea03, 0x63cfdb04, 0x6bcfcc02, 0x57cfecfe, 0x43cffe02, 0x3fcfff07, 0x39cffffd,
	0x3de04000, 0x3de04000, 0x3de04000, 0x3de04202, 0x3de0435e, 0x3de0348e, 0x3ee035ab, 0x41e036c3, 0x43e027d4, 0x4ae008e5, 0x52dff9f0, 0x63dfdafb, 0x75dfbc01, 0x64dfccfd, 0x52dffdff, 0x4bdfff03, 0x43e00ffe,
	0x4bf04000, 0x4bf04000, 0x4cf04000, 0x4cf041c7, 0x4cf0433c, 0x4cf04476, 0x4cf0459a, 0x4ef046b3, 0x4ff027c6, 0x53f028d7, 0x59f019e3, 0x64efeaf1, 0x71efcbf8, 0x6befdcf9, 0x65efddfb, 0x5deffeff, 0x54effffe,
	0x5bfff000, 0x5bfff000, 0x5bfff000, 0x5bfff17d, 0x5bfff317, 0x5bfff45c, 0x5bfff585, 0x5cfff6a1, 0x5cfff7b6, 0x5cfff8c6, 0x5dfff9d3, 0x62ffeae0, 0x66ffdbe9, 0x6fffbcf2, 0x79ffadf7, 0x71ffcefa, 0x68ffdffe,
	0xd9044022, 0xd7056112, 0xd4069210, 0xd406d30e, 0xd307140d, 0xd805250c, 0xdc03260c, 0xdf02170f, 0xe1010812, 0xe200a915, 0xe3004a17, 0xe4003b1a, 0xe4001c1d, 0xe4001d1f, 0xe5000e22, 0xe5002f23, 0xe6003ffe,
	0xd7138031, 0xd4146116, 0xd2153213, 0xd1156310, 0xd015a40e, 0xd513f50b, 0xda12260c, 0xdd10f70d, 0xe10fa811, 0xe20f0914, 0xe30e4a17, 0xe40dbb19, 0xe40d2c1d, 0xe50c9d1f, 0xe50bfe20, 0xe60b5f23, 0xe60a9ffe,
	0xd5235045, 0xd323f11d, 0xd0248218, 0xcf24c313, 0xce24f410, 0xd423a50c, 0xd922460b, 0xdd21470c, 0xe020380f, 0xe31fc912, 0xe41f3a16, 0xe41eeb19, 0xe61e9c1c, 0xe61e5d1e, 0xe61e1e20, 0xe71dbf22, 0xe71d7ffd,
	0xc33660c4, 0xc236b162, 0xc0371241, 0xbd37b330, 0xba384422, 0xc4368512, 0xcd34a609, 0xd4337706, 0xd9323807, 0xde31390a, 0xe2302a10, 0xe52fcb14, 0xe62f6c19, 0xe72f3d1b, 0xe72f0e1c, 0xe82edf1f, 0xe82e9ffb,
	0xb948016a, 0xb84831cd, 0xb7486284, 0xb3494361, 0xae4a1447, 0xba480523, 0xc645f60e, 0xce44a704, 0xd5435801, 0xdd420903, 0xe440ba0c, 0xe5403b0f, 0xe73fdc15, 0xe83fad17, 0xe83f7e19, 0xe93f6f1b, 0xea3f4ff8,
	0xc7564194, 0xc456d202, 0xc15772ba, 0xbe57f389, 0xbc589465, 0xc157b53b, 0xc656e61e, 0xcb56470a, 0xcf5587fb, 0xd753e8f6, 0xe15239fc, 0xe4519aff, 0xe750fc05, 0xe850ad07, 0xe9506e0a, 0xeb501f0e, 0xec4fdfef,
	0xd86501bd, 0xd465c23e, 0xd16692ff, 0xd066f3bd, 0xcf67448d, 0xd0675561, 0xd067663d, 0xd267171c, 0xd566c801, 0xdd6508f2, 0xe46339f2, 0xe8627af1, 0xea61bbf7, 0xec614cf8, 0xee60fdfd, 0xef60af01, 0xf0604fe8,
	0xef72511d, 0xee72c193, 0xed73329b, 0xec73d394, 0xeb748485, 0xea75256f, 0xea75c655, 0xec75272d, 0xee748810, 0xf073d8fd, 0xf17349f1, 0xf272fae8, 0xf472abe1, 0xf5720ce4, 0xf6717dec, 0xf6710ef3, 0xf7707fe2,
	0xf980904d, 0xfa80b08b, 0xfa80e1f1, 0xfd81a344, 0x00827466, 0x03837574, 0x0784666f, 0x0583973a, 0x0382c819, 0x0482f908, 0x068329f5, 0x07831ae4, 0x08831bd3, 0x06826cd4, 0x0481addd, 0x03812ee7, 0x01809fdd,
	0x0190502a, 0x0290603d, 0x029071ab, 0x0790d30d, 0x0c913437, 0x1491c558, 0x1c927661, 0x1c926743, 0x1c92582a, 0x1c924915, 0x1d924a01, 0x1c922af1, 0x1c920be3, 0x15918ce3, 0x1090fdec, 0x0d90aef4, 0x0a904fe7,
	0x06a02000, 0x06a02002, 0x06a0214b, 0x0aa042ba, 0x10a063ee, 0x1aa0b522, 0x25a1063c, 0x30a16746, 0x3ba1c841, 0x38a1a925, 0x36a18a0e, 0x31a16afb, 0x2da13bf0, 0x24a0dcef, 0x1aa07df8, 0x16a04efe, 0x11a00ff0,
	0x0fb03000, 0x0fb03001, 0x0fb0310f, 0x13b04294, 0x17b033cc, 0x20b054fe, 0x2ab0761b, 0x35b0972c, 0x41b0a831, 0x47b0c927, 0x4db0da19, 0x49b0cb06, 0x46b0bbf7, 0x37b08cf3, 0x26b03dfa, 0x22b02eff, 0x1caffff2,
	0x18c03000, 0x18c03000, 0x18c030bd, 0x1ac03264, 0x1cc033a2, 0x20c034ce, 0x26c035e7, 0x2fc026ff, 0x37c0280c, 0x4ec0391f, 0x65c03a22, 0x64c03b10, 0x62c03c00, 0x4bc02cf8, 0x35c00dfc, 0x2ec00f00, 0x27bffff5,
	0x23d03000, 0x23d03000, 0x23d0304c, 0x24d03237, 0x25d03383, 0x28d024b0, 0x2cd025cd, 0x32d016e6, 0x38d007f6, 0x4bcff90a, 0x5ccfda14, 0x66cfcb0f, 0x70cfbc07, 0x59cfdcfc, 0x43cfedfd, 0x3acfff01, 0x30cffff9,
	0x2ee04000, 0x2ee04000, 0x2ee04000, 0x2fe04201, 0x2fe0335d, 0x2fe0348e, 0x30e035ac, 0x32e036c4, 0x34e027d6, 0x3ce008e8, 0x44dff9f5, 0x5fdfbb05, 0x79df7c09, 0x66dfacff, 0x52dfddfd, 0x45dfef00, 0x39dffffc,
	0x3bf04000, 0x3bf04000, 0x3bf04000, 0x3bf041c6, 0x3bf0433c, 0x3bf04476, 0x3bf04599, 0x3df036b4, 0x3ff027c7, 0x44f018d9, 0x49f009e6, 0x5befcaf8, 0x6eef9c00, 0x65efacfc, 0x5defbdfb, 0x52efdefe, 0x47effffd,
	0x48fff000, 0x48fff000, 0x48fff000, 0x48fff17c, 0x49fff316, 0x49fff45b, 0x49fff585, 0x49fff6a1, 0x49fff7b6, 0x4bfff8c7, 0x4bfff9d3, 0x51ffdae1, 0x57ffcbec, 0x60ffbcf4, 0x68ff9df8, 0x5fffbefa, 0x54ffdffe,
	0xd305202a, 0xce071118, 0xca08f216, 0xc60a8314, 0xc30c0411, 0xcb08b50d, 0xd305560c, 0xd703870e, 0xdc01b811, 0xde011914, 0xdf006a17, 0xe0004b19, 0xe1001c1d, 0xe1001d1f, 0xe1001e22, 0xe2004f23, 0xe1007ffd,
	0xd0141036, 0xcb15711c, 0xc716f219, 0xc2186316, 0xbd19e413, 0xc716d50d, 0xd113b60c, 0xd612070c, 0xda10480f, 0xde0f4912, 0xe00e5a16, 0xe00dbb19, 0xe10d1c1b, 0xe10c8d1e, 0xe10bfe20, 0xe10b6f22, 0xe20abffc,
	0xce23a046, 0xc924c123, 0xc425d21e, 0xbf27331b, 0xb928a417, 0xc426150d, 0xd023660a, 0xd522370b, 0xda20e80e, 0xdd202911, 0xdf1f6a15, 0xe11f0b18, 0xe21e8c1b, 0xe11e5d1d, 0xe21e1e1f, 0xe21ddf20, 0xe31d8ffc,
	0xbc3690b4, 0xb937115c, 0xb6379240, 0xaa399338, 0x9f3b942e, 0xb038a516, 0xc135b60a, 0xc8347706, 0xcf331806, 0xd631d909, 0xdc30aa0e, 0xde302b12, 0xe22f8c17, 0xe22f5d18, 0xe22f2e1a, 0xe32eff1d, 0xe32ecff9,
	0xae482142, 0xac4851b3, 0xab488276, 0x9c4ad368, 0x8e4d1455, 0xa24a0529, 0xb746f611, 0xc0459706, 0xc8444801, 0xd242d902, 0xdb414a09, 0xde40bb0c, 0xe2401c12, 0xe23fed14, 0xe33fce16, 0xe33f9f18, 0xe43f6ff6,
	0xae57e1b9, 0xac585215, 0xa958b2c1, 0xa2599394, 0x9d5a9471, 0xa6595542, 0xaf582622, 0xb457670c, 0xbb56a7fc, 0xc654f8f6, 0xd25349f8, 0xd7528af9, 0xdc51abff, 0xde514d01, 0xe150de05, 0xe3507f0a, 0xe5501fed,
	0xb5678247, 0xb2681299, 0xaf68a32b, 0xaf68a3d1, 0xaf68a494, 0xb068a567, 0xb068b642, 0xb3686721, 0xb7680804, 0xc36648f2, 0xcf6469ed, 0xd5639aea, 0xdb62abee, 0xdf621cf0, 0xe2618df6, 0xe5610efb, 0xe8609fe5,
	0xd873c189, 0xd67421eb, 0xd47482cf, 0xd17533b4, 0xcd75e499, 0xca76757b, 0xc777065c, 0xca76c735, 0xcd767815, 0xd175e8fb, 0xd57549e9, 0xd874ead9, 0xdb747bce, 0xe1737cd2, 0xe6725ddf, 0xea719eea, 0xed70cfde,
	0xef812094, 0xef8160de, 0xee81b232, 0xea82b376, 0xe683c48e, 0xe484a58a, 0xe185a67b, 0xe385674e, 0xe685282a, 0xe585590c, 0xe78599ee, 0xe8858ad3, 0xea857bb9, 0xed841cbb, 0xf182bdcc, 0xf481dedb, 0xf580efd9,
	0xf9908052, 0xf990a06d, 0xf990b1d1, 0xfa91332b, 0xfb91c451, 0xfc92856c, 0xfe934671, 0x0093a75a, 0x01940840, 0x02941921, 0x03943a02, 0x04940ae7, 0x0493cbd0, 0x0392ccd0, 0x0191bdde, 0x00912ee8, 0xff908fe3,
	0xffa02000, 0xffa02000, 0xffa02147, 0x01a052ba, 0x03a083ef, 0x0aa11531, 0x10a1a653, 0x18a24761, 0x20a2e85c, 0x21a2e937, 0x22a2fa16, 0x20a2aaf9, 0x1da26be4, 0x16a1ace1, 0x0ea0fded, 0x0ba09ef5, 0x07a03fec,
	0x06b03000, 0x06b03000, 0x06b0310b, 0x09b03294, 0x0bb043cf, 0x12b0850a, 0x1bb0b62c, 0x24b0f743, 0x2eb13848, 0x37b1893d, 0x40b1ba29, 0x3cb1ab0b, 0x39b18bf2, 0x2bb11cea, 0x1db09df1, 0x18b06ef6, 0x13b02fed,
	0x0fc03000, 0x0fc03000, 0x0fc030ba, 0x10c03264, 0x12c033a4, 0x16c044d3, 0x1ac035f0, 0x23c0470d, 0x2cc0581d, 0x43c08936, 0x5cc0ba39, 0x59c0bb1a, 0x56c0bc01, 0x42c08cf2, 0x2dc04df4, 0x26c03ef8, 0x1fc00fef,
	0x18d03000, 0x18d03000, 0x18d03049, 0x19d03236, 0x1ad03383, 0x1dd034b4, 0x20d015d3, 0x27d016ef, 0x2dd01800, 0x41d0091b, 0x54cffa25, 0x5ecffb1c, 0x68cfec0d, 0x52cffcfb, 0x3cd00df8, 0x32cffefb, 0x27cffff5,
	0x22e04000, 0x22e04000, 0x22e03000, 0x22e03200, 0x22e0335c, 0x22e0348d, 0x23e035ac, 0x26e036c5, 0x28e027d6, 0x2fe008ec, 0x37dff9f9, 0x55dfbb0e, 0x73df7c13, 0x60df9d01, 0x4bdfbdfa, 0x3edfdefc, 0x2fdffff9,
	0x2df04000, 0x2df04000, 0x2df04000, 0x2df041c4, 0x2df0433b, 0x2df04476, 0x2df03599, 0x30f036b5, 0x31f027c7, 0x36f018db, 0x3beff9e9, 0x50efbaff, 0x65ef7c08, 0x5def9d00, 0x53efadfc, 0x47efdefd, 0x39efeffc,
	0x39fff000, 0x39fff000, 0x39fff000, 0x39fff17b, 0x39fff316, 0x39fff45b, 0x39fff584, 0x3afff6a1, 0x3afff7b5, 0x3bfff8c6, 0x3cfff9d4, 0x42ffdae3, 0x49ffcbee, 0x51ffacf5, 0x58ff8df9, 0x4effbefa, 0x43ffdffd,
	0xcf04f028, 0xca06f117, 0xc508f217, 0xba0d0318, 0xb0111416, 0xbb0d050e, 0xc608e60c, 0xce05e70c, 0xd602e80f, 0xd801f913, 0xdb00fa16, 0xdb00ab18, 0xdd005c1c, 0xdd006d1e, 0xdd007e20, 0xde009f21, 0xdd00cffc,
	0xce13a031, 0xc9151119, 0xc3167218, 0xb71a131a, 0xaa1da418, 0xb61a150f, 0xc316760b, 0xcb13e70b, 0xd311380e, 0xd70ff911, 0xda0eaa15, 0xdc0dfb18, 0xdd0d2c1a, 0xdd0cbd1d, 0xdd0c3e1e, 0xdd0b8f20, 0xdd0acffb,
	0xcc23403c, 0xc724511b, 0xc225521a, 0xb3286320, 0xa52b741d, 0xb2289511, 0xc125a60b, 0xca23b70a, 0xd221b80d, 0xd620b90f, 0xda1fba14, 0xdc1f3b17, 0xdd1ecc1a, 0xdd1e8d1b, 0xdd1e4e1d, 0xde1e0f1f, 0xde1daffb,
	0xba35d094, 0xb7366148, 0xb336f235, 0xa139f338, 0x8f3d0432, 0xa03a551a, 0xb037a60d, 0xbb35c707, 0xc633e806, 0xce327908, 0xd630fa0e, 0xd9306b10, 0xdc2fcc15, 0xdc2fad16, 0xdd2f6e19, 0xdd2f2f1a, 0xde2edff8,
	0xab474101, 0xa9477188, 0xa747b25e, 0x934aa35e, 0x7e4da453, 0x904b152c, 0xa3489614, 0xb046c708, 0xbd44f802, 0xc8435902, 0xd341aa08, 0xd7410b0b, 0xdb406c10, 0xdc403d13, 0xdd3ffe14, 0xde3fcf16, 0xdf3f7ff5,
	0xa257e184, 0x9f5861ef, 0x9b58d2ae, 0x905a438e, 0x845bb473, 0x8d5ab547, 0x9659b626, 0xa158670f, 0xac571800, 0xba5548f9, 0xc75379fb, 0xcd52cafb, 0xd3520bfe, 0xd6518d01, 0xda511e05, 0xdc50af0a, 0xdf503fed,
	0xa0681223, 0x9b68b27c, 0x9669531d, 0x9369c3d2, 0x906a249c, 0x906a356d, 0x916a3647, 0x9a694723, 0xa3685807, 0xb26678f7, 0xc16499f3, 0xc863daef, 0xcf630bef, 0xd3626cf2, 0xd961bdf7, 0xdc613efd, 0xe060afe6,
	0xc174d1b8, 0xbd754215, 0xb975c2eb, 0xb276a3cd, 0xab7784ae, 0xa977d585, 0xa6784661, 0xab77e739, 0xaf777818, 0xb87668ff, 0xc17569ef, 0xc4750ae2, 0xc874bbd7, 0xd073acd9, 0xd8727de4, 0xdf71beee, 0xe470efe1,
	0xdb82712b, 0xd982c171, 0xd6831291, 0xce8443b6, 0xc68574ba, 0xc386059c, 0xbe86967e, 0xc0868754, 0xc2868830, 0xc586190f, 0xc985b9f4, 0xcb85badd, 0xcd859bc6, 0xd5844cc7, 0xde82edd4, 0xe481fee1, 0xe980ffdc,
	0xee9100a4, 0xed9120c1, 0xed914209, 0xe991f354, 0xe6929471, 0xe293657e, 0xde94367a, 0xdd94a763, 0xdb952848, 0xde94d923, 0xe0948a05, 0xe2945aec, 0xe5941bd7, 0xe9931cd6, 0xee920de0, 0xf1915eea, 0xf390afe4,
	0xf8a02000, 0xf8a02000, 0xf8a02145, 0xf8a072c3, 0xf8a0c3fd, 0xf8a18544, 0xf7a25668, 0xf8a3176f, 0xf9a3e865, 0xfaa3a939, 0xfba37a17, 0xfba31afb, 0xfca2dbe7, 0xfca21ce2, 0xfca14dea, 0xfda0def3, 0xfca05fec,
	0xffb02000, 0xffb02000, 0xffb02109, 0x00b04296, 0x01b063d3, 0x05b0b517, 0x09b1163d, 0x0db17753, 0x12b1e858, 0x15b22945, 0x18b27a2d, 0x17b24b0c, 0x16b21bf3, 0x12b19ce8, 0x0db0fdeb, 0x09b0aef1, 0x07b04fea,
	0x06c03000, 0x06c03000, 0x06c030b7, 0x06c0325e, 0x07c0339b, 0x0ac044d5, 0x0ec055f8, 0x17c08721, 0x1ec0b837, 0x2cc1094a, 0x3bc16a47, 0x39c15b21, 0x37c15c02, 0x2bc0fcef, 0x1fc0aded, 0x1ac06ef0, 0x13c03fea,
	0x0ed03000, 0x0ed03000, 0x0ed03047, 0x0ed03232, 0x0fd0337e, 0x11d034b4, 0x14d025d7, 0x1cd026fc, 0x23d02811, 0x31d0392a, 0x3fd04a32, 0x49d04b26, 0x52d05c13, 0x43d04cfb, 0x33d03df3, 0x29d02ef2, 0x1fd00fee,
	0x17e03000, 0x17e03000, 0x17e03000, 0x17e031ff, 0x17e0335c, 0x17e0348c, 0x17e035ab, 0x1ae036c5, 0x1ce017d9, 0x24e008f2, 0x2ddffa01, 0x4ddfbb1e, 0x6ddf7c21, 0x5bdfad06, 0x48dfbdf8, 0x3adfdef5, 0x2cdffff1,
	0x21f04000, 0x21f04000, 0x21f04000, 0x21f041c3, 0x21f0433b, 0x21f04474, 0x22f03599, 0x23f036b4, 0x25f027c8, 0x2af018df, 0x30eff9ef, 0x48efab09, 0x5fef5c13, 0x56ef7d06, 0x4def9dfc, 0x40efbefa, 0x33efdff8,
	0x2cfff000, 0x2cfff000, 0x2cfff000, 0x2cfff17a, 0x2cfff315, 0x2cfff45a, 0x2cfff584, 0x2cfff6a1, 0x2cfff7b5, 0x2efff8c7, 0x2fffe9d5, 0x35ffdae5, 0x3bffbbf0, 0x44ff9cf8, 0x4cff7dfb, 0x41ffaefa, 0x37ffdffd,
	0xcc04a026, 0xc606c116, 0xc008d216, 0xad0fd31e, 0x9916d41d, 0xa711e512, 0xb50cf60c, 0xc208970b, 0xce04380f, 0xd202f911, 0xd601aa15, 0xd7011b17, 0xd8009c1a, 0xd900cd1c, 0xd900fe1d, 0xd9010f20, 0xd9010ffb,
	0xcc13002a, 0xc6147114, 0xc115d216, 0xaa1be320, 0x9421f420, 0xa31de513, 0xb219c60c, 0xbf16170a, 0xcb12580d, 0xd010b910, 0xd50f0a14, 0xd60e3b17, 0xd90d4c19, 0xd80ced1c, 0xd80c6e1d, 0xd90baf1f, 0xd90aeffa,
	0xcb22a031, 0xc6239112, 0xc2248215, 0xa8299324, 0x8e2ec425, 0x9e2b9515, 0xae28660d, 0xbb25970a, 0xc922c80c, 0xcf21690e, 0xd5200a13, 0xd61f8b15, 0xd81efc19, 0xd91ecd1a, 0xd91e8e1c, 0xd91e3f1d, 0xd91ddffa,
	0xbc34a06e, 0xb835312f, 0xb535b227, 0x9a3a0336, 0x7f3e6435, 0x8e3c251e, 0x9c39d610, 0xac375708, 0xbc34c806, 0xc6330908, 0xd0315a0c, 0xd230cb0f, 0xd5302c13, 0xd72fed15, 0xd72f9e17, 0xd82f5f19, 0xd92f1ff7,
	0xb045c0ba, 0xae460156, 0xab465242, 0x904a0352, 0x744dc450, 0x814c252f, 0x8d4a8618, 0x9f48270a, 0xb145c803, 0xbe43e903, 0xcc420a08, 0xd0416b0a, 0xd440cc0f, 0xd5408d10, 0xd6404e12, 0xd83fff14, 0xd93fbff4,
	0x9c57814c, 0x975811c5, 0x9258b297, 0x815ab387, 0x705cc474, 0x755c254b, 0x7c5b862c, 0x8e597713, 0x9f577803, 0xb05598fc, 0xbf53b9fd, 0xc4530afd, 0xca525bff, 0xce51dd01, 0xd2514e05, 0xd550cf09, 0xd8504fee,
	0x8f6891fd, 0x8869525e, 0x806a130f, 0x796ae3d3, 0x716bc4a5, 0x726bd574, 0x726be64d, 0x836a2725, 0x9468680b, 0xa56688fb, 0xb764b9f7, 0xbd641af3, 0xc3635bf1, 0xc962acf3, 0xcf61fdf9, 0xd5615eff, 0xd960bfe8,
	0xa67621e9, 0xa276a241, 0x9c77330a, 0x917853e9, 0x867974c6, 0x87798591, 0x86799666, 0x8d79073c, 0x9478681b, 0xa376e902, 0xb27569f4, 0xb5751ae9, 0xb974cbdf, 0xc373bce0, 0xcd72bde8, 0xd471def2, 0xdb70ffe4,
	0xbe8441c8, 0xba84a209, 0xb68502f4, 0xaa8643f9, 0x9e8774e8, 0x9d8795af, 0x9d87b682, 0x9c87d75b, 0x9b881837, 0xa886e912, 0xb485b9fa, 0xb685aae6, 0xb7859bd3, 0xc3845cd2, 0xce831ddb, 0xd8821ee7, 0xe0810fe0,
	0xdd91c0fa, 0xdc91e116, 0xda920242, 0xd392d380, 0xcb93a493, 0xc5946591, 0xbe953685, 0xb995d76e, 0xb4968851, 0xbd959925, 0xc694ba07, 0xc8948af1, 0xcb945bdf, 0xd4935cdb, 0xdc925de1, 0xe2918eec, 0xe990bfe6,
	0xf2a02000, 0xf2a02000, 0xf2a02143, 0xeea082cc, 0xeba1040d, 0xe3a22558, 0xdba3467e, 0xd5a4277e, 0xd0a5086f, 0xd5a4793b, 0xdaa3ca17, 0xdda38aff, 0xe0a33beb, 0xe5a28ce4, 0xeaa1bde8, 0xeea12ef1, 0xf2a07feb,
	0xf8b02000, 0xf8b02000, 0xf8b02107, 0xf7b05299, 0xf7b073d8, 0xf5b10523, 0xf4b1864d, 0xf2b22765, 0xf1b2d86a, 0xf2b3094f, 0xf2b33a32, 0xf3b30b0f, 0xf5b2cbf4, 0xf7b23ce6, 0xf8b18de5, 0xf9b10eeb, 0xfbb07fe7,
	0xffc03000, 0xffc03000, 0xffc030b4, 0xffc03257, 0xffc02392, 0x00c054d7, 0x02c07601, 0x05c0e737, 0x09c14852, 0x0ec1d960, 0x13c25a56, 0x13c23b29, 0x12c22c05, 0x0fc1acec, 0x0bc12de6, 0x09c0cee8, 0x06c06fe5,
	0x06d03000, 0x06d03000, 0x06d03044, 0x06d0322e, 0x06d02378, 0x08d024b5, 0x0ad035db, 0x0fd04708, 0x15d06823, 0x1cd0893b, 0x25d0aa3f, 0x2cd0db32, 0x33d0fc1b, 0x2ad0ccfb, 0x21d09ded, 0x1bd06eeb, 0x14d02fe7,
	0x0ee03000, 0x0ee03000, 0x0ee03000, 0x0ee031fd, 0x0ee0335b, 0x0ee0348b, 0x0ee035a9, 0x10e026c6, 0x12e027db, 0x19e018f9, 0x20e01a0a, 0x3bdffb2f, 0x57dfdc31, 0x49dfed0b, 0x39dffdf5, 0x2edffeee, 0x23dfffea,
	0x17f04000, 0x17f04000, 0x17f04000, 0x17f041c2, 0x17f0433a, 0x17f03474, 0x17f03597, 0x18f036b5, 0x19f027ca, 0x20f018e3, 0x25eff9f4, 0x3aefab15, 0x4fef5c20, 0x48ef7d0c, 0x41ef9dfe, 0x35efbef7, 0x29efdff5,
	0x20fff000, 0x20fff000, 0x20fff000, 0x20fff178, 0x21fff314, 0x21fff45a, 0x21fff584, 0x21fff6a0, 0x21fff7b5, 0x22fff8c7, 0x23ffe9d6, 0x29ffdae6, 0x2effbbf2, 0x36ff9cfa, 0x3eff7dfc, 0x35ffaefa, 0x2bffdffc,
	0xca03f020, 0xc505a10f, 0xc0076213, 0xab0e731d, 0x9515941e, 0xa0121513, 0xab0e960d, 0xb909e70c, 0xc805280d, 0xcd038910, 0xd201da15, 0xd3016b17, 0xd400ec1a, 0xd4010d1c, 0xd5013e1d, 0xd5013f1f, 0xd5013ffa,
	0xc9125024, 0xc413810d, 0xc014a212, 0xa91a931d, 0x92209420, 0x9d1db514, 0xa81ad60d, 0xb716d70a, 0xc512b80d, 0xcb10e910, 0xd10f0a13, 0xd20e3b16, 0xd40d6c19, 0xd40ced1a, 0xd40c5e1c, 0xd40b9f1e, 0xd50acffa,
	0xc9224029, 0xc5230109, 0xc123c20f, 0xa828a320, 0x8f2d9424, 0x992b6516, 0xa529360e, 0xb426270a, 0xc322e80c, 0xca21890e, 0xd1200a12, 0xd31f8b15, 0xd41f0c18, 0xd41ecd1a, 0xd51e8e1b, 0xd51e3f1d, 0xd51dcffa,
	0xbe33b053, 0xbb34311a, 0xb834a21c, 0xa038532b, 0x883c042d, 0x8f3ae51d, 0x9739c611, 0xa737270a, 0xb8348809, 0xc232e90a, 0xcc313a0e, 0xcf30bb10, 0xd1302c14, 0xd32ffd15, 0xd32fbe17, 0xd42f5f19, 0xd52f0ff7,
	0xb5447086, 0xb344c130, 0xb045122b, 0x9a47e33b, 0x834ac43c, 0x884a5528, 0x8b49d619, 0x9d47970c, 0xae455807, 0xbb43a906, 0xc841ea0a, 0xcb415b0c, 0xd040cc0f, 0xd1408d11, 0xd2404e13, 0xd33fff15, 0xd63faff5,
	0xa555d0ea, 0x9d56b17e, 0x95579271, 0x8359836b, 0x725b745f, 0x775af540, 0x7b5a8628, 0x8d58a713, 0x9e56c806, 0xad550901, 0xbd534a03, 0xc152bb02, 0xc5523c03, 0xca51bd05, 0xcd512e08, 0xd150bf0d, 0xd5503ff1,
	0x9966a160, 0x8d67d1e9, 0x806902d2, 0x736a53b1, 0x666b9493, 0x6b6b2564, 0x706ab642, 0x81693722, 0x9167a80d, 0xa265e901, 0xb46419fd, 0xb9639afa, 0xbe631bf9, 0xc4627cfb, 0xca61ddff, 0xd0612f05, 0xd5608fed,
	0xa7751167, 0x9e75d1d2, 0x9676a2cc, 0x827863cc, 0x6f7a14bd, 0x7379c586, 0x7879865c, 0x7f78e737, 0x8678481b, 0x9976a906, 0xab74f9fb, 0xb0749af2, 0xb5742bec, 0xbe734cee, 0xc7725df4, 0xd0719efc, 0xd770bfea,
	0xb683e168, 0xb18451a9, 0xac84c2b9, 0x9486b3e8, 0x7d88b4f0, 0x7f8895b0, 0x8288667e, 0x83887757, 0x83887835, 0x9686e913, 0xa88559ff, 0xac851af0, 0xb084cbe4, 0xbc83bce3, 0xc882adeb, 0xd181bef4, 0xda80dfe8,
	0xd491b0d3, 0xd09200fb, 0xcd924238, 0xbc93a397, 0xab9514bd, 0xa395c5ab, 0x9b967693, 0x9896c771, 0x9697084f, 0xa1962925, 0xae953a09, 0xb6948af7, 0xbe93ebeb, 0xc892fce9, 0xd3920def, 0xda915ef7, 0xe1909fec,
	0xeba0401f, 0xe9a06039, 0xe7a08180, 0xdca1831e, 0xd1a27467, 0xc3a3a596, 0xb5a4d6a8, 0xb1a5478c, 0xaca5c86d, 0xb3a5393f, 0xbaa4ba1b, 0xc4a3eb01, 0xcda31bf3, 0xd5a25cee, 0xdda18df2, 0xe4a0fef9, 0xe9a05ff0,
	0xf1b03011, 0xf1b0401f, 0xf0b05129, 0xecb0b2cb, 0xe8b10412, 0xe1b1b554, 0xd9b27676, 0xd3b3177c, 0xceb3b875, 0xccb3e955, 0xcbb41a35, 0xd1b3bb11, 0xd6b33bf7, 0xdeb26ceb, 0xe6b18ded, 0xebb10ef3, 0xefb07fec,
	0xf8c03000, 0xf8c03000, 0xf8c020b1, 0xf8c0225c, 0xf8c0339c, 0xf5c094f3, 0xf2c0e627, 0xeec1875b, 0xebc22873, 0xe8c2a96d, 0xe6c32a59, 0xe8c2fb2c, 0xeac2dc08, 0xefc21cef, 0xf3c15dec, 0xf6c0eeee, 0xf8c07fe9,
	0xffd03000, 0xffd03000, 0xffd02040, 0xffd02231, 0xffd0237e, 0xffd044c5, 0x00d055f1, 0x01d08722, 0x02d0c83d, 0x03d1094c, 0x05d13a4b, 0x07d17b39, 0x09d1ac1d, 0x08d15cfc, 0x07d10dec, 0x05d0cee7, 0x05d07fe2,
	0x06e03000, 0x06e03000, 0x06e03000, 0x06e031fc, 0x06e0335a, 0x06e0348b, 0x06e035a9, 0x08e026d0, 0x0ae027eb, 0x0fe03912, 0x15e03a27, 0x20e05b3c, 0x2be06c37, 0x27e06d0e, 0x22e06df3, 0x1de04ee6, 0x17e03fdf,
	0x0ef04000, 0x0ef04000, 0x0ef04000, 0x0ef031c0, 0x0ef03339, 0x0ef03473, 0x0ef03597, 0x10f036ba, 0x11f027d3, 0x16f008f2, 0x1ceffa06, 0x27efcb1e, 0x32efac23, 0x30efad0f, 0x2fefbe00, 0x29efcef5, 0x21efdfee,
	0x17fff000, 0x17fff000, 0x17fff000, 0x17fff176, 0x17fff313, 0x17fff459, 0x17fff583, 0x17fff6a0, 0x17fff7b5, 0x18fff8c7, 0x18fff9d5, 0x1cffdae6, 0x20ffcbf1, 0x28ffacfc, 0x2fff8dfe, 0x2bff9efa, 0x26ffbff9,
	0xc9032019, 0xc5045107, 0xc105920d, 0xaa0cb31b, 0x9413e41e, 0x9a120515, 0xa010360f, 0xb00b370d, 0xc006380d, 0xc7042910, 0xce021a14, 0xcf01ab17, 0xd0014c19, 0xd0015d1b, 0xd1017e1c, 0xd1016f1e, 0xd1016ffa,
	0xc811901c, 0xc5126104, 0xc113220c, 0xaa18e31b, 0x931e941e, 0x981d4516, 0x9d1bf60f, 0xae17870c, 0xc013180d, 0xc611190f, 0xcd0efa13, 0xce0e3b16, 0xd10d6c19, 0xd00ced1a, 0xd00c5e1c, 0xd00b9f1d, 0xd10abffa,
	0xc821a020, 0xc52230ff, 0xc222c209, 0xab27331b, 0x932ba420, 0x972ae517, 0x9b2a2610, 0xad26970c, 0xbf23180d, 0xc721890f, 0xce200a12, 0xcf1f9b15, 0xd01f1c18, 0xd01eed19, 0xd01e9e1a, 0xd11e3f1d, 0xd11ddff9,
	0xc3325034, 0xc032c101, 0xbd33320d, 0xab35f31d, 0x9938b421, 0x9739051a, 0x94396613, 0xa536c70b, 0xb634280a, 0xbf32a90b, 0xc8311a0f, 0xcb30ab11, 0xcd303c14, 0xce2ffd15, 0xce2fbe17, 0xd02f5f1a, 0xd12efff8,
	0xbf42a04d, 0xbc430103, 0xb9435212, 0xac44f31e, 0x9f469422, 0x9747a51d, 0x8e48a617, 0x9e46a70d, 0xaf44a809, 0xba432909, 0xc641ba0c, 0xc8413b0e, 0xcb40cc10, 0xcc409d12, 0xcd404e14, 0xd03fff16, 0xd13f9ff7,
	0xb6537080, 0xab54a12f, 0x9f55e246, 0x8f57934c, 0x7e595447, 0x81592533, 0x8358f622, 0x92576713, 0xa055c809, 0xaf543906, 0xbe52aa07, 0xc0524b07, 0xc351ec08, 0xc6518d0a, 0xca510e0c, 0xcd508f10, 0xd1500ff4,
	0xaf63e0bc, 0x9c65b16b, 0x8867728f, 0x7669338b, 0x636af47e, 0x6f69f552, 0x7a68f634, 0x8767a71c, 0x9566680e, 0xa664d905, 0xb7633a03, 0xba62eb02, 0xbd62ac00, 0xc2620d02, 0xc7618e05, 0xcc60ff0b, 0xd2604ff2,
	0xb27390df, 0xa574a15c, 0x9975b289, 0x7b7823ae, 0x5e7a94b3, 0x6679e57a, 0x70792651, 0x78788732, 0x8077e81b, 0x96760908, 0xac742a01, 0xb173bafb, 0xb7734bf8, 0xbf728cfa, 0xc671ddff, 0xcd711f06, 0xd4707ff0,
	0xb7833105, 0xb083b145, 0xa984327a, 0x838723d8, 0x5d8a04f8, 0x648975b0, 0x6c89067a, 0x6e88d754, 0x7288a834, 0x8b86b913, 0xa584aa02, 0xab842af9, 0xb3839bf3, 0xbd82ccf4, 0xc781edf9, 0xd0813f00, 0xd7808fef,
	0xcd91a0ab, 0xc79210e0, 0xc192722d, 0xa394a3b1, 0x8596d4e8, 0x7d9765c5, 0x7697f6a3, 0x7a97c773, 0x7d97884c, 0x8c968926, 0x9a958a0b, 0xaa945afb, 0xbb932bf6, 0xc5926cf6, 0xcf919dfb, 0xd690ff02, 0xdd906ff2,
	0xe2a0803f, 0xdda0d074, 0xd8a131c0, 0xc0a2c373, 0xa9a454c5, 0x97a595d7, 0x85a6d6d4, 0x89a6979a, 0x8da6686a, 0x93a61941, 0x97a5ca1f, 0xafa43b03, 0xc4a2abf9, 0xcea1fcf8, 0xd7a13dfd, 0xdda0bf02, 0xe4a03ff4,
	0xeab05022, 0xe8b0703e, 0xe5b0914d, 0xdcb132ff, 0xd2b1d44d, 0xc4b2c586, 0xb7b3b6a1, 0xb0b43795, 0xa8b4c880, 0xa7b4e95c, 0xa7b50a39, 0xb1b45b13, 0xbdb39bfa, 0xccb28cf0, 0xdab17df5, 0xe0b0fefa, 0xe7b06ff0,
	0xf2c02000, 0xf2c02000, 0xf2c020ad, 0xf1c03263, 0xf0c043a7, 0xe6c0e511, 0xddc1964e, 0xd0c26781, 0xc3c35895, 0xc0c3a97b, 0xbcc3fa5b, 0xc0c3db2f, 0xc3c3ac0b, 0xd3c29cf2, 0xe1c16df1, 0xe8c0fef3, 0xedc07fed,
	0xf8d02000, 0xf8d02000, 0xf8d0203c, 0xf8d02234, 0xf7d03384, 0xf5d064d6, 0xf2d09608, 0xedd0f73c, 0xe9d15858, 0xe5d1a95f, 0xe2d1fa58, 0xe0d23b40, 0xdfd27c21, 0xe4d20cff, 0xead18deb, 0xefd13ee4, 0xf3d0cfdd,
	0xfee03000, 0xfee03000, 0xfee03000, 0xffe031fa, 0xffe03359, 0xffe0348a, 0xffe025a8, 0xffe036d9, 0xfee047fa, 0xfee0792c, 0xfde0aa45, 0xfee0eb4b, 0xfee13c3c, 0xffe11d13, 0x00e11df3, 0x01e0eedf, 0x01e09fd5,
	0x06f03000, 0x06f03000, 0x06f03000, 0x06f031be, 0x06f03338, 0x06f03472, 0x06f03596, 0x07f036bf, 0x08f027dc, 0x0af01902, 0x0df00a18, 0x11f00b27, 0x15effc27, 0x16effd14, 0x17effe01, 0x15f00ef3, 0x12efffe8,
	0x0dfff000, 0x0dfff000, 0x0efff000, 0x0efff174, 0x0efff312, 0x0efff459, 0x0efff583, 0x0efff69f, 0x0efff7b4, 0x0efff8c5, 0x0efff9d4, 0x11ffeae5, 0x14ffdbf1, 0x19ffbcfd, 0x1eff9e00, 0x1effaefb, 0x1cffbff6,
	0xc7029015, 0xc5036100, 0xc2043208, 0xb0099315, 0x9e0ef419, 0xa00e6514, 0xa20de610, 0xaf09c70d, 0xbd05b80f, 0xc403c910, 0xcb01ca14, 0xcd016b18, 0xce00fc1a, 0xcd012d1b, 0xcd016e1d, 0xce016f1e, 0xce017ffa,
	0xc710d017, 0xc41160fc, 0xc211f206, 0xb0164314, 0x9d1a7419, 0x9f1a2514, 0xa019c610, 0xae16370c, 0xbd12780f, 0xc4108910, 0xcb0e7a14, 0xcc0dbb16, 0xce0cdc1a, 0xce0c7d1b, 0xcd0c0e1c, 0xcd0b5f1e, 0xcd0a7ffa,
	0xc7213019, 0xc52180f7, 0xc321e203, 0xb1254314, 0x9f289419, 0x9f288515, 0x9f286610, 0xae25870c, 0xbd22b80d, 0xc321390f, 0xca1fba13, 0xcd1f3b16, 0xce1ebc18, 0xce1e9d19, 0xcd1e7e1b, 0xcd1e1f1e, 0xce1dcffa,
	0xc431a026, 0xc231f0f3, 0xc0324203, 0xb2344312, 0xa4366418, 0xa036f515, 0x9c379611, 0xaa35770d, 0xb833480c, 0xc031f90d, 0xc8309a11, 0xc9304b12, 0xcb2fec15, 0xcc2fbd17, 0xcc2f9e18, 0xcc2f4f1b, 0xce2eeff9,
	0xc141e035, 0xbf4210ec, 0xbe425202, 0xb3439311, 0xa944c416, 0xa145c517, 0x9946c614, 0xa645270d, 0xb343880b, 0xbc42490b, 0xc6410a0e, 0xc840cb10, 0xc9408c12, 0xca406d14, 0xcb401e16, 0xcc3fdf18, 0xcd3f7ff8,
	0xbc525052, 0xb25350ff, 0xa9545223, 0x9d55832d, 0x9256b42d, 0x8f56f525, 0x8d57461c, 0x9955f711, 0xa554a80b, 0xb2535908, 0xbe520a0a, 0xc051db0b, 0xc1518c0b, 0xc4513d0e, 0xc850ce0f, 0xcb506f14, 0xce4fdff6,
	0xb8629073, 0xa8641118, 0x9765a251, 0x8a66c354, 0x7f67e44f, 0x8167a539, 0x84676628, 0x90665718, 0x9b65580d, 0xa9640907, 0xb762aa07, 0xb9626b06, 0xbb623c05, 0xc061bd07, 0xc5614e0a, 0xca60af10, 0xcf602ff5,
	0xb972808f, 0xac738108, 0x9f74924f, 0x8276e37d, 0x6679348a, 0x6978f564, 0x6c78b647, 0x7678072d, 0x7f774819, 0x9375990a, 0xa873ea04, 0xae736b00, 0xb572dbff, 0xbc722d01, 0xc4718e05, 0xca70ef0b, 0xd2703ff4,
	0xba8260ae, 0xb08310f2, 0xa783c24b, 0x7d86e3b2, 0x5289f4da, 0x5689a5a0, 0x5b896673, 0x6288e74e, 0x6988682f, 0x83868913, 0x9c84aa05, 0xa683fafd, 0xb0832bfa, 0xba827cfc, 0xc481ae00, 0xcc810f07, 0xd3805ff4,
	0xcb916081, 0xc291f0bf, 0xb892921c, 0x939503a7, 0x6e9774e2, 0x649835c3, 0x5a98e6a3, 0x61987771, 0x6898084a, 0x79970926, 0x8895fa0d, 0x9c949afe, 0xb0933bfa, 0xbd925cfa, 0xc9917dff, 0xd090ef06, 0xd9903ff5,
	0xd9a0a04b, 0xd1a1208e, 0xc9a1a1dc, 0xa9a39391, 0x89a574e3, 0x74a6d5ea, 0x5ea826df, 0x66a7c7a0, 0x6ca7686e, 0x74a70943, 0x7ca68a21, 0x98a4db05, 0xb4a31bfb, 0xc1a22cf9, 0xcea15dfe, 0xd6a0cf05, 0xdfa02ff7,
	0xe3b0502b, 0xdfb0804f, 0xdbb0b15f, 0xcbb1a31d, 0xbab29472, 0xa6b3c5a7, 0x92b4e6be, 0x89b577a6, 0x81b5f88b, 0x84b5d960, 0x87b5ba39, 0x96b4eb15, 0xa4b42bfd, 0xbab2dcf3, 0xcfb19df7, 0xd8b0fefc, 0xe0b06ff3,
	0xecc02005, 0xecc02006, 0xebc020b0, 0xe6c07283, 0xe1c0b3d5, 0xcfc1a544, 0xbdc28684, 0xabc387a4, 0x98c488ac, 0x98c49981, 0x98c4ba59, 0x9cc49b30, 0xa0c46c0d, 0xb9c30cf5, 0xd2c19df4, 0xdbc10ef7, 0xe4c07ff0,
	0xf1d03011, 0xf1d03010, 0xf1d03047, 0xf0d0424a, 0xeed0539e, 0xe7d0a4f5, 0xe0d0f62a, 0xd5d17758, 0xcbd1f870, 0xc4d2596d, 0xbdd2ca60, 0xbbd2fb42, 0xb8d32c23, 0xc3d2ad01, 0xced21dec, 0xd8d19ee6, 0xe2d10fe0,
	0xf7e0401f, 0xf7e0401c, 0xf7e03019, 0xf8e03204, 0xf8e0235b, 0xf8e0248e, 0xf7e025af, 0xf3e056ec, 0xefe08813, 0xe6e0e945, 0xdee14a5d, 0xd9e19b53, 0xd4e1ec3c, 0xd5e1dd16, 0xd8e1cdf4, 0xe1e17ee0, 0xe9e10fd6,
	0xfef03015, 0xfef03013, 0xfef03012, 0xfef031c4, 0xfff03339, 0xfff03475, 0xfff0359a, 0xfef026c9, 0xfdf037ea, 0xfcf03910, 0xfaf04a26, 0xf9f04b2a, 0xf9f05c26, 0xf9f05d16, 0xf9f06e04, 0xfbf05ef2, 0xfcf04fe4,
	0x06fff00b, 0x06fff00a, 0x06fff009, 0x06fff175, 0x06fff311, 0x06fff458, 0x06fff582, 0x06fff69f, 0x06fff7b4, 0x06fff8c5, 0x06fff9d2, 0x06fffae3, 0x07ffebef, 0x0affdcff, 0x0cffbe02, 0x0dffbefb, 0x0effbfef,
	0xc501e00f, 0xc40240f6, 0xc302a202, 0xb705f30d, 0xab094412, 0xa80a2511, 0xa50b1610, 0xb008170f, 0xba052810, 0xc2034911, 0xc8016a15, 0xca010b17, 0xcb009c1b, 0xca00fd1c, 0xc9015e1d, 0xc8016f1f, 0xc9017ffa,
	0xc5100010, 0xc41040f3, 0xc31081ff, 0xb713030b, 0xac158411, 0xa9164510, 0xa5170610, 0xb014670e, 0xbb11b80f, 0xc10fd911, 0xc80dea14, 0xc90d1b17, 0xcb0c3c1b, 0xca0c0d1c, 0xc80bae1c, 0xc90b0f1e, 0xc90a4ffa,
	0xc6209012, 0xc520b0ec, 0xc420d1fc, 0xb922c309, 0xae24a40f, 0xaa256510, 0xa6262610, 0xb024270d, 0xba22280e, 0xc120c910, 0xc71f5a13, 0xc91edb16, 0xcb1e4c1a, 0xca1e4d1a, 0xc91e4e1c, 0xc91def1d, 0xc91daffa,
	0xc430c016, 0xc330e0e2, 0xc23111f8, 0xba323306, 0xb233540d, 0xac34450f, 0xa635260f, 0xb033a70d, 0xba32280d, 0xc131190f, 0xc72ffa13, 0xc82fcb14, 0xc82f8c17, 0xc92f7d19, 0xc82f5e19, 0xc92f1f1c, 0xc92edff9,
	0xc440e01b, 0xc440e0d2, 0xc34101f1, 0xbe41b301, 0xb8427409, 0xb043550e, 0xa944360f, 0xb243270c, 0xba42080c, 0xc141290e, 0xc8403a11, 0xc7403b12, 0xc6404c14, 0xc6401d15, 0xc83ffe17, 0xc93faf1a, 0xca3f6ff9,
	0xc650d020, 0xbe5190c9, 0xb75241fc, 0xb352c30a, 0xae53440f, 0xa6541513, 0x9e54f613, 0xa654070e, 0xaf53080b, 0xb752290b, 0xc0513a0d, 0xc1512b0e, 0xc1511c0e, 0xc350cd10, 0xc5508e13, 0xc8501f17, 0xcb4faff9,
	0xc760d026, 0xba6200be, 0xad63220c, 0xaa637317, 0xa663b419, 0x9e64851b, 0x9565461b, 0x9d648712, 0xa663b80c, 0xb062d909, 0xb961ea0a, 0xba61cb0a, 0xbc619c0a, 0xc0613d0c, 0xc360de0e, 0xc8606f13, 0xcd5fdff8,
	0xc571203b, 0xb87220ad, 0xab732212, 0x91752347, 0x7777345c, 0x7277954b, 0x6e77f63c, 0x79771726, 0x84764816, 0x9574e90b, 0xa6737a06, 0xae72eb04, 0xb6724c05, 0xbc71bd07, 0xc2711e0a, 0xc9708f11, 0xcf6ffff8,
	0xc4814053, 0xb782309a, 0xaa831218, 0x7c86438a, 0x4e8984b9, 0x4e89958f, 0x4e89966c, 0x5b88b746, 0x6787e82a, 0x7f863913, 0x96849a07, 0xa3839b01, 0xb1829c01, 0xba81ed03, 0xc3813e07, 0xca80bf0d, 0xd2800ff8,
	0xca910056, 0xbd91d09e, 0xb092a20c, 0x8595539c, 0x599824db, 0x4c98f5c0, 0x3f99d6a3, 0x4b99276f, 0x56986847, 0x68975926, 0x78965a0e, 0x9194bb00, 0xa9933bfd, 0xb6924cfe, 0xc4915e03, 0xcc90bf0a, 0xd5900ff9,
	0xcfa0e058, 0xc3a190a9, 0xb7a241f9, 0x8ea493b0, 0x65a6d502, 0x4fa825fe, 0x37a996ec, 0x41a907a7, 0x4ca87871, 0x57a7d946, 0x62a74a24, 0x83a56b07, 0xa3a36bfc, 0xb4a26cfa, 0xc7a14e00, 0xd0a0af07, 0xd9a00ffa,
	0xdab07034, 0xd5b0b060, 0xcfb10170, 0xb7b2433d, 0x9eb38497, 0x83b4f5c9, 0x68b656dc, 0x60b6c7ba, 0x58b74897, 0x62b6c964, 0x6bb66a3a, 0x7bb59b17, 0x8bb4bbff, 0xa7b32cf5, 0xc4b19dfa, 0xcfb0feff, 0xdab05ff6,
	0xe5c03009, 0xe5c0300c, 0xe4c030b2, 0xd9c0b2a2, 0xcdc13404, 0xb1c28579, 0x94c3e6ba, 0x7dc4f7c9, 0x68c5f8c4, 0x70c5b987, 0x78c55a57, 0x7bc53b31, 0x7fc52c10, 0xa2c37cf7, 0xc5c1adf7, 0xd0c11efa, 0xddc07ff3,
	0xe8d04022, 0xe8d04021, 0xe8d04052, 0xe4d06260, 0xe0d093bb, 0xd4d11516, 0xc8d1964c, 0xb8d23776, 0xa7d2d889, 0x9fd3497c, 0x97d3aa68, 0x95d3cb46, 0x94d3dc24, 0xa3d34d03, 0xb1d2bdee, 0xc1d1fee7, 0xd2d13fe1,
	0xede0403e, 0xeee04038, 0xeee03033, 0xefe0320c, 0xf0e0235d, 0xf0e03493, 0xefe035b4, 0xe4e096fe, 0xd9e0e82c, 0xc7e19961, 0xb4e23a77, 0xb1e25b5b, 0xaee28c3c, 0xade29d18, 0xade2bdf5, 0xbee20ee0, 0xd0e16fd7,
	0xf5f0302b, 0xf5f03027, 0xf6f03023, 0xf6f031ca, 0xf7f03339, 0xf7f03477, 0xf6f0259d, 0xf3f036d4, 0xeff057f8, 0xe8f07920, 0xe2f09a35, 0xe1f0ab2e, 0xe0f0ac23, 0xdcf0cd18, 0xd9f0ee06, 0xddf0def2, 0xe0f0bfdf,
	0xfdfff016, 0xfdfff014, 0xfdfff012, 0xfdfff176, 0xfdfff310, 0xfdfff457, 0xfdfff581, 0xfdfff69f, 0xfefff7b3, 0xfefff8c4, 0xfefff9d1, 0xfdfffae1, 0xfdfffbec, 0xf9fffd00, 0xf7fffe05, 0xf5fffefc, 0xf4ffffea,
};

static u32 gmp_lut_table_high4bit_init[4913] = {
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x2,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x2, 0x2, 0x2,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x4, 0x4, 0x4, 0x3, 0x3,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x4, 0x4, 0x4, 0x4, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x5, 0x5, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x5, 0x5, 0x5, 0x5, 0x5, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x6, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x7, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0x9,
	0x9, 0x9, 0x9, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
};

#define XCC_COEF_LEN	12
#define XCC_COEF_INDEX_01	1
#define XCC_COEF_INDEX_12	6
#define XCC_COEF_INDEX_23	11
#define GMP_BLOCK_SIZE	137
#define GMP_CNT_NUM 18
#define GMP_COFE_CNT 4913   //17*17*17

static u32 gmp_lut_table_low32bit_wq_doing[GMP_COFE_CNT] = { 0 };
static u32 gmp_lut_table_high4bit_wq_doing[GMP_COFE_CNT] = { 0 };

static inline long get_timestamp_in_us(void)
{
	struct timespec ts;
	long timestamp;
	ktime_get_ts(&ts);
	timestamp = ts.tv_sec * USEC_PER_SEC + ts.tv_nsec / NSEC_PER_USEC;
	return timestamp;
}

static inline void count_delay(delay_record_t *record, long delay)
{
	if (NULL == record) {
		return;
	}
	record->count++;
	record->sum += delay;
	if (delay > record->max) record->max = delay;
	if (delay < record->min) record->min = delay;
	if (!(record->count % COUNT_LIMIT_TO_PRINT_DELAY)) {
		DEBUG_EFFECT_LOG("[effect] Delay(us/%4d) | average:%5ld | min:%5ld | max:%8ld | %s\n", record->count, record->sum / record->count, record->min, record->max, record->name);
		record->count = 0;
		record->sum = 0;
		record->max = 0;
		record->min = 0xFFFFFFFF;
	}
}

static inline uint32_t get_fixed_point_offset(uint32_t half_block_size)
{
	uint32_t num = 2;
	uint32_t len = 2;
	while (len < half_block_size) {
		num++;
		len <<= 1;
	}
	return num;
}

#define ACM_HUE_LUT_LENGTH ((uint32_t)256)
#define ACM_SATA_LUT_LENGTH ((uint32_t)256)
#define ACM_SATR_LUT_LENGTH ((uint32_t)64)

#define LCP_GMP_LUT_LENGTH	((uint32_t)17*17*17)
#define LCP_XCC_LUT_LENGTH	((uint32_t)12)

#define IGM_LUT_LEN ((uint32_t)257)
#define GAMMA_LUT_LEN ((uint32_t)257)

#define HIACE_DETAIL_WEIGHT_TABLE_LEN 33
#define HIACE_LOGLUM_EOTF_TABLE_LEN 63
#define HIACE_LUMA_GAMA_TABLE_LEN 63

#define BYTES_PER_TABLE_ELEMENT 4

static int hisi_effect_copy_to_user(uint32_t *table_dst, uint32_t *table_src, uint32_t table_length)
{
	unsigned long table_size = 0;

	if ((NULL == table_dst) || (NULL == table_src) || (table_length == 0)) {
		HISI_FB_ERR("invalid input parameters.\n");
		return -EINVAL;
	}

	table_size = (unsigned long)table_length * BYTES_PER_TABLE_ELEMENT;

	if (copy_to_user(table_dst, table_src, table_size)) {
		HISI_FB_ERR("failed to copy table to user.\n");
		return -EINVAL;
	}

	return 0;
}

static int hisi_effect_alloc_and_copy(uint32_t **table_dst, uint32_t *table_src,
	uint32_t lut_table_length, bool copy_user)
{
	uint32_t *table_new = NULL;
	unsigned long table_size = 0;

	if ((NULL == table_dst) ||(NULL == table_src) ||  (lut_table_length == 0)) {
		HISI_FB_ERR("invalid input parameter");
		return -EINVAL;
	}

	table_size = (unsigned long)lut_table_length * BYTES_PER_TABLE_ELEMENT;

	if (*table_dst == NULL) {
		table_new = (uint32_t *)kmalloc(table_size, GFP_ATOMIC);
		if (table_new) {
			memset(table_new, 0, table_size);
			*table_dst = table_new;
		} else {
			HISI_FB_ERR("failed to kmalloc lut_table!\n");
			return -EINVAL;
		}
	}

	if (copy_user) {
		if (copy_from_user(*table_dst, table_src, table_size)) {
			HISI_FB_ERR("failed to copy table from user\n");
			if (table_new)
				kfree(table_new);
			*table_dst = NULL;
			return -EINVAL;
		}
	} else {
		memcpy(*table_dst, table_src, table_size);
	}

	return 0;
}

static void hisi_effect_kfree(uint32_t **free_table)
{
	if (*free_table) {
		kfree((uint32_t *) *free_table);
		*free_table = NULL;
	}
}
static int hisifb_ce_do_contrast(struct hisi_fb_data_type *hisifd)
{
	ce_service_t *service = &g_hiace_service;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	if (g_is_ce_service_init) {
		service->new_hist = true;
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_wait_hist.start = get_timestamp_in_us();
		}
		wake_up_interruptible(&service->wq_hist);
	}

	return 0;
}

static inline int handle_err_hist(struct fb_info *info, int wait_ret) {
	struct hisi_fb_data_type *hisifd = NULL;
	int ret = 0;

	if (NULL == info) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->panel_power_on) {
		if (wait_ret > 0) {
			ret = 3;//panel on hist not return hist stop is true
		} else if (wait_ret == -ERESTARTSYS){
			hisifb_ce_service_deinit();
			ret = 4;//system err and return -ERESTARTSYS
		} else {
			ret = 2;//hist not return time out
		}
	} else {
		ret = 1;//panel off hist not return hist stop is true
	}

	if ((g_debug_effect & DEBUG_EFFECT_ENTRY) && wait_ret != 0) {
		DEBUG_EFFECT_LOG("[effect] wait_event_interruptible_timeout() return %d, -ERESTARTSYS:%d\n", wait_ret, -ERESTARTSYS);
	}

	return ret;
}

void hisi_effect_init(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	dss_ce_info_t *ce_info = NULL;
	hiace_alg_parameter_t *param = NULL;

	if (!g_is_effect_lock_init) {
		spin_lock_init(&g_gmp_effect_lock);
		spin_lock_init(&g_igm_effect_lock);
		spin_lock_init(&g_xcc_effect_lock);
		spin_lock_init(&g_gamma_effect_lock);
		spin_lock_init(&g_hiace_table_lock);
		mutex_init(&g_rgbw_lock);
		g_is_effect_lock_init = true;
	}

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] HIACE is not supported!\n");
		}
		return;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		ce_info = &hisifd->hiace_info;
		param = &pinfo->hiace_param;
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	if (!g_is_effect_init) {
		mutex_init(&g_ce_service_lock);
		mutex_init(&(hisifd->al_ctrl.ctrl_lock));
		mutex_init(&(hisifd->ce_ctrl.ctrl_lock));
		mutex_init(&(hisifd->bl_ctrl.ctrl_lock));
		mutex_init(&(hisifd->bl_enable_ctrl.ctrl_lock));
		mutex_init(&(hisifd->metadata_ctrl.ctrl_lock));
		hisifd->bl_enable_ctrl.ctrl_bl_enable = 1;

		memset(ce_info, 0, sizeof(dss_ce_info_t));
		ce_info->algorithm_result = 1;
		mutex_init(&(ce_info->hist_lock));
		mutex_init(&(ce_info->lut_lock));

		param->iWidth = (int)pinfo->xres;
		param->iHeight = (int)pinfo->yres;
		param->iMode = 0;
		param->bitWidth = 10;
		param->iMinBackLight = (int)hisifd->panel_info.bl_min;
		param->iMaxBackLight = (int)hisifd->panel_info.bl_max;
		param->iAmbientLight = -1;

		memset(&g_hiace_service, 0, sizeof(g_hiace_service));
		init_waitqueue_head(&g_hiace_service.wq_hist);

		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] width:%d, height:%d, minbl:%d, maxbl:%d\n", param->iWidth, param->iHeight, param->iMinBackLight, param->iMaxBackLight);
		}

		g_is_effect_init = true;
	} else {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] bypass\n");
		}
	}
}

void hisi_effect_deinit(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	dss_ce_info_t *ce_info = NULL;

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] HIACE is not supported!\n");
		}
		return;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		ce_info = &hisifd->hiace_info;
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	if (g_is_effect_lock_init) {
		g_is_effect_lock_init = false;
		mutex_destroy(&g_rgbw_lock);
	}

	down(&hisifd->hiace_hist_lock_sem);/*avoid  using  mutex_lock() but hist_lock was destoried by mutex_destory in  hisi_effect_deinit*/
	if (g_is_effect_init) {
		g_is_effect_init = false;

		mutex_destroy(&(ce_info->hist_lock));
		mutex_destroy(&(ce_info->lut_lock));

		mutex_destroy(&(hisifd->al_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->ce_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->bl_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->bl_enable_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->metadata_ctrl.ctrl_lock));

		mutex_destroy(&g_ce_service_lock);
	} else {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] bypass\n");
		}
	}
	up(&hisifd->hiace_hist_lock_sem);
}

static void hisifb_ce_service_init(void)
{
	mutex_lock(&g_ce_service_lock);
	if (!g_is_ce_service_init) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] step in\n");
		}

		g_hiace_service.is_ready = true;
		g_hiace_service.stop = false;
		g_hiace_service.hist_stop = false;

		g_is_ce_service_init = true;
	}
	mutex_unlock(&g_ce_service_lock);
}

static void hisifb_ce_service_deinit(void)
{
	mutex_lock(&g_ce_service_lock);
	if (g_is_ce_service_init) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] step in\n");
		}

		g_is_ce_service_init = false;

		g_hiace_service.is_ready = false;
		g_hiace_service.stop = true;
		g_hiace_service.hist_stop = true;

		wake_up_interruptible(&g_hiace_service.wq_hist);
	}
	mutex_unlock(&g_ce_service_lock);
}

static inline void enable_hiace(struct hisi_fb_data_type *hisifd, bool enable)
{
	if (enable) {
		hisifb_ce_service_init();
	} else {
		hisifb_ce_service_deinit();
	}

	down(&hisifd->blank_sem);
	if (hisifd->panel_power_on) {
		if (hisifd->hiace_info.hiace_enable != enable) { //lint !e731
			hisifd->hiace_info.hiace_enable = enable;
			EFFECT_DEBUG_LOG(DEBUG_EFFECT_ENTRY, "[effect] hiace:%d\n", (int)enable);
		}
	} else {
		EFFECT_DEBUG_LOG(DEBUG_EFFECT_ENTRY, "[effect] fb%d, panel power off!\n", hisifd->index);
	}
	up(&hisifd->blank_sem);
}
int hisifb_ce_service_blank(int blank_mode, struct fb_info *info)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;

	if (NULL == info) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		if (pinfo->hiace_support) {
			if (blank_mode == FB_BLANK_UNBLANK) {
				hisifb_ce_service_init();
				if (hisifb_display_effect_is_need_ace(hisifd)) {
					enable_hiace(hisifd, true);
				}
			} else {
				if (hisifb_display_effect_is_need_ace(hisifd)) {
					g_hiace_service.use_last_value = true;
				}
				hisifd->hiace_info.gradual_frames = 0;
				hisifd->hiace_info.hiace_enable = false;
				hisifd->hiace_info.to_stop_hdr = false;
				hisifd->hiace_info.to_stop_sre = false;
				g_hiace_service.blc_used = false;
				hiace_enable_status = false;

				// Since java has no destruct function and Gallery will refresh metadata when power on, always close HDR for Gallery when power off.
				if (hisifd->ce_ctrl.ctrl_ce_mode == CE_MODE_IMAGE) {
					hisifd->ce_ctrl.ctrl_ce_mode = CE_MODE_DISABLE;
				}
				hisifb_ce_service_deinit();
			}
		}
	}
	return 0;
}

int hisifb_ce_service_get_support(struct fb_info *info, void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	unsigned int support = 0;
	int ret = 0;

	if (NULL == info) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -EINVAL;
	}

	if (NULL == argp) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support) {
		support = 1;
	}
	if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
		DEBUG_EFFECT_LOG("[effect] support:%d\n", support);
	}

	ret = (int)copy_to_user(argp, &support, sizeof(support));
	if (ret) {
		HISI_FB_ERR("[effect] copy_to_user failed! ret=%d.\n", ret);
		return ret;
	}

	return ret;
}

int hisifb_ce_service_get_limit(struct fb_info *info, void __user *argp)
{
	int limit = 0;
	int ret = 0;

	if (NULL == argp) {
		HISI_FB_ERR("argp is NULL\n");
		return -EINVAL;
	}

	ret = (int)copy_to_user(argp, &limit, sizeof(limit));
	if (ret) {
		HISI_FB_ERR("copy_to_user failed! ret=%d.\n", ret);
		return ret;
	}

	return ret;
}

int hisifb_ce_service_get_hiace_param(struct fb_info *info, void __user *argp){
	int ret = 0;
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	struct dss_effect_info effect_info;

	if (NULL == info) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -EINVAL;
	}

	if (NULL == argp) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	if (PRIMARY_PANEL_IDX != hisifd->index) {
		HISI_FB_ERR("[effect] hisifd index error: fd = %d\n", hisifd->index);
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] Don't support HIACE\n");
		}
		return -EINVAL;
	}

	ret = copy_from_user(&effect_info, argp, sizeof(struct dss_effect_info));
	if (ret) {
		HISI_FB_ERR("failed to copy dss_effect_info from user space.\n");
		return	-EINVAL;
	}

	if (effect_info.modules & DSS_EFFECT_MODULE_HIACE) {
		ret = hisi_effect_hiace_info_get(hisifd, &(effect_info.hiace));
		if (ret) {
			HISI_FB_ERR("failed to get hiace info.\n");
			return	-EINVAL;
		}
	}

	ret = copy_to_user(argp, &effect_info, sizeof(struct dss_effect_info));
	if (ret) {
		HISI_FB_ERR("failed to copy result of ioctl to user space.\n");
		return	-EINVAL;
	}

	return 0;
}

/*lint -e571*/
int hisifb_ce_service_get_param(struct fb_info *info, void __user *argp)
{
	int ret = 0;
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;
	dss_display_effect_al_t *al_ctrl = NULL;
	dss_display_effect_metadata_t *metadata_ctrl = NULL;
	int mode = 0;
	struct timespec ts;

	if (NULL == info) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -EINVAL;
	}

	if (NULL == argp) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] Don't support HIACE\n");
		}
		return -EINVAL;
	}

	ce_ctrl = &(hisifd->ce_ctrl);
	al_ctrl = &(hisifd->al_ctrl);
	metadata_ctrl = &(hisifd->metadata_ctrl);
	mode = ce_ctrl->ctrl_ce_mode;
	if (mode != 0) {
		pinfo->hiace_param.iDoLCE = 1;
		pinfo->hiace_param.iDoAPLC = 1;
	}
	pinfo->hiace_param.iLevel = MAX(mode - 1, 0);
	pinfo->hiace_param.iAmbientLight = al_ctrl->ctrl_al_value;
	pinfo->hiace_param.iBackLight = (int)hisifd->bl_level;
	ktime_get_ts(&ts);
	pinfo->hiace_param.lTimestamp = ts.tv_sec * MSEC_PER_SEC + ts.tv_nsec / NSEC_PER_MSEC;
	if (metadata_ctrl->count <= META_DATA_SIZE) {
		memcpy(pinfo->hiace_param.Classifieresult, metadata_ctrl->metadata, (size_t)metadata_ctrl->count);
		pinfo->hiace_param.iResultLen = metadata_ctrl->count;
	}

	ret = (int)copy_to_user(argp, &pinfo->hiace_param, sizeof(pinfo->hiace_param));
	if (ret) {
		HISI_FB_ERR("[effect] copy_to_user(hiace_param) failed! ret=%d.\n", ret);
		return ret;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME) {
		DEBUG_EFFECT_LOG("[effect] iLevel:%d, iAmbientLight:%d, iBackLight:%d, lTimestamp:%ld(ms)\n",
						 pinfo->hiace_param.iLevel, pinfo->hiace_param.iAmbientLight, pinfo->hiace_param.iBackLight, pinfo->hiace_param.lTimestamp);
	}

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_algorithm.start = get_timestamp_in_us();
	}

	return ret;
}
/*lint +e571*/
int hisifb_ce_service_get_hist(struct fb_info *info, void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	ce_service_t *service = &g_hiace_service;
	int ret = 0;
	long wait_ret = 0;
	long timeout = msecs_to_jiffies(100000);

	if (runmode_is_factory()) {
		return ret;
	}

	if (NULL == info) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL\n");
		return -EINVAL;
	}

	if (NULL == argp) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME) {
		DEBUG_EFFECT_LOG("[effect] wait hist\n");
	}

	if (g_is_effect_init) {
		unlock_fb_info(info);
		wait_ret = wait_event_interruptible_timeout(service->wq_hist, service->new_hist || service->hist_stop, timeout);
		lock_fb_info(info);
		service->hist_stop = false;
	}
	if (!g_is_effect_init) {
		HISI_FB_ERR("[effect] wq_hist uninit.\n");
		return -EINVAL;
	}

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_wait_hist.stop = get_timestamp_in_us();
		count_delay(&delay_wait_hist, interval_wait_hist.stop - interval_wait_hist.start);
	}

	down(&hisifd->hiace_hist_lock_sem);/*avoid  using  mutex_lock() but hist_lock was destoried by mutex_destory in  hisi_effect_deinit*/
	if (service->new_hist) {
		time_interval_t interval_copy_hist = {0};
		static delay_record_t delay_copy_hist = {"hist copy", 0, 0xFFFFFFFF, 0, 0};

		service->new_hist = false;

		if(!g_is_effect_init){
			HISI_FB_ERR("[effect] wq_hist uninit here\n");
			up(&hisifd->hiace_hist_lock_sem);
			return -EINVAL;
		}
		mutex_lock(&hisifd->hiace_info.hist_lock);
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_copy_hist.start = get_timestamp_in_us();
		}
		ret = (int)copy_to_user(argp, hisifd->hiace_info.histogram, sizeof(hisifd->hiace_info.histogram));
		if (ret) {
			HISI_FB_ERR("[effect] copy_to_user failed(param)! ret=%d.\n", ret);
			ret = -1;
		}
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_copy_hist.stop = get_timestamp_in_us();
			count_delay(&delay_copy_hist, interval_copy_hist.stop - interval_copy_hist.start);
		}
		mutex_unlock(&hisifd->hiace_info.hist_lock);
	} else {
		ret = handle_err_hist(info, wait_ret);
	}
	up(&hisifd->hiace_hist_lock_sem);

	return ret;
}

int hisifb_ce_service_set_lut(struct fb_info *info, void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	dss_display_effect_bl_t *bl_ctrl = NULL;
	dss_display_effect_bl_enable_t *bl_enable_ctrl = NULL;
	hiace_interface_set_t hiace_set_interface;
	int ret = 0;
	time_interval_t interval_copy_lut = {0};
	static delay_record_t delay_copy_lut = {"lut copy", 0, 0xFFFFFFFF, 0, 0};

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_algorithm.stop = get_timestamp_in_us();
		count_delay(&delay_algorithm, interval_algorithm.stop - interval_algorithm.start);
	}

	if (runmode_is_factory()) {
		return ret;
	}

	if (NULL == info) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	if (NULL == argp) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] Don't support HIACE\n");
		}
		return -EINVAL;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME) {
		DEBUG_EFFECT_LOG("[effect] step in\n");
	}

	bl_ctrl = &(hisifd->bl_ctrl);
	bl_enable_ctrl = &(hisifd->bl_enable_ctrl);

	ret = (int)copy_from_user(&hiace_set_interface, argp, sizeof(hiace_interface_set_t));
	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(param) failed! ret=%d.\n", ret);
		return -2;
	}

	mutex_lock(&hisifd->hiace_info.lut_lock);
	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_copy_lut.start = get_timestamp_in_us();
	}
	ret = (int)hisi_effect_alloc_and_copy(&hisifd->hiace_info.lut_table, hiace_set_interface.lut, CE_SIZE_LUT, true);

	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(lut_table) failed! ret=%d.\n", ret);
		ret = -2;
	}

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_copy_lut.stop = get_timestamp_in_us();
		count_delay(&delay_copy_lut, interval_copy_lut.stop - interval_copy_lut.start);
	}
	mutex_unlock(&hisifd->hiace_info.lut_lock);
	hisifd->hiace_info.algorithm_result = 0;

	return ret;
}


ssize_t hisifb_display_effect_al_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_al_t *al_ctrl = NULL;

	if (NULL == info) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	al_ctrl = &(hisifd->al_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", al_ctrl->ctrl_al_value);
}

ssize_t hisifb_display_effect_al_ctrl_store(struct fb_info *info, const char *buf, size_t count)
{
	(void)info, (void)buf;

	return (ssize_t)count;
}

ssize_t hisifb_display_effect_ce_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;

	if (NULL == info) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	ce_ctrl = &(hisifd->ce_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", ce_ctrl->ctrl_ce_mode);
}

ssize_t hisifb_display_effect_ce_ctrl_store(struct fb_info *info, const char *buf, size_t count)
{
	(void)info, (void)buf;

	return (ssize_t)count;
}

ssize_t hisifb_display_effect_bl_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_bl_t *bl_ctrl = NULL;

	if (NULL == info) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	bl_ctrl = &(hisifd->bl_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", bl_ctrl->ctrl_bl_delta);
}

ssize_t hisifb_display_effect_bl_enable_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_bl_enable_t *bl_enable_ctrl = NULL;

	if (NULL == info) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	bl_enable_ctrl = &(hisifd->bl_enable_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", bl_enable_ctrl->ctrl_bl_enable);
}

ssize_t hisifb_display_effect_bl_enable_ctrl_store(struct fb_info *info, const char *buf, size_t count)
{
	(void)info, (void)buf;

	return (ssize_t)count;
}

ssize_t hisifb_display_effect_sre_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_sre_t *sre_ctrl = NULL;

	if (NULL == info) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	sre_ctrl = &(hisifd->sre_ctrl);

	return snprintf(buf, PAGE_SIZE, "sre_enable:%d, sre_al:%d\n", sre_ctrl->ctrl_sre_enable, sre_ctrl->ctrl_sre_al);
}
/*lint -e438, -e550, -e715*/
ssize_t hisifb_display_effect_sre_ctrl_store(struct fb_info *info, const char *buf, size_t count)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_sre_t *sre_ctrl = NULL;

	if (NULL == info) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	sre_ctrl = &(hisifd->sre_ctrl);

	return (ssize_t)count;
}

ssize_t hisifb_display_effect_metadata_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;

	if (NULL == info) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	return 0;
}

ssize_t hisifb_display_effect_metadata_ctrl_store(struct fb_info *info, const char *buf, size_t count)
{
	(void)info, (void)buf;

	return (ssize_t)count;
}

void hisifb_display_effect_func_switch(struct hisi_fb_data_type *hisifd, const char *command)
{
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}
	if (NULL == command) {
		HISI_FB_ERR("[effect] command is NULL\n");
		return;
	}

	if (!strncmp("hiace:", command, strlen("hiace:"))) {
		if('0' == command[strlen("hiace:")]) {
			hisifd->panel_info.hiace_support = 0;
			HISI_FB_INFO("[effect] hiace disable\n");
		} else {
			hisifd->panel_info.hiace_support = 1;
			HISI_FB_INFO("[effect] hiace enable\n");
		}
	}
	if (!strncmp("effect_enable:", command, strlen("effect_enable:"))) {
		g_enable_effect = (int)simple_strtoul(&command[strlen("effect_enable:")], NULL, 0);
		HISI_FB_INFO("[effect] effect_enable changed to %d\n", g_enable_effect);
	}
	if (!strncmp("effect_debug:", command, strlen("effect_debug:"))) {
		g_debug_effect = (int)simple_strtoul(&command[strlen("effect_debug:")], NULL, 0);
		HISI_FB_INFO("[effect] effect_debug changed to %d\n", g_debug_effect);
	}
}

bool hisifb_display_effect_is_need_ace(struct hisi_fb_data_type *hisifd)
{
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return false;
	}

	return (g_enable_effect & ENABLE_EFFECT_HIACE) && (hisifd->ce_ctrl.ctrl_ce_mode > 0);
}

bool hisifb_display_effect_is_need_blc(struct hisi_fb_data_type *hisifd)
{
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
	return false;
	}
	return hisifd->de_info.blc_enable;
}

static int deltabl_process(struct hisi_fb_data_type *hisifd, int backlight_in)
{
	int ret = 0;
	int bl_min = (int)hisifd->panel_info.bl_min;
	int bl_max = (int)hisifd->panel_info.bl_max;
	bool HBMEnable = hisifd->de_info.amoled_param.HBMEnable ? true:false;
	bool AmoledDimingEnable = hisifd->de_info.amoled_param.AmoledDimingEnable ? true:false;
	int HBM_Threshold_BackLight = hisifd->de_info.amoled_param.HBM_Threshold_BackLight;
	int HBM_Min_BackLight = hisifd->de_info.amoled_param.HBM_Min_BackLight;
	int HBM_Max_BackLight = hisifd->de_info.amoled_param.HBM_Max_BackLight;
	//int HBM_MinLum_Regvalue = hisifd->de_info.amoled_param.HBM_MinLum_Regvalue;
	//int HBM_MaxLum_Regvalue = hisifd->de_info.amoled_param.HBM_MaxLum_Regvalue;
	int Hiac_DBVThres = hisifd->de_info.amoled_param.Hiac_DBVThres;
	int Hiac_DBV_XCCThres = hisifd->de_info.amoled_param.Hiac_DBV_XCCThres;
	int Hiac_DBV_XCC_MinThres = hisifd->de_info.amoled_param.Hiac_DBV_XCC_MinThres;
	int current_hiac_backlight = 0;
	int current_hiac_deltaBL = 0;
	int temp_hiac_backlight = 0;
	int origin_hiac_backlight = 0;
	int temp_lowc_backlight = 0;

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL \n");
		return -1;
	}

	origin_hiac_backlight = (backlight_in - bl_min) * (HBM_Max_BackLight - HBM_Min_BackLight) /(bl_max - bl_min) + HBM_Min_BackLight;
	current_hiac_backlight = origin_hiac_backlight;

	if (HBMEnable && (HBM_Max_BackLight > HBM_Threshold_BackLight) && (HBM_Threshold_BackLight > (HBM_Min_BackLight + 1))) {
		if ((backlight_in >= bl_min) && (backlight_in < HBM_Threshold_BackLight)) {
			current_hiac_deltaBL = HBM_Min_BackLight + ((current_hiac_backlight - HBM_Min_BackLight) * (HBM_Max_BackLight - HBM_Min_BackLight) /(HBM_Threshold_BackLight - 1 - HBM_Min_BackLight)) - current_hiac_backlight;
		} else if ((current_hiac_backlight >= HBM_Threshold_BackLight) && (backlight_in <= bl_max)) {
			current_hiac_deltaBL = HBM_Max_BackLight - current_hiac_backlight;
		}
		current_hiac_backlight = current_hiac_backlight + current_hiac_deltaBL;
		HISI_FB_DEBUG("[effect] hiac_delta =  %d hiac_backlight =  %d, backlight = %d", current_hiac_deltaBL,current_hiac_backlight, backlight_in);
	}

	if (AmoledDimingEnable) {
		if ((current_hiac_backlight <= Hiac_DBVThres) && (current_hiac_backlight > Hiac_DBV_XCCThres)) {
			current_hiac_deltaBL = Hiac_DBVThres - origin_hiac_backlight;
		} else if ((current_hiac_backlight <= Hiac_DBV_XCCThres)) {
			temp_hiac_backlight = (current_hiac_backlight - HBM_Min_BackLight ) * (Hiac_DBVThres - Hiac_DBV_XCC_MinThres) /(Hiac_DBV_XCCThres - HBM_Min_BackLight) + Hiac_DBV_XCC_MinThres;
			current_hiac_deltaBL = temp_hiac_backlight - origin_hiac_backlight;
		}
		HISI_FB_DEBUG("[effect] hiac_delta =  %d hiac_backlight =  %d, backlight = %d", current_hiac_deltaBL,current_hiac_backlight, backlight_in);
	}

	hisifd->de_info.blc_delta = (bl_max - bl_min) * current_hiac_deltaBL /(HBM_Max_BackLight -HBM_Min_BackLight);

	if (AmoledDimingEnable && hisifd->panel_info.dbv_curve_mapped_support && hisifd->panel_info.is_dbv_need_mapped) {
		if ((current_hiac_backlight <= Hiac_DBVThres) && (current_hiac_backlight > Hiac_DBV_XCCThres)) {
			temp_lowc_backlight =  (Hiac_DBVThres - HBM_Min_BackLight) * (bl_max - bl_min)/(HBM_Max_BackLight -HBM_Min_BackLight) + bl_min;
			hisifd->de_info.blc_delta = (int)dbv_curve_noliner_to_liner_map[hisifd->panel_info.dbv_map_index][temp_lowc_backlight] - backlight_in;
		} else if ((current_hiac_backlight <= Hiac_DBV_XCCThres)) {
			temp_hiac_backlight = (current_hiac_backlight - HBM_Min_BackLight ) * (Hiac_DBVThres - Hiac_DBV_XCC_MinThres) /(Hiac_DBV_XCCThres - HBM_Min_BackLight) + Hiac_DBV_XCC_MinThres;
			temp_lowc_backlight = (temp_hiac_backlight - HBM_Min_BackLight) * (bl_max - bl_min)/(HBM_Max_BackLight -HBM_Min_BackLight) + bl_min;
			hisifd->de_info.blc_delta = (int)dbv_curve_noliner_to_liner_map[hisifd->panel_info.dbv_map_index][temp_lowc_backlight] - backlight_in;
		} else {
			hisifd->de_info.blc_delta = (int)dbv_curve_noliner_to_liner_map[hisifd->panel_info.dbv_map_index][backlight_in] - backlight_in;
		}
		HISI_FB_DEBUG("[effect] hiac_delta =  %d hiac_backlight =  %d, backlight = %d", current_hiac_deltaBL,current_hiac_backlight, backlight_in);
	}

	HISI_FB_DEBUG("[effect] first screen on ! dbv_map_index =%d delta: -10000 -> %d bl: %d (%d)\n",hisifd->panel_info.dbv_map_index,hisifd->de_info.blc_delta,backlight_in,backlight_in+hisifd->de_info.blc_delta);

	return ret;
}

static void handle_first_deltabl(struct hisi_fb_data_type *hisifd, int backlight_in)
{
	bool HBMEnable = hisifd->de_info.amoled_param.HBMEnable ? true:false;
	bool AmoledDimingEnable = hisifd->de_info.amoled_param.AmoledDimingEnable ? true:false;
	int bl_min = (int)hisifd->panel_info.bl_min;
	int bl_max = (int)hisifd->panel_info.bl_max;

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	if (!hisifb_display_effect_is_need_blc(hisifd)) {
		return;
	}

	if (!(HBMEnable || AmoledDimingEnable)) {
		return;
	}

	if (hisifd->bl_level == 0) {
		hisifd->de_info.blc_delta = -10000;
		return;
	}

	if (backlight_in >0 && (backlight_in < bl_min || backlight_in > bl_max)) {
		return;
	}

	if (hisifd->de_info.blc_delta == -10000) {
		deltabl_process(hisifd,backlight_in);
	}
}

bool hisifb_display_effect_check_bl_value(int curr, int last) {
	if (abs(curr - last) > 200) {
		return true;
	}
	return false;
}

bool hisifb_display_effect_check_bl_delta(int curr, int last) {
	if (abs(curr - last) > 20) {
		return true;
	}
	return false;
}

static inline void display_engine_bl_debug_print(int bl_in, int bl_out, int delta) {
	static int last_delta = 0;
	static int last_bl = 0;
	static int last_bl_out = 0;
	static int count = 0;
	if (hisifb_display_effect_check_bl_value(bl_in, last_bl) || hisifb_display_effect_check_bl_value(bl_out, last_bl_out) || hisifb_display_effect_check_bl_delta(delta, last_delta)) {
		if (count == 0) {
			HISI_FB_INFO("[effect] last delta:%d bl:%d->%d\n", last_delta, last_bl, last_bl_out);
		}
		count = DISPLAYENGINE_BL_DEBUG_FRAMES;
	}
	if (count > 0) {
		HISI_FB_INFO("[effect] delta:%d bl:%d->%d\n", delta, bl_in, bl_out);
		count--;
	}
	last_delta = delta;
	last_bl = bl_in;
	last_bl_out = bl_out;
}

unsigned short dbv_curve_noliner_to_liner_map[DBV_MAP_INDEX][DBV_MAP_COUNTS] = {
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		30, 31, 39, 55, 79, 94, 104, 119, 136, 142,
		146, 152, 156, 161, 162, 167, 171, 177, 182, 186,
		189, 192, 195, 201, 202, 206, 210, 214, 216, 219,
		225, 225, 229, 231, 234, 236, 240, 243, 245, 245,
		248, 250, 253, 257, 259, 262, 264, 267, 270, 273,
		276, 276, 278, 281, 284, 287, 290, 293, 293, 295,
		299, 301, 304, 306, 307, 309, 310, 311, 313, 316,
		319, 320, 320, 323, 325, 328, 330, 330, 332, 332,
		335, 337, 340, 340, 342, 344, 347, 349, 350, 350,
		351, 354, 356, 359, 360, 361, 361, 363, 366, 368,
		368, 371, 371, 372, 375, 377, 378, 380, 380, 382,
		385, 385, 387, 387, 390, 391, 394, 394, 394, 397,
		399, 401, 402, 402, 403, 406, 407, 408, 409, 411,
		411, 412, 413, 415, 416, 418, 418, 419, 421, 422,
		424, 424, 424, 425, 426, 428, 430, 431, 432, 432,
		434, 435, 437, 438, 440, 441, 441, 442, 444, 445,
		447, 449, 450, 450, 451, 452, 454, 456, 457, 458,
		458, 459, 460, 461, 463, 463, 464, 466, 467, 469,
		470, 470, 471, 474, 474, 476, 478, 479, 480, 482,
		483, 483, 485, 486, 486, 486, 488, 489, 490, 492,
		492, 493, 495, 497, 498, 499, 501, 502, 502, 504,
		505, 507, 508, 509, 509, 510, 511, 511, 512, 514,
		515, 517, 519, 520, 521, 521, 522, 524, 526, 527,
		529, 530, 531, 532, 532, 533, 534, 535, 536, 537,
		539, 540, 542, 543, 544, 544, 544, 545, 546, 547,
		548, 549, 550, 551, 551, 551, 551, 552, 553, 554,
		555, 555, 556, 557, 558, 559, 560, 561, 562, 563,
		564, 565, 565, 566, 566, 567, 567, 568, 569, 569,
		571, 571, 572, 573, 574, 575, 576, 577, 577, 578,
		579, 579, 580, 581, 582, 583, 583, 583, 583, 584,
		585, 586, 587, 588, 589, 590, 591, 592, 593, 594,
		595, 596, 597, 598, 598, 599, 599, 599, 600, 601,
		601, 603, 603, 603, 604, 606, 606, 607, 608, 609,
		610, 611, 612, 613, 614, 615, 615, 615, 615, 615,
		616, 617, 619, 620, 621, 622, 623, 624, 625, 626,
		627, 627, 628, 629, 630, 630, 631, 631, 631, 631,
		632, 633, 633, 635, 635, 636, 638, 639, 640, 641,
		642, 642, 643, 644, 645, 646, 646, 646, 646, 647,
		647, 648, 649, 650, 650, 652, 653, 654, 655, 656,
		657, 658, 659, 661, 662, 662, 662, 662, 662, 663,
		664, 664, 665, 666, 667, 667, 669, 670, 671, 672,
		672, 674, 675, 676, 677, 678, 678, 678, 678, 678,
		679, 680, 681, 681, 682, 684, 685, 686, 686, 686,
		687, 689, 690, 691, 692, 693, 694, 694, 694, 694,
		694, 695, 696, 696, 697, 699, 699, 701, 702, 703,
		704, 705, 706, 707, 708, 709, 710, 710, 710, 710,
		710, 710, 711, 712, 713, 714, 714, 716, 717, 719,
		720, 720, 722, 722, 725, 725, 725, 725, 726, 726,
		726, 726, 726, 727, 730, 730, 732, 733, 735, 735,
		735, 735, 735, 735, 735, 735, 735, 735, 735, 736,
		736, 737, 737, 738, 738, 738, 739, 739, 739, 740,
		740, 741, 741, 742, 742, 742, 743, 743, 744, 744,
		744, 745, 745, 746, 746, 746, 747, 747, 747, 747,
		748, 748, 749, 749, 750, 750, 751, 751, 751, 752,
		752, 752, 753, 753, 754, 754, 754, 754, 755, 756,
		756, 756, 757, 757, 758, 758, 758, 759, 759, 759,
		759, 760, 760, 761, 762, 762, 762, 762, 763, 763,
		764, 764, 764, 764, 765, 765, 765, 766, 766, 766,
		767, 768, 768, 769, 769, 769, 769, 770, 770, 771,
		772, 772, 773, 774, 775, 776, 776, 777, 777, 779,
		779, 779, 780, 781, 781, 781, 782, 783, 783, 784,
		785, 786, 786, 787, 788, 788, 789, 789, 790, 791,
		792, 792, 793, 793, 794, 795, 795, 796, 797, 797,
		798, 798, 799, 799, 799, 804, 805, 805, 806, 806,
		807, 808, 809, 810, 810, 811, 812, 812, 813, 813,
		814, 815, 816, 816, 817, 817, 818, 818, 819, 820,
		820, 821, 821, 822, 822, 823, 824, 824, 824, 826,
		827, 827, 828, 828, 829, 830, 830, 831, 832, 833,
		833, 833, 834, 835, 835, 836, 836, 837, 838, 838,
		838, 839, 840, 840, 841, 841, 842, 843, 844, 845,
		845, 845, 846, 847, 848, 848, 848, 850, 850, 851,
		851, 852, 852, 853, 853, 853, 854, 855, 856, 856,
		857, 857, 858, 858, 859, 859, 861, 861, 862, 862,
		863, 864, 864, 864, 865, 866, 867, 867, 868, 868,
		869, 869, 870, 870, 871, 871, 872, 873, 873, 874,
		874, 875, 875, 876, 876, 876, 878, 879, 879, 880,
		881, 881, 882, 882, 883, 884, 884, 885, 885, 886,
		886, 887, 887, 887, 888, 889, 890, 890, 891, 891,
		892, 892, 893, 893, 894, 894, 895, 896, 896, 897,
		898, 899, 899, 899, 901, 901, 902, 902, 902, 903,
		903, 904, 904, 905, 905, 906, 907, 907, 908, 908,
		909, 909, 910, 910, 911, 912, 912, 913, 914, 915,
		915, 915, 916, 917, 918, 918, 919, 919, 919, 920,
		920, 921, 921, 921, 922, 922, 923, 924, 924, 925,
		926, 926, 926, 927, 928, 928, 928, 929, 930, 930,
		931, 932, 932, 933, 933, 934, 935, 935, 936, 936,
		937, 937, 938, 938, 938, 939, 940, 940, 941, 942,
		942, 943, 943, 944, 944, 944, 946, 946, 947, 947,
		948, 949, 949, 950, 950, 950, 951, 952, 953, 953,
		954, 954, 955, 955, 955, 956, 956, 957, 958, 958,
		959, 959, 960, 960, 961, 961, 962, 963, 963, 964,
		964, 965, 966, 966, 966, 967, 967, 968, 969, 969,
		970, 970, 970, 971, 972, 972, 972, 973, 973, 974,
		975, 976, 976, 976, 977, 977, 978, 978, 979, 980,
		980, 981, 981, 982, 983, 983, 984, 984, 984, 985,
		986, 986, 987, 987, 988, 988, 989, 989, 989, 990,
		990, 991, 992, 993, 994, 995, 996, 997, 998, 999,
		1000, 1000, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
		1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019,
		1020, 1021, 1022, 1023,
	},
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		30, 31, 38, 51, 52, 60, 64, 73, 74, 82,
		84, 90, 94, 94, 99, 105, 105, 109, 114, 114,
		118, 123, 123, 129, 133, 133, 138, 138, 143, 147,
		147, 152, 152, 155, 159, 159, 163, 166, 166, 170,
		173, 177, 181, 181, 184, 188, 190, 190, 194, 198,
		201, 201, 205, 208, 208, 212, 216, 218, 222, 225,
		225, 229, 233, 234, 235, 235, 237, 238, 241, 241,
		243, 244, 246, 246, 249, 250, 252, 252, 254, 256,
		258, 258, 260, 262, 263, 263, 266, 268, 269, 269,
		271, 273, 275, 275, 277, 279, 281, 282, 282, 285,
		287, 288, 288, 290, 292, 294, 294, 296, 298, 300,
		301, 301, 301, 301, 304, 306, 307, 309, 309, 311,
		313, 315, 315, 317, 319, 321, 322, 322, 324, 324,
		325, 326, 326, 327, 328, 330, 330, 330, 332, 333,
		333, 334, 335, 336, 337, 337, 339, 339, 340, 341,
		342, 344, 344, 345, 346, 347, 347, 348, 349, 350,
		351, 353, 355, 355, 355, 357, 358, 359, 360, 360,
		361, 362, 363, 364, 364, 365, 366, 367, 369, 370,
		371, 372, 372, 373, 374, 375, 376, 376, 377, 378,
		380, 380, 382, 382, 382, 384, 385, 386, 386, 387,
		388, 389, 390, 391, 391, 392, 393, 394, 396, 396,
		398, 398, 399, 400, 401, 402, 403, 403, 404, 405,
		406, 407, 408, 410, 411, 412, 413, 413, 414, 415,
		416, 417, 418, 419, 419, 420, 421, 423, 423, 425,
		426, 426, 427, 428, 429, 430, 431, 432, 432, 433,
		434, 434, 434, 436, 437, 438, 439, 441, 441, 442,
		443, 444, 446, 447, 448, 449, 449, 450, 452, 453,
		454, 454, 454, 454, 454, 455, 456, 458, 459, 460,
		462, 462, 462, 464, 465, 466, 468, 469, 470, 471,
		471, 472, 474, 475, 476, 478, 478, 480, 481, 482,
		482, 485, 485, 486, 487, 488, 490, 491, 492, 494,
		494, 494, 494, 494, 494, 495, 496, 497, 499, 500,
		501, 502, 503, 504, 504, 507, 507, 508, 510, 510,
		512, 513, 514, 515, 517, 518, 519, 520, 521, 521,
		523, 524, 525, 526, 528, 529, 530, 531, 533, 534,
		534, 534, 534, 534, 534, 535, 536, 537, 537, 539,
		540, 541, 542, 543, 545, 546, 547, 549, 550, 551,
		552, 553, 555, 556, 556, 557, 558, 559, 561, 562,
		563, 565, 565, 567, 568, 569, 569, 569, 569, 569,
		571, 572, 573, 574, 574, 574, 575, 577, 578, 579,
		580, 581, 583, 584, 585, 587, 587, 589, 590, 591,
		593, 594, 594, 596, 597, 597, 599, 599, 599, 599,
		599, 600, 601, 602, 603, 605, 606, 607, 608, 610,
		611, 611, 612, 613, 615, 615, 616, 618, 619, 621,
		622, 623, 624, 625, 627, 627, 628, 629, 629, 629,
		629, 629, 630, 631, 632, 633, 634, 635, 638, 639,
		640, 641, 642, 644, 644, 645, 646, 647, 648, 650,
		651, 652, 654, 654, 655, 656, 658, 659, 659, 659,
		659, 659, 659, 661, 661, 662, 663, 664, 666, 668,
		670, 670, 672, 674, 674, 674, 674, 674, 674, 674,
		674, 674, 674, 674, 675, 675, 675, 676, 676, 677,
		677, 677, 677, 678, 679, 679, 679, 680, 680, 681,
		681, 681, 682, 682, 683, 683, 683, 684, 684, 685,
		685, 685, 686, 686, 687, 687, 687, 688, 689, 689,
		689, 690, 690, 693, 693, 694, 694, 695, 696, 696,
		696, 696, 697, 698, 698, 698, 698, 699, 699, 700,
		700, 700, 701, 702, 702, 702, 703, 704, 704, 704,
		704, 705, 706, 706, 706, 706, 707, 708, 708, 708,
		709, 709, 710, 710, 710, 711, 711, 712, 712, 712,
		713, 713, 714, 714, 715, 715, 715, 716, 716, 717,
		717, 718, 719, 719, 719, 720, 721, 722, 727, 727,
		729, 729, 730, 731, 731, 732, 733, 733, 734, 735,
		735, 736, 736, 737, 738, 738, 740, 740, 741, 742,
		742, 743, 744, 744, 745, 746, 747, 747, 748, 749,
		750, 750, 751, 752, 752, 752, 753, 754, 760, 761,
		761, 762, 763, 763, 765, 765, 765, 766, 767, 768,
		769, 769, 770, 771, 771, 771, 772, 773, 773, 774,
		776, 776, 776, 777, 778, 778, 779, 780, 780, 781,
		782, 782, 783, 784, 784, 785, 786, 786, 791, 792,
		792, 794, 794, 795, 796, 797, 797, 798, 799, 799,
		799, 801, 801, 802, 803, 803, 803, 804, 805, 805,
		806, 807, 807, 809, 809, 810, 811, 811, 812, 813,
		813, 814, 815, 816, 816, 816, 817, 818, 824, 824,
		825, 825, 826, 826, 827, 828, 828, 829, 830, 831,
		831, 832, 832, 833, 834, 835, 835, 836, 837, 837,
		838, 839, 839, 839, 840, 841, 841, 842, 843, 843,
		843, 844, 845, 845, 846, 847, 848, 848, 849, 849,
		849, 855, 857, 857, 858, 859, 859, 860, 861, 861,
		862, 862, 863, 864, 864, 864, 865, 865, 866, 866,
		867, 868, 868, 869, 870, 870, 870, 871, 872, 873,
		873, 874, 874, 877, 878, 878, 879, 879, 880, 880,
		881, 882, 882, 889, 889, 889, 890, 891, 891, 892,
		893, 894, 895, 895, 895, 896, 897, 897, 897, 899,
		899, 899, 900, 901, 901, 901, 902, 903, 903, 904,
		904, 905, 905, 906, 907, 907, 907, 909, 909, 910,
		911, 911, 912, 912, 913, 913, 914, 920, 920, 920,
		921, 922, 922, 923, 923, 924, 925, 925, 926, 927,
		927, 928, 928, 929, 930, 930, 931, 932, 932, 933,
		933, 934, 934, 935, 935, 936, 936, 936, 938, 938,
		938, 938, 939, 940, 940, 941, 942, 943, 943, 944,
		945, 945, 946, 952, 953, 953, 954, 954, 956, 957,
		957, 957, 958, 959, 959, 960, 960, 961, 961, 963,
		963, 963, 964, 965, 966, 966, 967, 968, 968, 968,
		969, 970, 970, 970, 971, 971, 972, 972, 973, 974,
		974, 974, 975, 976, 976, 976, 977, 978, 978, 978,
		986, 986, 987, 987, 988, 988, 989, 989, 990, 990,
		991, 991, 992, 992, 994, 995, 996, 997, 998, 999,
		1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
		1010, 1011, 1011, 1013, 1014, 1015, 1016, 1017, 1018, 1019,
		1020, 1021, 1022, 1023,
	},
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		30, 31, 38, 46, 54, 59, 66, 72, 79, 87,
		93, 98, 103, 109, 116, 119, 122, 123, 125, 127,
		129, 130, 131, 133, 134, 136, 138, 140, 141, 143,
		145, 146, 147, 149, 150, 151, 155, 158, 162, 167,
		170, 174, 178, 182, 185, 189, 192, 196, 199, 202,
		206, 209, 213, 215, 219, 222, 225, 228, 231, 235,
		236, 237, 238, 240, 241, 243, 243, 246, 247, 249,
		250, 252, 252, 254, 255, 256, 258, 259, 260, 262,
		263, 265, 266, 268, 269, 271, 273, 274, 275, 277,
		278, 280, 281, 282, 284, 285, 287, 288, 289, 290,
		292, 294, 295, 297, 298, 299, 301, 303, 304, 306,
		308, 309, 310, 311, 313, 314, 315, 317, 319, 320,
		322, 323, 324, 324, 326, 327, 327, 329, 330, 331,
		332, 333, 334, 335, 336, 337, 338, 340, 341, 341,
		343, 344, 344, 346, 347, 348, 349, 350, 350, 352,
		353, 354, 355, 356, 356, 358, 358, 359, 361, 361,
		362, 364, 364, 365, 366, 367, 368, 369, 370, 370,
		372, 372, 373, 374, 375, 376, 377, 378, 378, 379,
		380, 381, 382, 383, 384, 384, 385, 386, 387, 388,
		389, 390, 390, 391, 392, 393, 394, 395, 396, 396,
		398, 398, 399, 400, 401, 402, 402, 403, 404, 405,
		405, 406, 407, 408, 408, 410, 410, 411, 412, 413,
		413, 414, 415, 416, 417, 417, 418, 419, 420, 421,
		421, 422, 422, 424, 424, 425, 426, 427, 427, 428,
		429, 430, 430, 431, 432, 433, 433, 434, 434, 434,
		435, 436, 437, 437, 439, 440, 441, 442, 443, 444,
		445, 446, 447, 447, 449, 450, 451, 452, 453, 453,
		455, 456, 457, 458, 459, 459, 460, 461, 462, 464,
		465, 465, 466, 467, 468, 469, 469, 472, 472, 473,
		474, 474, 475, 477, 478, 479, 480, 481, 482, 483,
		484, 485, 485, 487, 488, 489, 490, 491, 491, 493,
		494, 495, 496, 496, 497, 499, 500, 501, 502, 502,
		504, 505, 506, 507, 507, 508, 510, 511, 512, 513,
		513, 514, 516, 517, 518, 518, 520, 520, 522, 523,
		524, 524, 526, 527, 528, 529, 529, 530, 532, 533,
		534, 534, 535, 535, 537, 538, 539, 540, 540, 542,
		544, 545, 545, 546, 548, 549, 550, 551, 551, 552,
		554, 555, 556, 556, 557, 558, 560, 561, 562, 562,
		564, 565, 566, 567, 567, 568, 570, 571, 572, 573,
		573, 574, 576, 577, 578, 578, 580, 581, 583, 584,
		584, 584, 586, 587, 588, 589, 589, 590, 592, 593,
		594, 594, 595, 596, 599, 600, 600, 601, 602, 604,
		605, 605, 605, 606, 607, 609, 610, 611, 611, 614,
		614, 615, 616, 616, 618, 620, 621, 622, 622, 622,
		623, 626, 626, 627, 627, 628, 629, 632, 633, 633,
		633, 635, 637, 638, 638, 639, 639, 641, 642, 644,
		644, 645, 645, 647, 647, 649, 650, 651, 653, 654,
		654, 655, 656, 657, 659, 660, 660, 661, 662, 663,
		664, 665, 667, 669, 670, 671, 671, 673, 673, 674,
		674, 674, 674, 674, 674, 674, 674, 674, 674, 675,
		676, 676, 677, 678, 679, 680, 680, 681, 681, 682,
		682, 683, 683, 683, 683, 683, 683, 683, 684, 685,
		686, 687, 688, 688, 689, 690, 691, 691, 692, 693,
		693, 694, 695, 695, 696, 697, 697, 698, 699, 699,
		700, 700, 700, 701, 702, 703, 703, 703, 703, 703,
		703, 703, 704, 705, 706, 706, 707, 708, 708, 709,
		710, 710, 711, 712, 712, 713, 714, 714, 715, 716,
		717, 717, 718, 718, 718, 719, 720, 720, 721, 721,
		722, 723, 723, 723, 723, 723, 723, 723, 724, 725,
		725, 726, 727, 727, 728, 729, 729, 730, 730, 731,
		731, 733, 733, 734, 735, 735, 736, 736, 737, 737,
		738, 739, 739, 740, 741, 742, 742, 743, 743, 743,
		743, 743, 743, 743, 743, 744, 745, 745, 746, 746,
		747, 748, 748, 749, 750, 750, 751, 752, 752, 753,
		753, 753, 754, 754, 755, 756, 757, 757, 758, 761,
		762, 763, 763, 763, 763, 763, 763, 763, 763, 764,
		765, 766, 766, 768, 769, 770, 771, 772, 773, 774,
		775, 776, 778, 780, 780, 783, 783, 783, 783, 783,
		783, 783, 783, 784, 785, 786, 787, 788, 789, 789,
		790, 791, 792, 794, 796, 796, 798, 798, 799, 801,
		802, 802, 803, 803, 803, 803, 803, 803, 803, 804,
		806, 807, 807, 808, 809, 809, 811, 812, 813, 815,
		815, 817, 818, 819, 820, 821, 822, 823, 823, 823,
		823, 823, 823, 823, 824, 825, 825, 825, 827, 827,
		829, 831, 832, 833, 834, 835, 836, 837, 838, 838,
		840, 841, 842, 842, 843, 843, 843, 843, 843, 843,
		843, 843, 844, 844, 846, 847, 850, 852, 853, 854,
		855, 856, 857, 857, 857, 858, 859, 861, 862, 863,
		863, 863, 863, 863, 863, 863, 863, 863, 864, 865,
		867, 868, 870, 871, 872, 873, 873, 873, 875, 876,
		876, 878, 878, 879, 880, 882, 883, 883, 883, 883,
		883, 883, 883, 883, 883, 885, 886, 888, 888, 889,
		889, 890, 891, 891, 894, 894, 895, 896, 897, 898,
		899, 900, 902, 903, 903, 903, 903, 903, 903, 903,
		904, 904, 905, 906, 906, 907, 908, 909, 910, 911,
		912, 913, 914, 915, 916, 917, 918, 920, 921, 921,
		921, 922, 923, 923, 923, 923, 923, 923, 923, 923,
		923, 925, 927, 927, 929, 929, 930, 931, 932, 933,
		934, 936, 937, 937, 938, 939, 940, 941, 942, 943,
		943, 943, 943, 943, 943, 943, 943, 943, 944, 944,
		946, 947, 948, 949, 949, 950, 951, 952, 953, 953,
		953, 954, 959, 960, 961, 961, 962, 963, 963, 963,
		963, 963, 963, 963, 963, 963, 964, 965, 966, 966,
		968, 969, 969, 969, 970, 971, 972, 973, 974, 978,
		979, 979, 980, 982, 983, 983, 983, 983, 983, 983,
		983, 983, 983, 983, 984, 985, 985, 985, 986, 986,
		989, 990, 991, 992, 994, 995, 996, 997, 998, 999,
		1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
		1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019,
		1020, 1021, 1022, 1023,
	}
};

static void hisifb_dbv_curve_mapped(struct hisi_fb_data_type *hisifd, int backlight_in, int *backlight_out) {
	if (NULL == hisifd || NULL == backlight_out) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}
	if (hisifd->panel_info.dbv_curve_mapped_support && hisifd->panel_info.is_dbv_need_mapped && (backlight_in < DBV_MAP_COUNTS) && (backlight_in >= 0)
		&& (hisifd->panel_info.dbv_map_index < DBV_MAP_INDEX)) {
		int bl = (int)dbv_curve_noliner_to_liner_map[hisifd->panel_info.dbv_map_index][backlight_in];

		*backlight_out = bl;
		HISI_FB_DEBUG("[effect] delta:%d bl:%d(bl_in:%d)->%d\n", hisifd->de_info.blc_delta, hisifd->bl_level, backlight_in, *backlight_out);
	}
}

bool hisifb_display_effect_fine_tune_backlight(struct hisi_fb_data_type *hisifd, int backlight_in, int *backlight_out)
{
	bool changed = false;
	struct hisi_panel_info* pinfo = NULL;
	int delta = 0;

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return false;
	}

	pinfo = &(hisifd->panel_info);
	if(NULL == pinfo) {
		HISI_FB_ERR("pinfo is NULL!\n");
		return false;
	}

	if (NULL == backlight_out) {
		HISI_FB_ERR("[effect] backlight_out is NULL\n");
		return false;
	}

	if (hisifd->panel_info.need_skip_delta) {
		hisifd->panel_info.need_skip_delta = 0;
		return changed;
	}

	handle_first_deltabl(hisifd,backlight_in);

	/*if ((pinfo->hbm_support == 1) && (backlight_in <= (int)hisifd->panel_info.bl_min)) {
		HISI_FB_DEBUG("[effect] don't need add delta_bl for bl_min\n");
		return false;
	}*/

	if (hisifd->bl_level > 0) {
		if (hisifb_display_effect_is_need_blc(hisifd)) {
			int bl = MIN((int)hisifd->panel_info.bl_max, MAX((int)hisifd->panel_info.bl_min, backlight_in + hisifd->de_info.blc_delta));

			if (hisifd->de_info.amoled_param.AmoledDimingEnable) {
				if (backlight_in >= hisifd->de_info.amoled_param.Lowac_DBV_XCCThres && backlight_in <= hisifd->de_info.amoled_param.Lowac_DBVThres) {
					bl = hisifd->de_info.amoled_param.Lowac_Fixed_DBVThres;
				}
			}

			if (*backlight_out != bl) {
				HISI_FB_DEBUG("[effect] delta:%d bl:%d(%d)->%d\n", hisifd->de_info.blc_delta, backlight_in, hisifd->bl_level, bl);
				*backlight_out = bl;
				changed = true;
				hisifd->de_info.blc_used = true;
			}
			delta = hisifd->de_info.blc_delta;
		} else {
			if (hisifd->de_info.blc_used) {
			if (*backlight_out != backlight_in) {
				HISI_FB_DEBUG("[effect] bl:%d->%d\n", *backlight_out, backlight_in);
				*backlight_out = backlight_in;
				changed = true;
				}
				hisifd->de_info.blc_used = false;
			}
			delta = 0;
		}
	}

	if (runmode_is_factory()) {
		hisifb_dbv_curve_mapped(hisifd,*backlight_out,backlight_out);
		HISI_FB_DEBUG("[effect] runmode_is_factory bl:%d->%d\n", *backlight_out, backlight_in);
	}

	display_engine_bl_debug_print(backlight_in, *backlight_out, delta);

	return changed;
}


int hisifb_display_effect_blc_cabc_update(struct hisi_fb_data_type *hisifd)
{
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	if ((hisifd->panel_info.blpwm_input_ena || hisifb_display_effect_is_need_blc(hisifd)) && hisifd->cabc_update) {
		hisifd->cabc_update(hisifd);
	}

	return 0;
}

//lint -e845, -e732, -e774
/* HIACE */
//static u32 hiace_lut[] = {0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992};
static u32 orginal_detail_weight[HIACE_DETAIL_WEIGHT_TABLE_LEN] = {
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80
};
static int orginal_LogLumEOTFLUT[HIACE_LOGLUM_EOTF_TABLE_LEN] = {
    -4096,-4096,-4096,-4096,-4096,-3942,-3719,-3518,
    -3347,-3201,-3074,-2963,-2863,-2546,-2309,-2118,
    -1958,-1819,-1695,-1585,-1484,-1391,-1078,-826,
    -613,-426,-259, 32, 288, 512, 718, 910,
    1089,1259,1421,1576,1726,1872,2014,2153,
    2289,2424,2556,2687,2817,2947,3075,3204,
    3332,3461,3590,3720,3851,3983,4050,4083,
    4087,4091,4095,4095,4095,4095,4095
};
static int orginal_LumEOTFGammaLUT[HIACE_LUMA_GAMA_TABLE_LEN] = {
    0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,  45,  65,  83,  99, 116, 133,
    151, 169, 188, 208, 229, 252, 275, 300,
    326, 354, 384, 415, 448, 483, 520, 560,
    602, 646, 693, 743, 796, 853, 913, 976,
    1023,1023,1023,1023,1023,1023,1023,1023,
    1023,1023,1023,1023,1023,1023,1023,1023,
    1023,1023,1023,1023,1023,1023,1023
};

static void init_hdr10_lut(struct hisi_fb_data_type *hisifd)
{
    int ret = 0;
    if (NULL == hisifd) {
        HISI_FB_ERR("[effect] hisifd is NULL\n");
        return;
    }

    if (hisifd->panel_info.hiace_support == 0) {
        if (g_debug_effect & DEBUG_EFFECT_FRAME) {
            DEBUG_EFFECT_LOG("[effect] HIACE is not support!\n");
        }
        return;
    }

    ret = (int)hisi_effect_alloc_and_copy(&(hisifd->effect_info.hiace.detail_weight_table), orginal_detail_weight, HIACE_DETAIL_WEIGHT_TABLE_LEN, false);
    if (ret) {
       HISI_FB_ERR("[effect] copy (detail_weight) failed! ret=%d.\n", ret);
    }
    ret = (int)hisi_effect_alloc_and_copy(&(hisifd->effect_info.hiace.loglum_eotf_table), orginal_LogLumEOTFLUT, HIACE_LOGLUM_EOTF_TABLE_LEN, false);
    if (ret) {
        HISI_FB_ERR("[effect] copy (LogLumEOTFLUT) failed! ret=%d.\n", ret);
    }
    ret = (int)hisi_effect_alloc_and_copy(&(hisifd->effect_info.hiace.luma_gamma_table), orginal_LumEOTFGammaLUT, HIACE_LUMA_GAMA_TABLE_LEN, false);
    if (ret) {
        HISI_FB_ERR("[effect] copy (LumEOTFGammaLUT) failed! ret=%d.\n", ret);
    }

    //hisifd->effect_updated_flag.hiace_hdr10_lut_updated = true;     //write init lut

    return;
}

void init_hiace(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	char __iomem *hiace_base = NULL;
	struct hiace_info *hiace_param = NULL;
	unsigned long dw_jiffies = 0;
	uint32_t tmp = 0;
	bool is_ready = false;

	uint32_t global_hist_ab_work;
	uint32_t global_hist_ab_shadow;
	uint32_t gamma_ab_work;
	uint32_t gamma_ab_shadow;
	uint32_t width;
	uint32_t height;
	uint32_t half_block_w;
	uint32_t half_block_h;
	uint32_t pipe_mode;
	uint32_t partition_mode;
	uint32_t xPartition;
	uint32_t is_left_pipe;
	uint32_t lhist_quant;
	uint32_t lhist_sft;
	uint32_t slop;
	uint32_t th_max;
	uint32_t th_min;
	uint32_t up_thres;
	uint32_t low_thres;
	uint32_t fixbit_x;
	uint32_t fixbit_y;
	uint32_t reciprocal_x;
	uint32_t reciprocal_y;

	uint32_t block_pixel_num;
	uint32_t max_lhist_block_pixel_num;
	uint32_t max_lhist_bin_reg_num;

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);

	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] HIACE is not supported!\n");
		}
		return;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	hiace_param = &(hisifd->effect_info.hiace);


	set_reg(hiace_base + DPE_BYPASS_ACE, 0x1, 1, 0);
	set_reg(hiace_base + DPE_INIT_GAMMA, 0x1, 1, 0);
	set_reg(hiace_base + DPE_UPDATE_LOCAL, 0x1, 1, 0);
	set_reg(hiace_base + DPE_UPDATE_FNA, 0x1, 1, 0);

	/* parameters */
	width = hisifd->panel_info.xres & 0x1fff;
	height = hisifd->panel_info.yres & 0x1fff;
	set_reg(hiace_base + DPE_IMAGE_INFO, (height << 16) | width, 32, 0);

	hiace_param->image_info = (height << 16) | width;

	pipe_mode = 0;
	partition_mode = 0;
	is_left_pipe = 0;
	set_reg(hiace_base + DPE_DB_PIPE_CFG, (is_left_pipe << 31) | (partition_mode << 30) | pipe_mode, 32, 0);
	if (partition_mode == 0) {
		xPartition = 6;
	} else {
		xPartition = 4;
	}

	hiace_param->db_pipe_cfg = (is_left_pipe << 31) | (partition_mode << 30) | pipe_mode;

	lhist_quant = 0;
	set_reg(hiace_base + DPE_LHIST_EN, lhist_quant, 1, 10);

	hiace_param->lhist_en = lhist_quant<<10 | hiace_param->lhist_en;

	half_block_w = (width / (2 * xPartition)) & 0x1ff;
	half_block_h = ((height + 11) / 12) & 0x1ff;
	set_reg(hiace_base + DPE_HALF_BLOCK_INFO,
		(half_block_h << 16) | half_block_w, 32, 0);

	hiace_param->half_block_info = (half_block_h << 16) | half_block_w;

	block_pixel_num = (half_block_w * half_block_h) << 2;
	max_lhist_block_pixel_num = block_pixel_num << 2;
	max_lhist_bin_reg_num = (1 << 16) - 1; /* each local hist bin 20bit -> 16bit */
	if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num << 1)) {
		lhist_sft = 0;
	} else if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num << 2)) {
		lhist_sft = 1;
	} else if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num << 3)) {
		lhist_sft = 2;
	} else if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num << 4)) {
		lhist_sft = 3;
	} else {
		lhist_sft = 4;
	}
	set_reg(hiace_base + DPE_LHIST_SFT, lhist_sft, 3, 0);
	pinfo->hiace_param.ilhist_sft = (int)lhist_sft;
	hiace_param->lhist_sft = lhist_sft;

	slop = 68 & 0xff;
	th_min = 0 & 0x1ff;
	th_max = 30 & 0x1ff;
	set_reg(hiace_base + DPE_HUE, (slop << 24) | (th_max << 12) | th_min, 32, 0);

	hiace_param->hue = (slop << 24) | (th_max << 12) | th_min;

	slop = 68 & 0xff;
	th_min = 80 & 0xff;
	th_max = 140 & 0xff;
	set_reg(hiace_base + DPE_SATURATION, (slop << 24) | (th_max << 12) | th_min, 32, 0);
	hiace_param->saturation = (slop << 24) | (th_max << 12) | th_min;

	slop = 68 & 0xff;
	th_min = 100 & 0xff;
	th_max = 255 & 0xff;
	set_reg(hiace_base + DPE_VALUE, (slop << 24) | (th_max << 12) | th_min, 32, 0);
	hiace_param->value = (slop << 24) | (th_max << 12) | th_min;

	set_reg(hiace_base + DPE_SKIN_GAIN, 128, 8, 0);
	hiace_param->skin_gain = 128;   //SDR:128;  HDR:0

	up_thres = 248 & 0xff;
	low_thres = 8 & 0xff;
	set_reg(hiace_base + DPE_UP_LOW_TH, (up_thres << 8) | low_thres, 32, 0);
	hiace_param->up_low_th = (up_thres << 8) | low_thres;

	fixbit_x = get_fixed_point_offset(half_block_w) & 0x1f;
	fixbit_y = get_fixed_point_offset(half_block_h) & 0x1f;
	reciprocal_x = (1U << (fixbit_x + 8)) / (2 * MAX(half_block_w, 1)) & 0x3ff;
	reciprocal_y = (1U << (fixbit_y + 8)) / (2 * MAX(half_block_h, 1)) & 0x3ff;
	set_reg(hiace_base + DPE_XYWEIGHT, (fixbit_y << 26) | (reciprocal_y << 16)
		| (fixbit_x << 10) | reciprocal_x, 32, 0);

	hiace_param->xyweight = (fixbit_y << 26) | (reciprocal_y << 16) | (fixbit_x << 10) | reciprocal_x;

	if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
		DEBUG_EFFECT_LOG("[effect] half_block_w:%d, half_block_h:%d, fixbit_x:%d, fixbit_y:%d, reciprocal_x:%d, reciprocal_y:%d, lhist_sft:%d\n",
						 half_block_w, half_block_h, fixbit_x, fixbit_y, reciprocal_x, reciprocal_y, lhist_sft);
	}

	/* wait for gamma init finishing */
	dw_jiffies = jiffies + HZ / 2;
	do {
		tmp = inp32(hiace_base + DPE_INIT_GAMMA);
		if ((tmp & 0x1) != 0x1) {
			is_ready = true;
			break;
		}
	} while (time_after(dw_jiffies, jiffies)); //lint !e550

	if (!is_ready) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] fb%d, HIACE_INIT_GAMMA is not ready! HIACE_INIT_GAMMA=0x%08X.\n",
							 hisifd->index, tmp);
		} else {
			HISI_FB_INFO("[effect] fb%d, HIACE_INIT_GAMMA is not ready! HIACE_INIT_GAMMA=0x%08X.\n",
						 hisifd->index, tmp);
		}
	}

	global_hist_ab_work = inp32(hiace_base + DPE_GLOBAL_HIST_AB_WORK);
	global_hist_ab_shadow = !global_hist_ab_work;

	gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK);
	gamma_ab_shadow = !gamma_ab_work;

	set_reg(hiace_base + DPE_GLOBAL_HIST_AB_SHADOW, global_hist_ab_shadow, 1, 0);
	set_reg(hiace_base + DPE_GAMMA_AB_SHADOW, gamma_ab_shadow, 1, 0);

	/* clear hiace interrupt */
	outp32(hiace_base + DPE_INT_STAT, 0x1);

	/* unmask hiace interrupt */
	set_reg(hiace_base + DPE_INT_UNMASK, 0x1, 1, 0);

	hiace_param->roi_start_point = 0x0;
	hiace_param->roi_width_high = (0x0780<<16) | 0x0438;
	hiace_param->roi_mode_ctrl = 0x0;
	hiace_param->roi_hist_stat_mode = 0x0;
	hiace_param->rgb_blend_weight = 0;//(0x05<<16) | (0x05<<8) | 0x05;
	set_reg(hiace_base + DPE_RGB_BLEND_WEIGHT, hiace_param->rgb_blend_weight, 32, 0);
	hiace_param->fna_statistic = (0x0f<<8) | 0x03;
	hiace_param->gamma_w = 0;
	hiace_param->gamma_r = 0x0;
	hiace_param->fna_addr = 0x0;
	hiace_param->update_fna = 0x0;
	hiace_param->db_pipe_ext_width = 0x0;
	hiace_param->db_pipe_full_img_width = 0x0438;

	init_noisereduction(hisifd);

	hiace_param->hdr10_en = 0x0;
	set_reg(hiace_base + DPE_HDR10_EN, hiace_param->hdr10_en, 32, 0);
	hiace_param->loglum_max = 0x0;
	set_reg(hiace_base + DPE_LOGLUM_MAX, hiace_param->loglum_max, 32, 0);
	hiace_param->hist_modev = 0x44AB70DA;
	set_reg(hiace_base + DPE_HIST_MODEV, hiace_param->hist_modev, 32, 0);
	hiace_param->end_point =  (636<<16) | 82;
	set_reg(hiace_base + DPE_END_POINT, hiace_param->end_point, 32, 0);

	init_hdr10_lut(hisifd);

	/*enable hiace */
	//set_reg(hiace_base + DPE_BYPASS_ACE, 0x0, 1, 0);
	//hiace_param->enable = 1;
	hiace_param->enable = 0;

}

void init_noisereduction(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	char __iomem *nr_base = NULL;
	struct hiace_info *hiace_param = NULL;
	uint32_t somebrightness0;
	uint32_t somebrightness1;
	uint32_t somebrightness2;
	uint32_t somebrightness3;
	uint32_t somebrightness4;
	uint32_t minSigma;
	uint32_t maxSigma;
	uint32_t colorSigma0;
	uint32_t colorSigma1;
	uint32_t colorSigma2;
	uint32_t colorSigma3;
	uint32_t colorSigma4;
	uint32_t colorSigma5;

	uint32_t slop;
	uint32_t th_max;
	uint32_t th_min;

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		nr_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	pinfo = &(hisifd->panel_info);

	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] NR is not supported!\n");
		}
		return;
	}
	hiace_param = &(hisifd->effect_info.hiace);

	/* disable noisereduction */
	set_reg(nr_base + DPE_BYPASS_NR, 0x1, 1, 0);

	somebrightness0 = 819 & 0x3ff;
	somebrightness1 = 640 & 0x3ff;
	somebrightness2 = 384 & 0x3ff;
	somebrightness3 = 205 & 0x3ff;
	somebrightness4 = 96 & 0x3ff;
	set_reg(nr_base + DPE_S3_SOME_BRIGHTNESS01, somebrightness0 | (somebrightness1 << 16), 32, 0);
	set_reg(nr_base + DPE_S3_SOME_BRIGHTNESS23, somebrightness2 | (somebrightness3 << 16), 32, 0);
	set_reg(nr_base + DPE_S3_SOME_BRIGHTNESS4, somebrightness4, 32, 0);

	hiace_param->s3_some_brightness01 = somebrightness0 | (somebrightness1 << 16);
	hiace_param->s3_some_brightness23 = somebrightness2 | (somebrightness3 << 16);
	hiace_param->s3_some_brightness4 = somebrightness4;

	minSigma = 0x16 & 0x1f;     //-10
	maxSigma = 0x1f & 0x1f;     //-1
	set_reg(nr_base + DPE_S3_MIN_MAX_SIGMA, minSigma | (maxSigma << 16), 32, 0);
	hiace_param->s3_min_max_sigma = minSigma | (maxSigma << 16);

	colorSigma0 = 0x1f & 0x1f;      //-1
	colorSigma1 = 0x1f & 0x1f;      //-1
	colorSigma2 = 0x1e & 0x1f;      //-2
	colorSigma3 = 0x1e & 0x1f;      //-2
	colorSigma4 = 0x1e & 0x1f;      //-2
	colorSigma5 = 0x1e & 0x1f;      //-2
	set_reg(nr_base + DPE_S3_GREEN_SIGMA03, colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24), 32, 0);
	set_reg(nr_base + DPE_S3_GREEN_SIGMA45, colorSigma4 | (colorSigma5 << 8), 32, 0);

	hiace_param->s3_green_sigma03 = colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24);
	hiace_param->s3_blue_sigma45 = colorSigma4 | (colorSigma5 << 8);

	colorSigma0 = 0x1f & 0x1f;     //-1
	colorSigma1 = 0x1f & 0x1f;     //-1
	colorSigma2 = 0x1e & 0x1f;     //-2
	colorSigma3 = 0x1e & 0x1f;     //-2
	colorSigma4 = 0x1e & 0x1f;     //-2
	colorSigma5 = 0x1e & 0x1f;     //-2
	set_reg(nr_base + DPE_S3_RED_SIGMA03, colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24), 32, 0);
	set_reg(nr_base + DPE_S3_RED_SIGMA45, colorSigma4 | (colorSigma5 << 8), 32, 0);

	hiace_param->s3_red_sigma03 = colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24);
	hiace_param->s3_red_sigma45 = colorSigma4 | (colorSigma5 << 8);

	colorSigma0 = 0x1f & 0x1f;     //-1
	colorSigma1 = 0x1f & 0x1f;     //-1
	colorSigma2 = 0x1e & 0x1f;     //-2
	colorSigma3 = 0x1e & 0x1f;     //-2
	colorSigma4 = 0x1e & 0x1f;     //-2
	colorSigma5 = 0x1e & 0x1f;     //-2
	set_reg(nr_base + DPE_S3_BLUE_SIGMA03, colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24), 32, 0);
	set_reg(nr_base + DPE_S3_BLUE_SIGMA45, colorSigma4 | (colorSigma5 << 8), 32, 0);

	hiace_param->s3_blue_sigma03 = colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24);
	hiace_param->s3_blue_sigma45 = colorSigma4 | (colorSigma5 << 8);

	colorSigma0 = 0x1f & 0x1f;     //-1
	colorSigma1 = 0x1f & 0x1f;     //-1
	colorSigma2 = 0x1e & 0x1f;     //-2
	colorSigma3 = 0x1e & 0x1f;     //-2
	colorSigma4 = 0x1e & 0x1f;     //-2
	colorSigma5 = 0x1e & 0x1f;     //-2
	set_reg(nr_base + DPE_S3_WHITE_SIGMA03, colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24), 32, 0);
	set_reg(nr_base + DPE_S3_WHITE_SIGMA45, colorSigma4 | (colorSigma5 << 8), 32, 0);

	set_reg(nr_base + DPE_S3_FILTER_LEVEL, 20, 5, 0);

	set_reg(nr_base + DPE_S3_SIMILARITY_COEFF, 296, 10, 0);

	set_reg(nr_base + DPE_S3_V_FILTER_WEIGHT_ADJ, 0x1, 2, 0);

	hiace_param->s3_white_sigma03 = colorSigma0 | (colorSigma1 << 8) | (colorSigma2 << 16) | (colorSigma3 << 24);
	hiace_param->s3_white_sigma45 = colorSigma4 | (colorSigma5 << 8);
	hiace_param->s3_filter_level = 20;
	hiace_param->s3_similarity_coeff = 296;
	hiace_param->s3_v_filter_weight_adj = 0x1;

	slop = 68 & 0xff;
	th_min = 0x0 & 0x1ff;
	th_max = 25 & 0x1ff;
	set_reg(nr_base + DPE_S3_HUE, (slop << 24) | (th_max << 12) | th_min, 32, 0);
	hiace_param->s3_hue = (slop << 24) | (th_max << 12) | th_min;

	slop = 68 & 0xff;
	th_min = 80 & 0xff;
	th_max = 120 & 0xff;
	set_reg(nr_base + DPE_S3_SATURATION, (slop << 24) | (th_max << 12) | th_min, 32, 0);
	hiace_param->s3_saturation = (slop << 24) | (th_max << 12) | th_min;

	slop = 68 & 0xff;
	th_min = 120 & 0xff;
	th_max = 255 & 0xff;
	set_reg(nr_base + DPE_S3_VALUE, (slop << 24) | (th_max << 12) | th_min, 32, 0);
	hiace_param->s3_value = (slop << 24) | (th_max << 12) | th_min;

	set_reg(nr_base + DPE_S3_SKIN_GAIN, 0x80, 8, 0);
	hiace_param->s3_skin_gain = 0x80;

	/* disable noisereduction */
	set_reg(nr_base + DPE_BYPASS_NR, 0x1, 1, 0);
	hiace_param->bypass_nr = 0x1;

	if (pinfo->noisereduction_support == 1) {
	/* enable noisereduction */
		set_reg(nr_base + DPE_BYPASS_NR, 0x0, 1, 0);
		hiace_param->bypass_nr = 0x0;
	}
}

#define DETAIL_WEIGHT_TABLE_UPDATED (1 << 0)
#define LOGLUM_EOTF_TABLE_UPDATED (1 << 1)
#define LUMA_GAMA_TABLE_UPDATED (1 << 2)

/*lint -e679*/
static void hisi_dss_dpp_hiace_set_lut_reg(struct hisi_fb_data_type *hisifd, char __iomem *hiace_base)
{
	uint32_t gamma_ab_shadow = 0;
	uint32_t gamma_ab_work = 0;
	uint32_t temp = 0;
	uint32_t i = 0;
	uint32_t sel_gamma_ab_shadow= 0;

	sel_gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0xe;

	if ((g_table_update & DETAIL_WEIGHT_TABLE_UPDATED) && (hisifd->effect_info.hiace.detail_weight_table != NULL)) {
		gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x8;
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x8;
		if (gamma_ab_shadow == gamma_ab_work) {
			/* write detail_weight lut */
			for (i = 0; i < (DETAIL_WEIGHT_SIZE -1); i++) {
				temp = ((hisifd->effect_info.hiace.detail_weight_table[i * 4]) | (hisifd->effect_info.hiace.detail_weight_table[i * 4 + 1] << 8) | (hisifd->effect_info.hiace.detail_weight_table[i * 4 + 2] << 16) | (hisifd->effect_info.hiace.detail_weight_table[i * 4 + 3] << 24));
				outp32(hisifd->dss_base + HIACE_DETAIL_WEIGHT + i * 4, temp);
				HISI_FB_DEBUG("[effect] detail_weight_table temp[%d]=%d\n",i,temp);
			}
			outp32(hisifd->dss_base + HIACE_DETAIL_WEIGHT + i * 4, (hisifd->effect_info.hiace.detail_weight_table[HIACE_DETAIL_WEIGHT_TABLE_LEN - 1]));
			g_table_update &= ~DETAIL_WEIGHT_TABLE_UPDATED;

			sel_gamma_ab_shadow^=0x8;
		}
	}

	gamma_ab_shadow = 0;
	gamma_ab_work = 0;
	if ((g_table_update & LOGLUM_EOTF_TABLE_UPDATED) && (hisifd->effect_info.hiace.loglum_eotf_table != NULL)) {
		gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x4;
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x4;
		if (gamma_ab_shadow == gamma_ab_work) {
			/* write loglum_eotf lut */
			for (i = 0; i < (LOG_LUM_EOTF_LUT_SIZE - 1); i++) {
				temp = ((hisifd->effect_info.hiace.loglum_eotf_table[i * 2]) | (hisifd->effect_info.hiace.loglum_eotf_table[i * 2 + 1] << 16));
				outp32(hisifd->dss_base + HIACE_LOG_LUM + i * 4, temp);
				HISI_FB_DEBUG("[effect] loglum_eotf_table temp[%d]=%d\n",i,temp);
			}
			outp32(hisifd->dss_base + HIACE_LOG_LUM + i * 4, (hisifd->effect_info.hiace.loglum_eotf_table[LOG_LUM_EOTF_LUT_SIZE - 1]));
			g_table_update &= ~LOGLUM_EOTF_TABLE_UPDATED;

			sel_gamma_ab_shadow^=0x4;
		}
	}

	gamma_ab_shadow = 0;
	gamma_ab_work = 0;
	if ((g_table_update & LUMA_GAMA_TABLE_UPDATED) && (hisifd->effect_info.hiace.luma_gamma_table != NULL)) {
		gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x2;
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x2;
		if (gamma_ab_shadow == gamma_ab_work) {
			/* write luma_gama lut */
			for (i = 0; i < LUMA_GAMA_LUT_SIZE; i++) {
				temp = (hisifd->effect_info.hiace.luma_gamma_table[i * 3]) | (hisifd->effect_info.hiace.luma_gamma_table[i * 3 + 1] << 10) |(hisifd->effect_info.hiace.luma_gamma_table[i * 3 + 2] << 20);
				outp32(hisifd->dss_base + HIACE_LUMA_GAMMA + i * 4, temp);
				HISI_FB_DEBUG("[effect] luma_gamma_table temp[%d]=%d\n",i,temp);
			}
			g_table_update &= ~LUMA_GAMA_TABLE_UPDATED;
			sel_gamma_ab_shadow^=0x2;
		}
	}
	g_sel_gamma_ab_shadow_hdr_lut = sel_gamma_ab_shadow;
}
/*lint +e679*/

void hisi_dss_dpp_hiace_set_reg(struct hisi_fb_data_type *hisifd)
{
	char __iomem *hiace_base = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;
	dss_ce_info_t *ce_info = NULL;
	int xPartition = 6;
	int j = 0;
	int gamma_ab_shadow = 0;
	int gamma_ab_work = 0;
	time_interval_t interval_lut = {0};
	static delay_record_t delay_lut = {"lut writing", 0, 0xFFFFFFFF, 0, 0};

	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	if (NULL == hisifd->dss_base) {
		HISI_FB_ERR("[effect] dss_base is NULL\n");
		return;
	}

	if (hisifd->panel_info.hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_FRAME) {
			DEBUG_EFFECT_LOG("[effect] HIACE is not support!\n");
		}
		return;
	}

	if (PRIMARY_PANEL_IDX == hisifd->index) {
		ce_ctrl = &(hisifd->ce_ctrl);
		ce_info = &(hisifd->hiace_info);
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!\n", hisifd->index);
		return;
	}

	if (!(g_enable_effect & ENABLE_EFFECT_HIACE) || ce_ctrl->ctrl_ce_mode == CE_MODE_DISABLE) {
		if (g_debug_effect & DEBUG_EFFECT_FRAME) {
			DEBUG_EFFECT_LOG("[effect] g_enable_effect is %d, ctrl_ce_mode is %d.\n",
						g_enable_effect, ce_ctrl->ctrl_ce_mode);
		}
		//ce_info->algorithm_result = 1;
		return;
	}

	/*if (g_debug_effect & DEBUG_EFFECT_FRAME) {
		DEBUG_EFFECT_LOG("[effect] step in\n");
	}*/

	//lint -e{438}
	gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x1;
	if (ce_info->algorithm_result == 0 && hisifd->hiace_info.lut_table != NULL) {
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x1;
		HISI_FB_DEBUG("[effect] start set hiace lut! gamma_ab_shadow=%d,gamma_ab_work=%d,g_sel_gamma_ab_shadow_hdr_lut=%d\n",gamma_ab_shadow,gamma_ab_work,g_sel_gamma_ab_shadow_hdr_lut);
		if (gamma_ab_shadow == gamma_ab_work) {
			int i = 0;

			/* write gamma lut */
			//HISI_FB_DEBUG("[effect] write gamma lut!\n");
			set_reg(hiace_base + DPE_GAMMA_EN, 1, 1, 31);

			if (g_debug_effect & DEBUG_EFFECT_DELAY) {
				interval_lut.start = get_timestamp_in_us();
			}

			mutex_lock(&ce_info->lut_lock);
			for (i = 0; i < (6 * xPartition * 8); i++) {
				j = i % 8;
				//lut_value = hiace_lut[4*j] | ((hiace_lut[4*j+1] - hiace_lut[4*j]) << 10)	|
				//	((hiace_lut[4*j+2] - hiace_lut[4*j+1]) << 17)  | ((hiace_lut[4*j+3] - hiace_lut[4*j+2]) << 24) ;
				//outp32(hiace_base + DPE_GAMMA_VxHy_3z2_3z1_3z_W, lut_value);
				outp32(hiace_base + DPE_GAMMA_VxHy_3z2_3z1_3z_W, hisifd->hiace_info.lut_table[i]);
			}
			mutex_unlock(&ce_info->lut_lock);

			if (g_debug_effect & DEBUG_EFFECT_DELAY) {
				interval_lut.stop = get_timestamp_in_us();
				count_delay(&delay_lut, interval_lut.stop - interval_lut.start);
			}

			set_reg(hiace_base + DPE_GAMMA_EN, 0, 1, 31);

			gamma_ab_shadow ^= 1;
		}

		ce_info->algorithm_result = 1;
	}
	set_reg(hiace_base + DPE_GAMMA_AB_SHADOW, (gamma_ab_shadow & 0x1) |(g_sel_gamma_ab_shadow_hdr_lut & 0xe), 4, 0);
	return;
}

static int get_lhist_band(char __iomem *hiace_base)
{
    int lhist_en = 0;
    int lhist_quant = 0;
    int lhist_band = 16;

    lhist_en = inp32(hiace_base + DPE_LHIST_EN);

    lhist_quant = (lhist_en>>10) & 0x1;

    if (lhist_quant == 0) {
        lhist_band = 16;
    } else {
        lhist_band = 8;
    }

    return lhist_band;
}
void hisi_dpp_hiace_end_handle_func(struct work_struct *work)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	char __iomem *hiace_base = NULL;
	uint32_t * global_hist_ptr = NULL;
	uint32_t * sat_global_hist_ptr = NULL;
	uint32_t * local_hist_ptr = NULL;
	uint32_t * fna_data_ptr = NULL;
	dss_ce_info_t *ce_info = NULL;

	int i = 0;
	int xPartition = 6;
	int lhist_band = 8;
	int sum_sat = 0;
	int global_hist_ab_shadow = 0;
	int global_hist_ab_work = 0;
	int local_valid =0 ;
	int fna_valid =0 ;

	time_interval_t interval_total = {0};
	time_interval_t interval_hist_global = {0};
	time_interval_t interval_sat_hist_global = {0};
	time_interval_t interval_hist_local = {0};
	time_interval_t interval_fna_local = {0};

	static delay_record_t delay_total = {"interrupt handling", 0, 0xFFFFFFFF, 0, 0};
	static delay_record_t delay_hist_global = {"global hist reading", 0, 0xFFFFFFFF, 0, 0};
	static delay_record_t delay_sat_hist_global = {"sat_global hist reading", 0, 0xFFFFFFFF, 0, 0};
	static delay_record_t delay_hist_local = {"local hist reading", 0, 0xFFFFFFFF, 0, 0};
	static delay_record_t delay_fna_local = {"fna_local hist reading", 0, 0xFFFFFFFF, 0, 0};

	if (NULL == work) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	hisifd = container_of(work, struct hisi_fb_data_type, hiace_end_work);
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		return;
	}

	if (PRIMARY_PANEL_IDX != hisifd->index) {
		HISI_FB_ERR("[effect] fb%d, not support!\n", hisifd->index);
		return;
	}
	ce_info = &(hisifd->hiace_info);
	hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;

	down(&hisifd->blank_sem);
	if (!hisifd->panel_power_on) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] panel power off!\n");
		}
		up(&hisifd->blank_sem);
		return;

	}

	if (!(g_enable_effect & ENABLE_EFFECT_HIACE) || hisifd->ce_ctrl.ctrl_ce_mode == CE_MODE_DISABLE) {
		if (g_debug_effect & DEBUG_EFFECT_FRAME) {
			DEBUG_EFFECT_LOG("[effect] g_enable_effect is %d, ctrl_ce_mode is %d.\n",
						g_enable_effect, hisifd->ce_ctrl.ctrl_ce_mode);
		}
		goto ERR_OUT;
	}

	if (g_hiace_service.is_ready) {
		g_hiace_service.is_ready = false;
	} else {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] service is not ready!\n");
		}
		goto ERR_OUT;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME) {
		DEBUG_EFFECT_LOG("[effect] step in\n");
	}
	hisifb_ce_service_init();

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_total.start = get_timestamp_in_us();
	}

	hisifb_activate_vsync(hisifd);

	mutex_lock(&ce_info->hist_lock);

	sum_sat = (int)inp32(hiace_base + DPE_SUM_SATURATION);

	local_valid = inp32(hiace_base + DPE_LOCAL_VALID);

	lhist_band = get_lhist_band(hiace_base);

	if (local_valid == 1) {
		/* read local hist */
		local_hist_ptr = &hisifd->hiace_info.histogram[HIACE_GHIST_RANK * 2];
		set_reg(hiace_base + DPE_LHIST_EN, 1, 1, 31);

		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_hist_local.start = get_timestamp_in_us();
		}
		for (i = 0; i < (6 * xPartition * lhist_band); i++) {/* H  L */
			local_hist_ptr[i] = inp32(hiace_base + DPE_LOCAL_HIST_VxHy_2z_2z1);
		}
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_hist_local.stop = get_timestamp_in_us();
			count_delay(&delay_hist_local, interval_hist_local.stop - interval_hist_local.start);
		}

		set_reg(hiace_base + DPE_LHIST_EN, 0, 1, 31);
		outp32(hiace_base + DPE_UPDATE_LOCAL, 1);
	}

	fna_valid = inp32(hiace_base + DPE_FNA_VALID);
	if (fna_valid == 1) {
		/* read fna data */
		// cppcheck-suppress *
		fna_data_ptr = &hisifd->hiace_info.histogram[HIACE_GHIST_RANK * 2 + YBLOCKNUM * XBLOCKNUM * HIACE_LHIST_RANK];
		set_reg(hiace_base + DPE_FNA_EN, 1, 1, 31);

		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_fna_local.start = get_timestamp_in_us();
		}
		for (i = 0; i < (6 * xPartition); i++) {/* FNA */
			fna_data_ptr[i] = inp32(hiace_base + DPE_FNA_VxHy);
		}
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_fna_local.stop = get_timestamp_in_us();
			count_delay(&delay_fna_local, interval_fna_local.stop - interval_fna_local.start);
		}

		set_reg(hiace_base + DPE_FNA_EN, 0, 1, 31);
		outp32(hiace_base + DPE_UPDATE_FNA, 1);
	}

	global_hist_ab_shadow = inp32(hiace_base + DPE_GLOBAL_HIST_AB_SHADOW);
	global_hist_ab_work = inp32(hiace_base + DPE_GLOBAL_HIST_AB_WORK);
	if (global_hist_ab_shadow == global_hist_ab_work) {
		/* read global hist */
		global_hist_ptr = &hisifd->hiace_info.histogram[0];/* HIACE_GHIST_RANK */

		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_hist_global.start = get_timestamp_in_us();
		}
		for (i = 0; i < 32; i++) {
			global_hist_ptr[i] = inp32(hiace_base + DPE_GLOBAL_HIST_LUT_ADDR + i * 4);
		}
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_hist_global.stop = get_timestamp_in_us();
			count_delay(&delay_hist_global, interval_hist_global.stop - interval_hist_global.start);
		}

		/* read sat_global hist */
		sat_global_hist_ptr = &hisifd->hiace_info.histogram[HIACE_GHIST_RANK];/* HIACE_GHIST_RANK */

		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_sat_hist_global.start = get_timestamp_in_us();
		}
		for (i = 0; i < 32; i++) {
			sat_global_hist_ptr[i] = inp32(hiace_base + DPE_SAT_GLOBAL_HIST_LUT_ADDR + i * 4);
		}
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_sat_hist_global.stop = get_timestamp_in_us();
			count_delay(&delay_sat_hist_global, interval_sat_hist_global.stop - interval_sat_hist_global.start);
		}

		outp32(hiace_base +  DPE_GLOBAL_HIST_AB_SHADOW, global_hist_ab_shadow ^ 1);
	}

	hisifd->hiace_info.histogram[CE_SIZE_HIST - 1] = sum_sat;
	mutex_unlock(&ce_info->hist_lock);

	hisifb_deactivate_vsync(hisifd);
	if ((local_valid == 1) ||(fna_valid == 1) || (global_hist_ab_shadow == global_hist_ab_work)) { /* global or local hist or fna is updated */
		hisifb_ce_do_contrast(hisifd);
	}

	g_hiace_service.is_ready = true;

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_total.stop = get_timestamp_in_us();
		count_delay(&delay_total, interval_total.stop - interval_total.start);
	}

ERR_OUT:
	/* clear INT */
	if (hisifd->panel_power_on) {
		hisifb_activate_vsync(hisifd);
		outp32(hiace_base + DPE_INT_STAT, 0x1);
		hisifb_deactivate_vsync(hisifd);
	}

	up(&hisifd->blank_sem);
} //lint !e550
//lint +e845, +e732, +e774

void init_acm_ce(struct hisi_fb_data_type *hisifd)
{
	return;
}

void hisi_dss_dpp_ace_set_reg(struct hisi_fb_data_type *hisifd)
{
	return;
}

void hisi_dpp_ace_end_handle_func(struct work_struct *work)
{
	return;
}

/*******************************************************************************
** GM IGM
*/
#define GM_LUT_LEN 257
#define GM_LUT_MHLEN 254
static uint16_t degm_gm_lut[GM_LUT_LEN *6];

int hisifb_use_dynamic_gamma(struct hisi_fb_data_type *hisifd, char __iomem *dpp_base)
{
	uint32_t i = 0;
	uint32_t index = 0;
	struct hisi_panel_info *pinfo = NULL;
	//char __iomem *gamma_pre_lut_base = NULL;//lint !e838

	if (hisifd == NULL) {
		return -1;
	}

	if (dpp_base == NULL) {
		return -1;
	}

	pinfo = &(hisifd->panel_info);

	if(hisifd->dynamic_gamma_info.use_dynamic_gm_init == 1) {
		uint16_t* gm_lut_r =  degm_gm_lut;
		uint16_t* gm_lut_g =  gm_lut_r + GM_LUT_LEN;
		uint16_t* gm_lut_b =  gm_lut_g + GM_LUT_LEN;

		for (i = 0; i < pinfo->gamma_lut_table_len / 2; i++) {
			index = i << 1;
			if (index >= GM_LUT_MHLEN)
			{
				index = GM_LUT_MHLEN;
			}
			outp32(dpp_base + (U_GAMA_R_COEF + i * 4), gm_lut_r[index] | gm_lut_r[index+1] << 16);
			outp32(dpp_base + (U_GAMA_G_COEF + i * 4), gm_lut_g[index] | gm_lut_g[index+1] << 16);
			outp32(dpp_base + (U_GAMA_B_COEF + i * 4), gm_lut_b[index] | gm_lut_b[index+1] << 16);
		}
		if (pinfo->gamma_lut_table_len <= GM_LUT_LEN) {
			outp32(dpp_base + U_GAMA_R_LAST_COEF, gm_lut_r[pinfo->gamma_lut_table_len - 1]);
			outp32(dpp_base + U_GAMA_G_LAST_COEF, gm_lut_g[pinfo->gamma_lut_table_len - 1]);
			outp32(dpp_base + U_GAMA_B_LAST_COEF, gm_lut_b[pinfo->gamma_lut_table_len - 1]);
		}
		return 1;//lint !e438
	}

	return 0;//lint !e438

}//lint !e550

int hisifb_use_dynamic_degamma(struct hisi_fb_data_type *hisifd, char __iomem *dpp_base)
{
	uint32_t i = 0;
	uint32_t index = 0;
	struct hisi_panel_info *pinfo = NULL;

	if (hisifd == NULL) {
		return -1;
	}

	if (dpp_base == NULL) {
		return -1;
	}

	pinfo = &(hisifd->panel_info);

	if(hisifd->dynamic_gamma_info.use_dynamic_gm_init == 1) {

		uint16_t* degm_lut_r = degm_gm_lut + GM_LUT_LEN * 3;
		uint16_t* degm_lut_g = degm_lut_r + GM_LUT_LEN;
		uint16_t* degm_lut_b = degm_lut_g + GM_LUT_LEN;

		for (i = 0; i < pinfo->igm_lut_table_len / 2; i++) {
			index = i << 1;
			if(index >= GM_LUT_MHLEN)
			{
				index = GM_LUT_MHLEN;
			}
			outp32(dpp_base + (U_DEGAMA_R_COEF +  i * 4), degm_lut_r[index] | degm_lut_r[index+1] << 16);
			outp32(dpp_base + (U_DEGAMA_G_COEF +  i * 4), degm_lut_g[index] | degm_lut_g[index+1] << 16);
			outp32(dpp_base + (U_DEGAMA_B_COEF +  i * 4), degm_lut_b[index] | degm_lut_b[index+1] << 16);
		}
		if (pinfo->igm_lut_table_len <= GM_LUT_LEN) {
			outp32(dpp_base + U_DEGAMA_R_LAST_COEF, degm_lut_r[pinfo->igm_lut_table_len - 1]);
			outp32(dpp_base + U_DEGAMA_G_LAST_COEF, degm_lut_g[pinfo->igm_lut_table_len - 1]);
			outp32(dpp_base + U_DEGAMA_B_LAST_COEF, degm_lut_b[pinfo->igm_lut_table_len - 1]);
		}

		return 1;
	}

	return 0;

}
/*lint -e571 -e774*/
void hisifb_update_dynamic_gamma(struct hisi_fb_data_type *hisifd, const char* buffer, size_t len)
{
	struct hisi_panel_info *pinfo = NULL;
	if (hisifd == NULL || buffer == NULL) {
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo == NULL) {
		return;
	}

	if (!HISI_DSS_SUPPORT_DPP_MODULE_BIT(DPP_MODULE_GAMA)){
		return;
	}

	hisifd->dynamic_gamma_info.use_dynamic_gm = 0;
	hisifd->dynamic_gamma_info.use_dynamic_gm_init = 0;

	if (pinfo->gamma_support == 1) {
		if ((len > 0) && (len <= (int)sizeof(degm_gm_lut))) {
			memcpy((char*)degm_gm_lut, buffer, (size_t)len);
			hisifd->dynamic_gamma_info.use_dynamic_gm = 1;
			hisifd->dynamic_gamma_info.use_dynamic_gm_init = 1;
		}
	}

}
/*lint +e571 +e774*/
void hisifb_update_gm_from_reserved_mem(uint32_t *gm_r, uint32_t *gm_g, uint32_t *gm_b,
	uint32_t *igm_r, uint32_t *igm_g, uint32_t *igm_b)
{
	int i = 0;
	int len = 0;
	uint16_t *u16_gm_r = NULL;
	uint16_t *u16_gm_g = NULL;
	uint16_t *u16_gm_b = NULL;
	uint16_t *u16_igm_r = NULL;
	uint16_t *u16_igm_g = NULL;
	uint16_t *u16_igm_b = NULL;
	void *mem = NULL;
	unsigned long gm_addr = 0;
	unsigned long gm_size = 0;

	if (gm_r == NULL || gm_g == NULL || gm_b == NULL
		|| igm_r == NULL || igm_g == NULL || igm_b == NULL) {
		return;
	}

	gm_addr = HISI_SUB_RESERVED_LCD_GAMMA_MEM_PHYMEM_BASE;//0x20AF1000;
	gm_size = HISI_SUB_RESERVED_LCD_GAMMA_MEM_PHYMEM_SIZE;//0x1000;

	HISI_FB_INFO("gamma kernel gm_addr = 0x%lx  gm_size = 0x%lx \n", gm_addr, gm_size);

	mem = (void *)ioremap_wc(gm_addr, gm_size);
	if (mem == NULL) {
		HISI_FB_ERR("mem ioremap error ! \n");
		return;
	}
	memcpy(&len, mem, 4UL);
	HISI_FB_INFO("gamma read len = %d \n", len);
	if (len != GM_IGM_LEN) {
		HISI_FB_INFO("gamma read len error ! \n");
		iounmap(mem);
		return;
	}

	u16_gm_r = (uint16_t *)(mem + 4);
	u16_gm_g = u16_gm_r + GM_LUT_LEN;
	u16_gm_b = u16_gm_g + GM_LUT_LEN;

	u16_igm_r = u16_gm_b + GM_LUT_LEN;
	u16_igm_g = u16_igm_r + GM_LUT_LEN;
	u16_igm_b = u16_igm_g + GM_LUT_LEN;

	for (i = 0; i < GM_LUT_LEN; i++) {
		gm_r[i] = u16_gm_r[i];
		gm_g[i] = u16_gm_g[i];
		gm_b[i] = u16_gm_b[i];

		igm_r[i]  = u16_igm_r[i];
		igm_g[i] = u16_igm_g[i];
		igm_b[i] = u16_igm_b[i];
	}
	iounmap(mem);
	return;
}

/*lint -e571, -e573, -e737, -e732, -e850, -e730, -e713, -e529, -e574, -e679, -e732, -e845, -e570,
-e774 -e568 -e587 -e685*/

static void free_gamma_table(struct gamma_info *gamma)
{
	hisi_effect_kfree(&gamma->gamma_r_table);
	hisi_effect_kfree(&gamma->gamma_g_table);
	hisi_effect_kfree(&gamma->gamma_b_table);
	hisi_effect_kfree(&gamma->gamma_r_table_pre);
	hisi_effect_kfree(&gamma->gamma_g_table_pre);
	hisi_effect_kfree(&gamma->gamma_b_table_pre);
}

int hisi_effect_arsr2p_info_get(struct hisi_fb_data_type *hisifd, struct arsr2p_info *arsr2p)
{
	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == arsr2p) {
		HISI_FB_ERR("fb%d, arsr2p is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr2p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr2p is not supported!\n", hisifd->index);
		return 0;
	}

	memcpy(&arsr2p[0], &(hisifd->dss_module_default.arsr2p[DSS_RCHN_V0].arsr2p_effect), sizeof(struct arsr2p_info));
	memcpy(&arsr2p[1], &(hisifd->dss_module_default.arsr2p[DSS_RCHN_V0].arsr2p_effect_scale_up), sizeof(struct arsr2p_info));
	memcpy(&arsr2p[2], &(hisifd->dss_module_default.arsr2p[DSS_RCHN_V0].arsr2p_effect_scale_down), sizeof(struct arsr2p_info));
	arsr2p[0].sharp_enable = hisifd->panel_info.prefix_sharpness2D_support;
	arsr2p[0].skin_enable  = arsr2p[0].skin_enable;
	arsr2p[0].shoot_enable = arsr2p[0].shoot_enable;
	arsr2p[1].sharp_enable = hisifd->panel_info.prefix_sharpness2D_support;
	arsr2p[1].skin_enable  = arsr2p[1].skin_enable;
	arsr2p[1].shoot_enable = arsr2p[1].shoot_enable;
	arsr2p[2].sharp_enable = hisifd->panel_info.prefix_sharpness2D_support;
	arsr2p[2].skin_enable  = arsr2p[2].skin_enable;
	arsr2p[2].shoot_enable = arsr2p[2].shoot_enable;

	return 0;
}

#define ARSR1P_ROG_FHD_FLAG BIT(0)
#define ARSR1P_ROG_HD_FLAG BIT(1)
#define ARSR1P_INFO_SIZE 3

static void arsr1p_rog_init(struct arsr1p_info *arsr1p_rog)
{
	if (arsr1p_rog == NULL) {
		return;
	}

	arsr1p_rog->skin_thres_y = 332<<10 | 300;
	arsr1p_rog->skin_thres_u = 40<<10 | 20;
	arsr1p_rog->skin_thres_v = 48<<10 | 24;
	arsr1p_rog->skin_expected = 580<<20 | 452<<10 | 600;
	arsr1p_rog->skin_cfg = 12<<16 | 10<<8 | 6;
	arsr1p_rog->shoot_cfg1 = 8<<16 | 20;
	arsr1p_rog->shoot_cfg2 = (-80 & 0x7ff) | (8<<16);
	arsr1p_rog->shoot_cfg3 = 372;
	arsr1p_rog->sharp_cfg1_h = 256<<16 | 192;  //no used
	arsr1p_rog->sharp_cfg1_l = 24<<16 | 8;  //no used
	arsr1p_rog->sharp_cfg2_h = 256<<16 | 192;
	arsr1p_rog->sharp_cfg2_l = 32<<16 | 16;
	arsr1p_rog->sharp_cfg3 = 150<<16 | 150;  //no used
	arsr1p_rog->sharp_cfg4 = 200<<16 | 0;  //no used
	arsr1p_rog->sharp_cfg5 = 200<<16 | 0;  //no used
	arsr1p_rog->sharp_cfg6 = 160<<16 | 40;
	arsr1p_rog->sharp_cfg6_cut = 192<<16 | 128;
	arsr1p_rog->sharp_cfg7 = 1<<17 | 8;
	arsr1p_rog->sharp_cfg7_ratio = 160<<16 | 16;
	arsr1p_rog->sharp_cfg8 = 3<<22 | 800;  //no used
	arsr1p_rog->sharp_cfg9 = 8<<22 | 12800;  //no used
	arsr1p_rog->sharp_cfg10 = 800;  //no used
	arsr1p_rog->sharp_cfg11 = 15 << 22 | 12800;
	arsr1p_rog->diff_ctrl = 80<<16 | 64;
	arsr1p_rog->skin_slop_y = 512;
	arsr1p_rog->skin_slop_u = 819;
	arsr1p_rog->skin_slop_v = 682;

	arsr1p_rog->sharp_level = 0x20002;
	arsr1p_rog->sharp_gain_low = 0x3C0078;
	arsr1p_rog->sharp_gain_mid = 0x6400C8;
	arsr1p_rog->sharp_gain_high = 0x5000A0;
	arsr1p_rog->sharp_gainctrl_sloph_mf = 0x280;
	arsr1p_rog->sharp_gainctrl_slopl_mf = 0x1400;
	arsr1p_rog->sharp_gainctrl_sloph_hf = 0x140;
	arsr1p_rog->sharp_gainctrl_slopl_hf = 0xA00;
	arsr1p_rog->sharp_mf_lmt = 0x40;
	arsr1p_rog->sharp_gain_mf = 0x12C012C;
	arsr1p_rog->sharp_mf_b = 0;
	arsr1p_rog->sharp_hf_lmt = 0x80;
	arsr1p_rog->sharp_gain_hf = 0x104012C;
	arsr1p_rog->sharp_hf_b = 0x1400;
	arsr1p_rog->sharp_lf_ctrl = 0x100010;
	arsr1p_rog->sharp_lf_var = 0x1800080;
	arsr1p_rog->sharp_lf_ctrl_slop = 0;
	arsr1p_rog->sharp_hf_select = 0;

}
int hisi_effect_arsr1p_info_get(struct hisi_fb_data_type *hisifd, struct arsr1p_info *arsr1p)
{
	struct arsr1p_info *arsr1p_param = NULL;
	struct arsr1p_info *arsr1p_rog_fhd = NULL;
	struct arsr1p_info *arsr1p_rog_hd = NULL;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == arsr1p) {
		HISI_FB_ERR("fb%d, arsr1p is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr1p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr1p sharp is not supported!\n", hisifd->index);
		return 0;
	}

	arsr1p_param = &(hisifd->effect_info.arsr1p[0]);

	arsr1p_param->sharp_enable = hisifd->panel_info.arsr1p_sharpness_support;
	arsr1p_param->skin_enable = arsr1p_param->sharp_enable;
	arsr1p_param->shoot_enable = arsr1p_param->skin_enable;

	arsr1p_param->skin_thres_y = 332<<10 | 300;
	arsr1p_param->skin_thres_u = 40<<10 | 20;
	arsr1p_param->skin_thres_v = 48<<10 | 24;
	arsr1p_param->skin_expected = 580<<20 | 452<<10 | 600;
	arsr1p_param->skin_cfg = 12<<16 | 10<<8 | 6;

	arsr1p_param->shoot_cfg1 = 8<<16 | 20;
	arsr1p_param->shoot_cfg2 = (-80 & 0x7ff) | (8<<16);
	arsr1p_param->shoot_cfg3 = 372;

	arsr1p_param->sharp_cfg1_h = 256<<16 | 192;  // no used
	arsr1p_param->sharp_cfg1_l = 24<<16 | 8;  // no used
	arsr1p_param->sharp_cfg2_h = 256<<16 | 192;
	arsr1p_param->sharp_cfg2_l = 32<<16 | 16;
	arsr1p_param->sharp_cfg3 = 150<<16 | 150;  // no used
	arsr1p_param->sharp_cfg4 = 200<<16 | 0;  // no used
	arsr1p_param->sharp_cfg5 = 200<<16 | 0;  // no used
	arsr1p_param->sharp_cfg6 = 160<<16 | 40;
	arsr1p_param->sharp_cfg6_cut = 192<<16 | 128;
	arsr1p_param->sharp_cfg7 = 1<<17 | 8;
	arsr1p_param->sharp_cfg7_ratio = 160<<16 | 16;
	arsr1p_param->sharp_cfg8 = 3<<22 | 800;  // no used
	arsr1p_param->sharp_cfg9 = 8<<22 | 12800;  // no used
	arsr1p_param->sharp_cfg10 = 800;  // no used
	arsr1p_param->sharp_cfg11 = 15 << 22 | 12800;

	arsr1p_param->diff_ctrl = 80<<16 | 64;
	arsr1p_param->skin_slop_y = 512;
	arsr1p_param->skin_slop_u = 819;
	arsr1p_param->skin_slop_v = 682;

	arsr1p_param->sharp_level = 0x20002;
	arsr1p_param->sharp_gain_low = 0x3C0078;
	arsr1p_param->sharp_gain_mid = 0x6400C8;
	arsr1p_param->sharp_gain_high = 0x5000A0;
	arsr1p_param->sharp_gainctrl_sloph_mf = 0x280;
	arsr1p_param->sharp_gainctrl_slopl_mf = 0x1400;
	arsr1p_param->sharp_gainctrl_sloph_hf = 0x140;
	arsr1p_param->sharp_gainctrl_slopl_hf = 0xA00;
	arsr1p_param->sharp_mf_lmt = 0x40;
	arsr1p_param->sharp_gain_mf = 0x12C012C;
	arsr1p_param->sharp_mf_b = 0;
	arsr1p_param->sharp_hf_lmt = 0x80;
	arsr1p_param->sharp_gain_hf = 0x104012C;
	arsr1p_param->sharp_hf_b = 0x1400;
	arsr1p_param->sharp_lf_ctrl = 0x100010;
	arsr1p_param->sharp_lf_var = 0x1800080;
	arsr1p_param->sharp_lf_ctrl_slop = 0;
	arsr1p_param->sharp_hf_select = 0;

	memcpy(&(arsr1p[0]), arsr1p_param, sizeof(struct arsr1p_info));

	/*arsr1p rog fhd init*/
	arsr1p_rog_fhd = &(hisifd->effect_info.arsr1p[1]);
	arsr1p_rog_fhd->sharp_enable = hisifd->panel_info.arsr1p_sharpness_support;
	arsr1p_rog_fhd->skin_enable = arsr1p_rog_fhd->sharp_enable;
	arsr1p_rog_fhd->shoot_enable = arsr1p_rog_fhd->skin_enable;
	if (!(hisifd->effect_info.arsr1p_rog_initialized & ARSR1P_ROG_FHD_FLAG)) {
		arsr1p_rog_init(arsr1p_rog_fhd);
		hisifd->effect_info.arsr1p_rog_initialized |= ARSR1P_ROG_FHD_FLAG;
	}

	memcpy(&(arsr1p[1]), arsr1p_rog_fhd, sizeof(struct arsr1p_info));

	/*arsr1p rog hd init*/
	arsr1p_rog_hd = &(hisifd->effect_info.arsr1p[2]);
	arsr1p_rog_hd->sharp_enable = hisifd->panel_info.arsr1p_sharpness_support;
	arsr1p_rog_hd->skin_enable = arsr1p_rog_hd->sharp_enable;
	arsr1p_rog_hd->shoot_enable = arsr1p_rog_hd->skin_enable;
	if (!(hisifd->effect_info.arsr1p_rog_initialized & ARSR1P_ROG_HD_FLAG)) {
		arsr1p_rog_init(arsr1p_rog_hd);
		hisifd->effect_info.arsr1p_rog_initialized |= ARSR1P_ROG_HD_FLAG;
	}

	memcpy(&(arsr1p[2]), arsr1p_rog_hd, sizeof(struct arsr1p_info));

	return 0;
}

int hisi_effect_acm_info_get(struct hisi_fb_data_type *hisifd, struct acm_info *acm_dst)
{
	return 0;
}

int hisi_effect_lcp_info_get(struct hisi_fb_data_type *hisifd, struct lcp_info *lcp)
{
	int ret = 0;
	struct hisi_panel_info *pinfo = NULL;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == lcp) {
		HISI_FB_ERR("fb%d, lcp is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);

	if (hisifd->effect_ctl.lcp_gmp_support && (pinfo->gmp_lut_table_len == LCP_GMP_LUT_LENGTH)) {
		ret = hisi_effect_copy_to_user(lcp->gmp_table_low32, pinfo->gmp_lut_table_low32bit, LCP_GMP_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gmp_table_low32 to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(lcp->gmp_table_high4, pinfo->gmp_lut_table_high4bit, LCP_GMP_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gmp_table_high4 to user!\n", hisifd->index);
			goto err_ret;
		}
	}

	if (hisifd->effect_ctl.lcp_xcc_support && (pinfo->xcc_table_len == LCP_XCC_LUT_LENGTH)) {
		ret = hisi_effect_copy_to_user(lcp->xcc_table, pinfo->xcc_table, LCP_XCC_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy xcc_table to user!\n", hisifd->index);
			goto err_ret;
		}

		lcp->xcc_dual_lcd_top_left = (pinfo->yres/2) << 16;
		lcp->xcc_dual_lcd_bot_right = pinfo->yres << 16 | pinfo->xres;

		ret = hisi_effect_copy_to_user(lcp->xcc_table_pre, pinfo->xcc_table, LCP_XCC_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy xcc_table_pre to user!\n", hisifd->index);
			goto err_ret;
		}
	}

	if (hisifd->effect_ctl.lcp_igm_support && (pinfo->igm_lut_table_len == IGM_LUT_LEN)) {
		ret = hisi_effect_copy_to_user(lcp->igm_r_table, pinfo->igm_lut_table_R, IGM_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy igm_r_table to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(lcp->igm_g_table, pinfo->igm_lut_table_G, IGM_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy igm_g_table to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(lcp->igm_b_table, pinfo->igm_lut_table_B, IGM_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy igm_b_table to user!\n", hisifd->index);
			goto err_ret;
		}
	}

err_ret:
	return ret;
}

int hisi_effect_hiace_info_get(struct hisi_fb_data_type *hisifd, struct hiace_info *hiace) {
	struct hisi_panel_info *pinfo = NULL;
	struct hiace_info *hiace_param = NULL;
	int ret = 0;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == hiace) {
		HISI_FB_ERR("fb%d, hiace is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		HISI_FB_INFO("fb%d, hiace is not supported!\n", hisifd->index);
		return 0;
	}

	hiace_param = &(hisifd->effect_info.hiace);

	hiace->image_info = hiace_param->image_info;
	hiace->half_block_info = hiace_param->half_block_info;
	hiace->xyweight = hiace_param->xyweight;
	hiace->lhist_sft = hiace_param->lhist_sft;
	hiace->roi_start_point = hiace_param->roi_start_point;
	hiace->roi_width_high = hiace_param->roi_width_high;
	hiace->roi_mode_ctrl = hiace_param->roi_mode_ctrl;
	hiace->roi_hist_stat_mode = hiace_param->roi_hist_stat_mode;
	hiace->hue = hiace_param->hue;
	hiace->saturation = hiace_param->saturation;
	hiace->value = hiace_param->value;
	hiace->skin_gain = hiace_param->skin_gain;
	hiace->up_low_th = hiace_param->up_low_th;
	hiace->rgb_blend_weight = hiace_param->rgb_blend_weight;
	hiace->fna_statistic = hiace_param->fna_statistic;
	hiace->up_cnt = hiace_param->up_cnt;
	hiace->low_cnt = hiace_param->low_cnt;
	hiace->sum_saturation = hiace_param->sum_saturation;
	hiace->lhist_en = hiace_param->lhist_en;
	hiace->gamma_w = hiace_param->gamma_w;
	hiace->gamma_r = hiace_param->gamma_r;
	hiace->fna_addr = hiace_param->fna_addr;
	hiace->fna_data = hiace_param->fna_data;
	hiace->update_fna = hiace_param->update_fna;
	hiace->fna_valid = hiace_param->fna_valid;
	hiace->db_pipe_cfg = hiace_param->db_pipe_cfg;
	hiace->db_pipe_ext_width = hiace_param->db_pipe_ext_width;
	hiace->db_pipe_full_img_width = hiace_param->db_pipe_full_img_width;
	hiace->bypass_nr = hiace_param->bypass_nr;
	hiace->bypass_nr_gain= hiace_param->bypass_nr_gain;
	hiace->s3_some_brightness01 = hiace_param->s3_some_brightness01;
	hiace->s3_some_brightness23 = hiace_param->s3_some_brightness23;
	hiace->s3_some_brightness4 = hiace_param->s3_some_brightness4;
	hiace->s3_min_max_sigma = hiace_param->s3_min_max_sigma;
	hiace->s3_green_sigma03 = hiace_param->s3_green_sigma03;
	hiace->s3_green_sigma45 = hiace_param->s3_green_sigma45;
	hiace->s3_red_sigma03 = hiace_param->s3_red_sigma03;
	hiace->s3_red_sigma45 = hiace_param->s3_red_sigma45;
	hiace->s3_blue_sigma03 = hiace_param->s3_blue_sigma03;
	hiace->s3_blue_sigma45 = hiace_param->s3_blue_sigma45;
	hiace->s3_white_sigma03 = hiace_param->s3_white_sigma03;
	hiace->s3_white_sigma45 = hiace_param->s3_white_sigma45;
	hiace->s3_filter_level = hiace_param->s3_filter_level;
	hiace->s3_similarity_coeff = hiace_param->s3_similarity_coeff;
	hiace->s3_v_filter_weight_adj = hiace_param->s3_v_filter_weight_adj;
	hiace->s3_hue = hiace_param->s3_hue;
	hiace->s3_saturation = hiace_param->s3_saturation;
	hiace->s3_value = hiace_param->s3_value;
	hiace->s3_skin_gain = hiace_param->s3_skin_gain;
	hiace->param_update = hiace_param->param_update;
	hiace->enable = hiace_param->enable;
	hiace->enable_update = hiace_param->enable_update;
	hiace->lut_update = hiace_param->lut_update;
	hiace->hdr10_en = hiace_param->hdr10_en;
	hiace->loglum_max = hiace_param->loglum_max;
	hiace->hist_modev = hiace_param->hist_modev;
	hiace->end_point = hiace_param->end_point;
	hiace->table_update = hiace_param->table_update;

	ret = hisi_effect_copy_to_user(hiace->detail_weight_table, hisifd->effect_info.hiace.detail_weight_table, HIACE_DETAIL_WEIGHT_TABLE_LEN);
	if (ret) {
		HISI_FB_ERR("fb%d, failed to copy detail_weight_table to user!\n", hisifd->index);
	}

	ret = hisi_effect_copy_to_user(hiace->loglum_eotf_table, hisifd->effect_info.hiace.loglum_eotf_table, HIACE_LOGLUM_EOTF_TABLE_LEN);
	if (ret) {
		HISI_FB_ERR("fb%d, failed to copy loglum_eotf_table to user!\n", hisifd->index);
	}

	ret = hisi_effect_copy_to_user(hiace->luma_gamma_table, hisifd->effect_info.hiace.luma_gamma_table, HIACE_LUMA_GAMA_TABLE_LEN);
	if (ret) {
		HISI_FB_ERR("fb%d, failed to copy luma_gamma_table to user!\n", hisifd->index);
	}

	return ret;
}

int hisi_effect_gamma_info_get(struct hisi_fb_data_type *hisifd, struct gamma_info *gamma)
{
	struct hisi_panel_info *pinfo = NULL;
	int ret = 0;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == gamma) {
		HISI_FB_ERR("fb%d, gamma is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.gamma_support) {
		HISI_FB_INFO("fb%d, gamma is not supported!\n", hisifd->index);
		return 0;
	}

	pinfo = &(hisifd->panel_info);

	if (hisifd->effect_ctl.lcp_gmp_support && (pinfo->gamma_lut_table_len== GAMMA_LUT_LEN)) {
		gamma->para_mode = 0;

		gamma->gamma_dual_lcd_top_left= (pinfo->yres/2)<<16;
		gamma->gamma_dual_lcd_bot_right=(pinfo->yres<<16) | pinfo->xres;

		ret = hisi_effect_copy_to_user(gamma->gamma_r_table, pinfo->gamma_lut_table_R, GAMMA_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_r_table to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(gamma->gamma_g_table, pinfo->gamma_lut_table_G, GAMMA_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_g_table to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(gamma->gamma_b_table, pinfo->gamma_lut_table_B, GAMMA_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_b_table to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(gamma->gamma_r_table_pre, pinfo->gamma_lut_table_R, GAMMA_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_r_table to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(gamma->gamma_g_table_pre, pinfo->gamma_lut_table_G, GAMMA_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_g_table to user!\n", hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(gamma->gamma_b_table_pre, pinfo->gamma_lut_table_B, GAMMA_LUT_LEN);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_b_table to user!\n", hisifd->index);
			goto err_ret;
		}
	}

err_ret:
	return ret;
}
#define ARSR2P_MAX_NUM 3

int hisi_effect_arsr2p_info_set(struct hisi_fb_data_type *hisifd, struct arsr2p_info *arsr2p)
{
	uint32_t i;
	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == arsr2p) {
		HISI_FB_ERR("fb%d, arsr2p is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr2p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr2p sharp is not supported!\n", hisifd->index);
		return 0;
	}

	for (i = 0; i < ARSR2P_MAX_NUM; i++) {
		if (arsr2p[i].update == 1) {
			memcpy(&(hisifd->effect_info.arsr2p[i]), &(arsr2p[i]), sizeof(struct arsr2p_info));
		}
	}

	hisifd->effect_updated_flag.arsr2p_effect_updated = true;

	//debug info
	for (i = 0; i < ARSR2P_MAX_NUM; i++) {
		if (hisifd->effect_info.arsr2p[i].update) {
			HISI_FB_INFO("arsr2p mode %d: enable : %u, sharp_enable:%u, shoot_enable:%u, skin_enable:%u, update: %u\n",
				i, hisifd->effect_info.arsr2p[i].enable, hisifd->effect_info.arsr2p[i].sharp_enable, hisifd->effect_info.arsr2p[i].shoot_enable, hisifd->effect_info.arsr2p[i].skin_enable,
                hisifd->effect_info.arsr2p[i].update);
		}
	}

	return 0;
}

int hisi_effect_arsr1p_info_set(struct hisi_fb_data_type *hisifd, struct arsr1p_info *arsr1p)
{
	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == arsr1p) {
		HISI_FB_ERR("fb%d, arsr1p is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr1p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr1p sharp is not supported!\n", hisifd->index);
		return 0;
	}

	arsr1p->enable = (arsr1p->para_mode) & 0x1;
	memcpy(hisifd->effect_info.arsr1p, arsr1p, sizeof(struct arsr1p_info) * ARSR1P_INFO_SIZE);
	hisifd->effect_updated_flag.arsr1p_effect_updated = true;

	if (arsr1p[1].update == 1) {
		hisifd->effect_info.arsr1p_rog_initialized |= ARSR1P_ROG_FHD_FLAG;
	}

	if (arsr1p[2].update == 1) {
		hisifd->effect_info.arsr1p_rog_initialized |= ARSR1P_ROG_HD_FLAG;
	}

	return 0;
}

int hisi_effect_acm_info_set(struct hisi_fb_data_type *hisifd, struct acm_info *acm_src)
{
	return 0;
}

int hisi_effect_gmp_info_set(struct hisi_fb_data_type *hisifd, struct lcp_info *lcp_src)
{
	struct lcp_info *lcp_dst = NULL;
	struct dss_effect *effect = NULL;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return -EINVAL;
	}

	if (NULL == lcp_src) {
		HISI_FB_ERR("fb%d, lcp_src is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	lcp_dst = &(hisifd->effect_info.lcp);
	effect = &(hisifd->effect_ctl);

	if (!effect->lcp_gmp_support) {
		HISI_FB_INFO("fb%d, lcp gmp is not supported!\n", hisifd->index);
		return 0;
	}

	lcp_dst->gmp_enable = lcp_src->gmp_enable;
	/*only update gmp lut when gmp is enabled*/
	if (lcp_src->gmp_enable) {
		spin_lock(&g_gmp_effect_lock);
		if (hisi_effect_alloc_and_copy(&lcp_dst->gmp_table_high4, lcp_src->gmp_table_high4,
			LCP_GMP_LUT_LENGTH, true)) {
			HISI_FB_ERR("fb%d, failed to set gmp_table_high4!\n", hisifd->index);
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&lcp_dst->gmp_table_low32, lcp_src->gmp_table_low32,
			LCP_GMP_LUT_LENGTH, true)) {
			HISI_FB_ERR("fb%d, failed to set gmp_lut_table_low32bit!\n", hisifd->index);
			goto err_ret;
		}
		spin_unlock(&g_gmp_effect_lock);
	}

	/*sdk updated gmp lut, driver need to config the lut reg*/
	hisifd->effect_updated_flag.gmp_effect_updated = true;

	if(hisifd->online_play_count > 1 && hisifd->gmp_lut_wq) {
		queue_work(hisifd->gmp_lut_wq, &hisifd->gmp_lut_work);
	}

	return 0;

err_ret:
	spin_unlock(&g_gmp_effect_lock);
	return -EINVAL;
}

int hisi_effect_igm_info_set(struct hisi_fb_data_type *hisifd, struct lcp_info *lcp_src){
	struct lcp_info *lcp_dst = NULL;
	struct dss_effect *effect = NULL;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return -EINVAL;
	}

	if (NULL == lcp_src) {
		HISI_FB_ERR("fb%d, lcp_src is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	lcp_dst = &(hisifd->effect_info.lcp);
	effect = &(hisifd->effect_ctl);

	if (!effect->lcp_igm_support) {
		HISI_FB_INFO("fb%d, lcp degamma is not supported!\n", hisifd->index);
		return 0;
	}

	spin_lock(&g_igm_effect_lock);

	lcp_dst->igm_enable = lcp_src->igm_enable;

	if (hisi_effect_alloc_and_copy(&lcp_dst->igm_r_table, lcp_src->igm_r_table,
		IGM_LUT_LEN, true)) {
		HISI_FB_ERR("fb%d, failed to set igm_r_table!\n", hisifd->index);
		goto err_ret;
	}

	if (hisi_effect_alloc_and_copy(&lcp_dst->igm_g_table, lcp_src->igm_g_table,
		IGM_LUT_LEN, true)) {
		HISI_FB_ERR("fb%d, failed to set igm_g_table!\n", hisifd->index);
		goto err_ret;
	}

	if (hisi_effect_alloc_and_copy(&lcp_dst->igm_b_table, lcp_src->igm_b_table,
		IGM_LUT_LEN, true)) {
		HISI_FB_ERR("fb%d, failed to set igm_b_table!\n", hisifd->index);
		goto err_ret;
	}

	hisifd->effect_updated_flag.igm_effect_updated = true;

	spin_unlock(&g_igm_effect_lock);
	return 0;

err_ret:
	hisi_effect_kfree(&lcp_dst->igm_r_table);
	hisi_effect_kfree(&lcp_dst->igm_g_table);
	hisi_effect_kfree(&lcp_dst->igm_b_table);

	spin_unlock(&g_igm_effect_lock);
	return -EINVAL;
}

int hisi_effect_xcc_info_set(struct hisi_fb_data_type *hisifd, struct lcp_info *lcp_src){
	struct lcp_info *lcp_dst = NULL;
	struct dss_effect *effect = NULL;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return -EINVAL;
	}

	if (NULL == lcp_src) {
		HISI_FB_ERR("fb%d, lcp_src is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	lcp_dst = &(hisifd->effect_info.lcp);
	effect = &(hisifd->effect_ctl);

	if (!effect->lcp_xcc_support) {
		HISI_FB_INFO("fb%d, lcp xcc are not supported!\n", hisifd->index);
		return 0;
	}

	spin_lock(&g_xcc_effect_lock);

	lcp_dst->xcc_enable = lcp_src->xcc_enable;
	lcp_dst->xcc_pre_enable=lcp_src->xcc_pre_enable;

	if (hisi_effect_alloc_and_copy(&lcp_dst->xcc_table, lcp_src->xcc_table,
		LCP_XCC_LUT_LENGTH, true)) {
		HISI_FB_ERR("fb%d, failed to set xcc_table!\n", hisifd->index);
		goto err_ret;
	}

	if(lcp_dst->xcc_pre_enable){
		if((0x0 == lcp_src->xcc_dual_lcd_top_left) && (0x0 == lcp_src->xcc_dual_lcd_bot_right)){
			lcp_src->xcc_dual_lcd_top_left= ((hisifd->panel_info.yres)/2)<<16;
			lcp_src->xcc_dual_lcd_bot_right=((hisifd->panel_info.yres)<<16 | (hisifd->panel_info.xres));
		}
		else{
			if(((((lcp_src->xcc_dual_lcd_top_left) >> 16) & 0x1fff) < 0) || (((lcp_src->xcc_dual_lcd_top_left) & 0x1fff) < 0)){
				HISI_FB_ERR("xcc dual_lcd_top_left_x or dual_lcd_top_left_x  is  less than 0!\n");
				goto err_ret;
			}

			if(((((lcp_src->xcc_dual_lcd_bot_right) >> 16) & 0x1fff) > (hisifd->panel_info.yres)) || (((lcp_src->xcc_dual_lcd_bot_right) & 0x1fff)> (hisifd->panel_info.xres))){
				HISI_FB_ERR("xcc dual_lcd_bot_right_x or dual_lcd_bot_right_y is larger than pinfo size!\n");
				goto err_ret;
			}

			if(((((lcp_src->xcc_dual_lcd_top_left) >> 16) & 0x1fff) > (((lcp_src->xcc_dual_lcd_bot_right) >> 16) & 0x1fff)) || (((lcp_src->xcc_dual_lcd_top_left) & 0x1fff) > ((lcp_src->xcc_dual_lcd_bot_right) & 0x1fff))){
				HISI_FB_ERR("xcc dual_lcd_top_left is less than dual_lcd_bot_right!\n");
				goto err_ret;
			}

			lcp_dst->xcc_dual_lcd_top_left = lcp_src->xcc_dual_lcd_top_left;
			lcp_dst->xcc_dual_lcd_bot_right = lcp_src->xcc_dual_lcd_bot_right;
		}

		if (hisi_effect_alloc_and_copy(&lcp_dst->xcc_table_pre,
		lcp_src->xcc_table_pre,
		LCP_XCC_LUT_LENGTH, true)) {
		HISI_FB_ERR("fb%d, failed to set xcc_table_pre!\n", hisifd->index);
		goto err_ret;
		}
	}

	hisifd->effect_updated_flag.xcc_effect_updated = true;

	spin_unlock(&g_xcc_effect_lock);
	return 0;

err_ret:
	hisi_effect_kfree(&lcp_dst->xcc_table);
	hisi_effect_kfree(&lcp_dst->xcc_table_pre);

	spin_unlock(&g_xcc_effect_lock);
	return -EINVAL;
}


static int hisi_efffect_gamma_lut_set(struct gamma_info *gammaDst, struct gamma_info *gammaSrc,
                                  struct hisi_panel_info* pInfo) {

	if (gammaSrc->para_mode == 0) {
		//Normal mode
		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_r_table, pInfo->gamma_lut_table_R,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_r_table!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_g_table, pInfo->gamma_lut_table_G,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_g_table!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_b_table, pInfo->gamma_lut_table_B,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_b_table!\n");
			goto err_ret;
		}
	} else if (gammaSrc->para_mode == 1) {
		//Cinema mode
		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_r_table, pInfo->cinema_gamma_lut_table_R,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_r_table!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_g_table, pInfo->cinema_gamma_lut_table_G,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_g_table!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_b_table, pInfo->cinema_gamma_lut_table_B,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_b_table!\n");
			goto err_ret;
		}
	} else if (gammaSrc->para_mode == 2) {
		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_r_table, gammaSrc->gamma_r_table,
			GAMMA_LUT_LEN, true)) {
			HISI_FB_ERR("failed to copy gamma_r_table from user!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_g_table, gammaSrc->gamma_g_table,
			GAMMA_LUT_LEN, true)) {
			HISI_FB_ERR("failed to copy gamma_g_table from user!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_b_table, gammaSrc->gamma_b_table,
			GAMMA_LUT_LEN, true)) {
			HISI_FB_ERR("failed to copy gamma_b_table from user!\n");
			goto err_ret;
		}
	} else {
		HISI_FB_ERR("not supported gamma para_mode!\n");
		return -EINVAL;
	}

	return 0;

err_ret:
	free_gamma_table(gammaDst);

	return -EINVAL;

}

static int hisi_efffect_gamma_lut_pre_set(struct gamma_info *gammaDst, struct gamma_info *gammaSrc,
                                  struct hisi_panel_info* pInfo) {
        if(NULL==gammaDst){
		HISI_FB_ERR("gammaDst is NULL!\n");
		return -EINVAL;
        }

        if(NULL==gammaSrc){
		HISI_FB_ERR("gammaSrc is NULL!\n");
		return -EINVAL;
        }

	if ((0x0 == gammaSrc->gamma_dual_lcd_top_left) && (0x0 == gammaSrc->gamma_dual_lcd_bot_right)){
		gammaDst->gamma_dual_lcd_top_left= (pInfo->yres/2)<<16;
		gammaDst->gamma_dual_lcd_bot_right=((pInfo->yres)<<16 | pInfo->xres);
	}
	else{
		if(((((gammaSrc->gamma_dual_lcd_top_left) >> 16) & 0x1fff) < 0) || (((gammaSrc->gamma_dual_lcd_top_left) & 0x1fff) < 0)){
			HISI_FB_ERR("gamma dual_lcd_top_left_x or dual_lcd_top_left_x  is  less than 0!\n");
			return -EINVAL;
		}

		if(((((gammaSrc->gamma_dual_lcd_bot_right) >> 16) & 0x1fff) > pInfo->yres) || (((gammaSrc->gamma_dual_lcd_bot_right)& 0x1fff) > pInfo->xres)){
			HISI_FB_ERR("gamma dual_lcd_bot_right_x or dual_lcd_bot_right_y is larger than pinfo size!\n");
			return -EINVAL;
		}

		if(((((gammaSrc->gamma_dual_lcd_top_left) >> 16) & 0x1fff) > (((gammaSrc->gamma_dual_lcd_bot_right) >> 16) & 0x1fff)) || (((gammaSrc->gamma_dual_lcd_top_left) & 0x1fff) > ((gammaSrc->gamma_dual_lcd_bot_right) & 0x1fff))){
			HISI_FB_ERR("gamma dual_lcd_top_left is less than dual_lcd_bot_right!\n");
			return -EINVAL;
		}

		gammaDst->gamma_dual_lcd_top_left = gammaSrc->gamma_dual_lcd_top_left;
		gammaDst->gamma_dual_lcd_bot_right = gammaSrc->gamma_dual_lcd_bot_right;
	}

	if (gammaSrc->para_mode == 0) {
		//Normal mode
		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_r_table_pre, pInfo->gamma_lut_table_R,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_r_table_pre!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_g_table_pre, pInfo->gamma_lut_table_G,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_g_table_pre!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_b_table_pre, pInfo->gamma_lut_table_B,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_b_table_pre!\n");
			goto err_ret;
		}
	} else if (gammaSrc->para_mode == 1) {
		//Cinema mode
		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_r_table_pre, pInfo->cinema_gamma_lut_table_R,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_r_table_pre!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_g_table_pre, pInfo->cinema_gamma_lut_table_G,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_g_table_pre!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_b_table_pre, pInfo->cinema_gamma_lut_table_B,
			GAMMA_LUT_LEN, false)) {
			HISI_FB_ERR("failed to set gamma_b_table_pre!\n");
			goto err_ret;
		}
	} else if (gammaSrc->para_mode == 2) {
		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_r_table_pre,
		gammaSrc->gamma_r_table_pre,
			GAMMA_LUT_LEN, true)) {
			HISI_FB_ERR("failed to copy gamma_r_table_pre from user!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_g_table_pre,
		gammaSrc->gamma_g_table_pre,
			GAMMA_LUT_LEN, true)) {
			HISI_FB_ERR("failed to copy gamma_g_table_pre from user!\n");
			goto err_ret;
		}

		if (hisi_effect_alloc_and_copy(&gammaDst->gamma_b_table_pre,
		gammaSrc->gamma_b_table_pre,
			GAMMA_LUT_LEN, true)) {
			HISI_FB_ERR("failed to copy gamma_b_table_pre from user!\n");
			goto err_ret;
		}
	} else {
		HISI_FB_ERR("not supported gamma para_mode!\n");
		return -EINVAL;
	}

	return 0;

err_ret:
       gammaDst->gamma_dual_lcd_top_left= (pInfo->yres/2)<<16;
       gammaDst->gamma_dual_lcd_bot_right=((pInfo->yres)<<16 | pInfo->xres);
	free_gamma_table(gammaDst);

	return -EINVAL;

}

static int hisi_efffect_gamma_param_set(struct gamma_info *gammaDst, struct gamma_info *gammaSrc,
                                  struct hisi_panel_info* pInfo) {
	int ret;

	if(NULL==gammaDst){
		HISI_FB_ERR("gammaDst is NULL!\n");
		return -EINVAL;
        }

	if(NULL==gammaSrc){
		HISI_FB_ERR("gammaSrc is NULL!\n");
		return -EINVAL;
        }

	ret = hisi_efffect_gamma_lut_set(gammaDst, gammaSrc,pInfo);
	if (ret < 0) {
		HISI_FB_ERR("failed to set gamma lut!\n");
		return -EINVAL;
	}

	if (gammaSrc->pre_enable) {
		ret = hisi_efffect_gamma_lut_pre_set(gammaDst, gammaSrc,pInfo);
		if (ret < 0) {
			HISI_FB_ERR("failed to set gamma lut pre!\n");
			return -EINVAL;
		}
       }
	return 0;
}

int hisi_effect_gamma_info_set(struct hisi_fb_data_type *hisifd, struct gamma_info *gamma_src)
{
	struct gamma_info *gamma_dst = NULL;
	struct hisi_panel_info *pinfo = NULL;
	int ret;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return -EINVAL;
	}

	if (NULL == gamma_src) {
		HISI_FB_ERR("fb%d, gamma_src is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	gamma_dst = &(hisifd->effect_info.gamma);
	pinfo = &(hisifd->panel_info);

	if (!hisifd->effect_ctl.gamma_support) {
		HISI_FB_INFO("fb%d, gamma is not supported!\n", hisifd->index);
		return 0;
	}

	spin_lock(&g_gamma_effect_lock);

	gamma_dst->enable = gamma_src->enable;
	gamma_dst->pre_enable = gamma_src->pre_enable;
	gamma_dst->para_mode = gamma_src->para_mode;
	ret = hisi_efffect_gamma_param_set(gamma_dst, gamma_src, pinfo);
	if (ret < 0) {
		HISI_FB_ERR("fb%d, failed to set gamma table!\n", hisifd->index);
		spin_unlock(&g_gamma_effect_lock);
		return ret;
	}

	hisifd->effect_updated_flag.gamma_effect_updated = true;

	spin_unlock(&g_gamma_effect_lock);

	return 0;
}

void hisi_effect_acm_set_reg(struct hisi_fb_data_type *hisifd)
{
	return;
}

static bool lcp_igm_set_reg(char __iomem *degamma_lut_base, struct lcp_info *lcp_param)
{
	int cnt;

	if (degamma_lut_base == NULL) {
		HISI_FB_ERR("lcp_lut_base is NULL!\n");
		return false;
	}

	if (lcp_param == NULL) {
		HISI_FB_ERR("lcp_param is NULL!\n");
		return false;
	}

	if (lcp_param->igm_r_table == NULL || lcp_param->igm_g_table == NULL || lcp_param->igm_b_table == NULL) {
		HISI_FB_INFO("igm_r_table or igm_g_table or igm_b_table	is NULL!\n");
		return false;
	}

	for (cnt = 0; cnt < IGM_LUT_LEN; cnt = cnt + 2) {
		set_reg(degamma_lut_base + (U_DEGAMA_R_COEF + cnt * 2), lcp_param->igm_r_table[cnt], 12,0);
		if(cnt != IGM_LUT_LEN-1)
			set_reg(degamma_lut_base + (U_DEGAMA_R_COEF + cnt * 2), lcp_param->igm_r_table[cnt+1], 12,16);

		set_reg(degamma_lut_base + (U_DEGAMA_G_COEF + cnt * 2), lcp_param->igm_g_table[cnt], 12,0);
		if(cnt != IGM_LUT_LEN-1)
			set_reg(degamma_lut_base + (U_DEGAMA_G_COEF + cnt * 2), lcp_param->igm_g_table[cnt+1], 12,16);

		set_reg(degamma_lut_base + (U_DEGAMA_B_COEF + cnt * 2), lcp_param->igm_b_table[cnt], 12,0);
		if(cnt != IGM_LUT_LEN-1)
			set_reg(degamma_lut_base + (U_DEGAMA_B_COEF + cnt * 2), lcp_param->igm_b_table[cnt+1], 12,16);
	}
	return true;
}

static bool lcp_xcc_set_reg(char __iomem *xcc_base, struct lcp_info *lcp_param)
{
	int cnt;

	if (xcc_base == NULL) {
		HISI_FB_DEBUG("lcp_base is NULL!\n");
		return false;
	}

	if (lcp_param == NULL) {
		HISI_FB_DEBUG("lcp_param is NULL!\n");
		return false;
	}

	if (lcp_param->xcc_table == NULL) {
		HISI_FB_DEBUG("xcc_table is NULL!\n");
		return false;
	}
	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++) {
		set_reg(xcc_base + XCC_COEF_00 +cnt * 4,  lcp_param->xcc_table[cnt], 17, 0);
	}

	return true;
}

static void reset_xcc_reg(char __iomem *xcc_base)
{
	int cnt;
	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++) {
		if (cnt == XCC_COEF_INDEX_01 || cnt == XCC_COEF_INDEX_12 || cnt == XCC_COEF_INDEX_23) {
			set_reg(xcc_base + XCC_COEF_00 +cnt * 4,  0x8000, 17, 0);
		} else {
			set_reg(xcc_base + XCC_COEF_00 +cnt * 4,  0x0, 17, 0);
		}
	}
}

void clear_xcc_table(struct hisi_fb_data_type *hisifd)
{
	char __iomem *xcc_base = NULL;
	int cnt;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is null!\n");
		return;
	}

	xcc_base = hisifd->dss_base + DSS_DPP_XCC_OFFSET;

	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++) {
		xcc_table_temp[cnt] = inp32(xcc_base + XCC_COEF_00 +cnt * 4);//lint !e679
	}

	//bypass xcc
	reset_xcc_reg(xcc_base);
	xcc_enable_state = inp32(xcc_base + XCC_EN);
}

void restore_xcc_table(struct hisi_fb_data_type *hisifd)
{
	int cnt;
	char __iomem *xcc_base = NULL;
	struct lcp_info *lcp_param = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is null!\n");
		return;
	}

	xcc_base = hisifd->dss_base + DSS_DPP_XCC_OFFSET;
	lcp_param = &(hisifd->effect_info.lcp);

	if (xcc_base == NULL) {
		HISI_FB_DEBUG("lcp_base is NULL!\n");
		return;
	}

	if (lcp_param == NULL) {
		HISI_FB_ERR("lcp_param is null!\n");
		return;
	}

	if (lcp_param->xcc_table == NULL) {
		HISI_FB_DEBUG("xcc_table is NULL!\n");
		return;
	}

	//enable xcc
	if (spin_can_lock(&g_xcc_effect_lock)) {
		spin_lock(&g_xcc_effect_lock);
		if (!hisifd->effect_updated_flag.xcc_effect_updated) {
			for (cnt = 0; cnt < XCC_COEF_LEN; cnt++) {
				lcp_param->xcc_table[cnt] = xcc_table_temp[cnt];
			}
			lcp_xcc_set_reg(xcc_base, lcp_param);
			set_reg(xcc_base + XCC_EN, xcc_enable_state & 0x3, 2, 0);
		} else {
			lcp_xcc_set_reg(xcc_base, lcp_param);
			set_reg(xcc_base + XCC_EN, (lcp_param->xcc_enable | lcp_param->xcc_pre_enable << 1) & 0x3, 2, 0);
			hisifd->effect_updated_flag.xcc_effect_updated = FALSE;
		}
		spin_unlock(&g_xcc_effect_lock);
	} else {
		HISI_FB_INFO("xcc effect param is being updated, delay set reg to next frame!\n");
	}

}

static bool lcp_xcc_pre_set_reg(char __iomem *xcc_pre_base, struct lcp_info *lcp_param)
{
	int cnt;

	if (xcc_pre_base == NULL) {
		HISI_FB_DEBUG("lcp_base is NULL!\n");
		return false;
	}

	if (lcp_param == NULL) {
		HISI_FB_DEBUG("lcp_param is NULL!\n");
		return false;
	}

	if (lcp_param->xcc_table == NULL) {
		HISI_FB_DEBUG("xcc_table is NULL!\n");
		return false;
	}
	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++) {
		set_reg(xcc_pre_base + XCC_COEF_00 +cnt * 4,  lcp_param->xcc_table_pre[cnt], 17, 0);
	}
	return true;
}

static bool lcp_gmp_set_reg(char __iomem *gmp_lut_base, uint32_t *gmp_lut_low32, uint32_t *gmp_lut_high4)
{
	int i;

	if (gmp_lut_base == NULL) {
		HISI_FB_DEBUG("gmp_lut_base is NULL!\n");
		return false;
	}

	if (gmp_lut_low32 == NULL || gmp_lut_high4 == NULL) {
		HISI_FB_DEBUG("gmp_table_low32 or gmp_table_high4 is NULL!\n");
		return false;
	}

	for (i = 0; i < GMP_COFE_CNT; i++) {
		set_reg(gmp_lut_base + i * 2 * 4, gmp_lut_low32[i], 32, 0);
		set_reg(gmp_lut_base + i * 2 * 4 + 4, gmp_lut_high4[i], 4, 0);
		if( 0 == (i%500))
			HISI_FB_DEBUG("[effect] gmp_table_low32[%d]=%d,gmp_table_high4[%d]=%d\n",i,gmp_lut_low32[i],i,gmp_lut_high4[i]);
	}

	return true;
}

void hisifb_effect_gmp_lut_workqueue_handler(struct work_struct *work)
{
	struct hisi_fb_data_type *hisifd = NULL;
	int ret = 0;
	struct dss_effect *effect = NULL;
	struct lcp_info *lcp_param = NULL;
	char __iomem *gmp_lut_base = NULL;
	//uint32_t degama_lut_sel;
	uint32_t gmp_lut_sel =0;
	uint32_t is_enable = 0;
	char __iomem *gmp_base = NULL;
	struct timeval tv1, tv2, tv3, tv4;
	int gmp_en = 0;

	if (NULL == work) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	hisifd = container_of(work, struct hisi_fb_data_type, gmp_lut_work);
	if (NULL == hisifd || hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] hisifd is NULL or not primary panel\n");
		return;
	}

	gmp_base = hisifd->dss_base + DSS_DPP_GMP_OFFSET;
	gmp_lut_base = hisifd->dss_base + DSS_DPP_GMP_LUT_OFFSET;

	effect = &hisifd->effect_ctl;
	if (NULL == effect) {
		HISI_FB_ERR("[effect] effect is NULL\n");
		return;
	}

	lcp_param = &(hisifd->effect_info.lcp);
	if (NULL == lcp_param) {
		HISI_FB_ERR("[effect] lcp_param is NULL\n");
		return;
	}

	if (effect->lcp_gmp_support && hisifd->effect_updated_flag.gmp_effect_updated) {
		down(&hisifd->blank_sem);
		if (!hisifd->panel_power_on) {
			HISI_FB_INFO("[effect] fb%d, panel is power off!\n", hisifd->index);
			up(&hisifd->blank_sem);
			return;
		}
		hisifb_activate_vsync(hisifd);

		is_enable = lcp_param->gmp_enable;
		if (is_enable)  {
			if ((lcp_param->gmp_table_low32 == NULL) || (lcp_param->gmp_table_high4 == NULL)) {
				HISI_FB_ERR("gmp table got NULL pointer,need goto err out!\n");
				goto ERR_OUT;
			}

			if (spin_can_lock(&g_gmp_effect_lock)) {
				if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
					hisifb_get_timestamp(&tv1);
				}
				spin_lock(&g_gmp_effect_lock);
				memcpy(gmp_lut_table_low32bit_wq_doing, lcp_param->gmp_table_low32, GMP_COFE_CNT * sizeof(u32));
				memcpy(gmp_lut_table_high4bit_wq_doing, lcp_param->gmp_table_high4, GMP_COFE_CNT * sizeof(u32));
				spin_unlock(&g_gmp_effect_lock);
				if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
					hisifb_get_timestamp(&tv2);
				}
				HISI_FB_DEBUG("[effect] gmp lut update to software time : %uus!\n", hisifb_timestamp_diff(&tv1, &tv2));
			} else {
				HISI_FB_INFO("gmp effect param is being updated, delay set reg to next frame!\n");
				goto ERR_OUT;
			}

			if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
				hisifb_get_timestamp(&tv3);
			}
			ret = lcp_gmp_set_reg(gmp_lut_base, gmp_lut_table_low32bit_wq_doing, gmp_lut_table_high4bit_wq_doing);
			if (ret) {
				//Enable GMP
				gmp_lut_sel = inp32(gmp_base + GMP_LUT_SEL);
				set_reg(gmp_base + GMP_LUT_SEL, (~(gmp_lut_sel & 0x1)) & 0x1, 1, 0);
				set_reg(gmp_base + GMP_EN, is_enable, 1, 0);
				hisifd->effect_updated_flag.gmp_effect_updated = false;
			}
			if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
				hisifb_get_timestamp(&tv4);
			}
			HISI_FB_DEBUG("[effect] gmp lut set_reg time : %uus!\n", hisifb_timestamp_diff(&tv3, &tv4));

			hisifd->effect_gmp_update_flag = true;
		} else {
			//disable  GMP
			set_reg(gmp_base + GMP_EN, is_enable, 1, 0);
			hisifd->effect_updated_flag.gmp_effect_updated = false;
		}
		gmp_en = inp32(gmp_base + GMP_EN);
		HISI_FB_DEBUG("[effect] gmp_lut_sel=%d, gmp=%d\n", gmp_lut_sel, gmp_en);

ERR_OUT:
		hisifb_deactivate_vsync(hisifd);
		up(&hisifd->blank_sem);
		HISI_FB_DEBUG("-\n");
		return;
	}
	HISI_FB_DEBUG("-\n");
	return;
}

void hisi_effect_lcp_set_reg(struct hisi_fb_data_type *hisifd)
{
	struct dss_effect *effect = NULL;
	struct lcp_info *lcp_param = NULL;
	char __iomem *xcc_base = NULL;
	char __iomem *degamma_base = NULL;
	char __iomem *gmp_base = NULL;
	char __iomem *gmp_lut_base = NULL;
	char __iomem *degamma_lut_base = NULL;
	char __iomem *lcp_base = NULL;
	char __iomem *dpp_top_base = NULL;
	char __iomem *xcc_pre_base = NULL;
	uint32_t degama_lut_sel = 0;
	uint32_t gmp_lut_sel = 0;
	int gmp_en = 0;

	bool ret;
	int i=0;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!");
		return;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return;
	}

	effect = &hisifd->effect_ctl;

	lcp_base = hisifd->dss_base + DSS_DPP_LCP_OFFSET_ES;
	xcc_base = hisifd->dss_base + DSS_DPP_XCC_OFFSET;
	degamma_base = hisifd->dss_base + DSS_DPP_DEGAMMA_OFFSET;
	degamma_lut_base = hisifd->dss_base + DSS_DPP_DEGAMMA_LUT_OFFSET;
	gmp_base = hisifd->dss_base + DSS_DPP_GMP_OFFSET;
	gmp_lut_base = hisifd->dss_base + DSS_DPP_GMP_LUT_OFFSET;
	dpp_top_base = hisifd->dss_base + DSS_DPP_OFFSET;
	xcc_pre_base = hisifd->dss_base + DSS_DPP_XCC_PRE_OFFSET;

	lcp_param = &(hisifd->effect_info.lcp);
	if (NULL == lcp_param) {
		HISI_FB_ERR("lcp_param is NULL!");
		return;
	}

	//Update De-Gamma LUT
	if (effect->lcp_igm_support && hisifd->effect_updated_flag.igm_effect_updated) {
		if (spin_can_lock(&g_igm_effect_lock)) {
			spin_lock(&g_igm_effect_lock);
			ret = lcp_igm_set_reg(degamma_lut_base, lcp_param);

			//Enable De-Gamma
			if (ret) {
				degama_lut_sel = inp32(degamma_base + DEGAMA_LUT_SEL);
				set_reg(degamma_base + DEGAMA_LUT_SEL, (~(degama_lut_sel & 0x1)) & 0x1, 1, 0);
				set_reg(degamma_base + DEGAMA_EN,  lcp_param->igm_enable, 1, 0);
			}
			hisifd->effect_updated_flag.igm_effect_updated = false;
			spin_unlock(&g_igm_effect_lock);
		} else {
			HISI_FB_INFO("igm effect param is being updated, delay set reg to next frame!\n");
		}
	}

	//Update XCC Coef
	if (effect->lcp_xcc_support && hisifd->effect_updated_flag.xcc_effect_updated && !hisifd->mask_layer_xcc_flag) {
		if (spin_can_lock(&g_xcc_effect_lock)) {
			spin_lock(&g_xcc_effect_lock);
			ret = lcp_xcc_set_reg(xcc_base, lcp_param);

			//Update XCC PRE Coef
			if(lcp_param->xcc_pre_enable){
				set_reg(dpp_top_base + DUAL_LCD_TOP_LEFT, lcp_param->xcc_dual_lcd_top_left, 32, 0);
				set_reg(dpp_top_base + DUAL_LCD_BOT_RIGHT, lcp_param->xcc_dual_lcd_bot_right, 32, 0);

				ret = lcp_xcc_pre_set_reg(xcc_pre_base, lcp_param);
			}

			//Enable XCC
			if (ret) {
				set_reg(xcc_base + XCC_EN, (lcp_param->xcc_enable | lcp_param->xcc_pre_enable << 1) & 0x3, 2, 0);
				//Enable XCC pre
				//set_reg(xcc_base + XCC_EN,  lcp_param->xcc_enable, 1, 1);
			}
			hisifd->effect_updated_flag.xcc_effect_updated = false;
			spin_unlock(&g_xcc_effect_lock);
		} else {
			HISI_FB_INFO("xcc effect param is being updated, delay set reg to next frame!\n");
		}
	}

	//GMP LUT for init 	AB buffer
	if (effect->lcp_gmp_support  == 1 && hisifd->online_play_count < 2) {
		if (hisifd->effect_gmp_update_flag || hisifd->effect_updated_flag.gmp_effect_updated) {
			if( lcp_param->gmp_table_low32 && lcp_param->gmp_table_high4){
				if (spin_can_lock(&g_gmp_effect_lock)) {
					spin_lock(&g_gmp_effect_lock);
					for (i = 0; i < GMP_COFE_CNT; i++) {
						set_reg(gmp_lut_base + i * 2 * 4, lcp_param->gmp_table_low32[i], 32, 0); // lint !e679
						set_reg(gmp_lut_base + i * 2 * 4 + 4, lcp_param->gmp_table_high4[i], 4, 0); // lint !e679
						if( 0 == (i%500))
							HISI_FB_DEBUG("[effect] gmp_table_low32[%d]=%d,gmp_table_high4[%d]=%d\n",i,lcp_param->gmp_table_low32[i],i,lcp_param->gmp_table_high4[i]);
					}
					spin_unlock(&g_gmp_effect_lock);
				}
			}
			gmp_lut_sel = (uint32_t)inp32(gmp_base + GMP_LUT_SEL);
			set_reg(gmp_base + GMP_LUT_SEL, (~(gmp_lut_sel & 0x1)) & 0x1, 1, 0);
			set_reg(gmp_base + GMP_EN, lcp_param->gmp_enable, 1, 0);
			if((1 ==hisifd->online_play_count) && hisifd->effect_updated_flag.gmp_effect_updated)
				hisifd->effect_updated_flag.gmp_effect_updated = false;
		} else {
			for (i = 0; i < GMP_COFE_CNT; i++) {
				outp32(gmp_lut_base + i * 2 * 4, gmp_lut_table_low32bit_init[i]);
				outp32(gmp_lut_base + i * 2 * 4 + 4, gmp_lut_table_high4bit_init[i]);
			}
			gmp_lut_sel = (uint32_t)inp32(gmp_base + GMP_LUT_SEL);
			set_reg(gmp_base + GMP_LUT_SEL, (~(gmp_lut_sel & 0x1)) & 0x1, 1, 0);
		}
		gmp_en = inp32(gmp_base + GMP_EN);
		HISI_FB_INFO("[effect] effect_gmp_update_flag=%d,gmp_lut_sel=%d,gmp=%d\n",hisifd->effect_gmp_update_flag,gmp_lut_sel,gmp_en);
	}
}

void hisi_effect_gamma_set_reg(struct hisi_fb_data_type *hisifd)
{
	struct gamma_info *gamma_param = NULL;
	char __iomem *gamma_base = NULL;
	char __iomem *gamma_lut_base = NULL;
	char __iomem *gamma_pre_lut_base = NULL;
	char __iomem *dpp_top_base = NULL;
	int cnt = 0;
	uint32_t gama_lut_sel;

	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!");
		return;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return;
	}

	if (!hisifd->effect_ctl.gamma_support) {
		return;
	}

	if (!hisifd->effect_updated_flag.gamma_effect_updated) {
		return;
	}

	gamma_base = hisifd->dss_base + DSS_DPP_GAMA_OFFSET;
	gamma_lut_base = hisifd->dss_base + DSS_DPP_GAMA_LUT_OFFSET;
	gamma_pre_lut_base = hisifd->dss_base + DSS_DPP_GAMA_PRE_LUT_OFFSET;
	dpp_top_base = hisifd->dss_base + DSS_DPP_OFFSET;

	gamma_param = &(hisifd->effect_info.gamma);

	if (!spin_can_lock(&g_gamma_effect_lock)) {
	    HISI_FB_INFO("gamma effect param is being updated, delay set reg to next frame!\n");
	    return;
	}
	spin_lock(&g_gamma_effect_lock);

	if ((NULL == gamma_param->gamma_r_table) ||
		(NULL == gamma_param->gamma_g_table) ||
		(NULL == gamma_param->gamma_b_table)) {
		HISI_FB_INFO("fb%d, gamma table is null!\n", hisifd->index);
		goto err_ret;
	}

	//Update Gamma LUT
	for (cnt = 0; cnt < GAMMA_LUT_LEN; cnt = cnt + 2) {
		set_reg(gamma_lut_base + (U_GAMA_R_COEF + cnt * 2), gamma_param->gamma_r_table[cnt], 12, 0);
		if (cnt != GAMMA_LUT_LEN - 1)
			set_reg(gamma_lut_base + (U_GAMA_R_COEF + cnt * 2), gamma_param->gamma_r_table[cnt+1], 12, 16);

		set_reg(gamma_lut_base + (U_GAMA_G_COEF + cnt * 2), gamma_param->gamma_g_table[cnt], 12, 0);
		if (cnt != GAMMA_LUT_LEN - 1)
			set_reg(gamma_lut_base + (U_GAMA_G_COEF + cnt * 2), gamma_param->gamma_g_table[cnt+1], 12, 16);

		set_reg(gamma_lut_base + (U_GAMA_B_COEF + cnt * 2), gamma_param->gamma_b_table[cnt], 12, 0);
		if (cnt != GAMMA_LUT_LEN - 1)
			set_reg(gamma_lut_base + (U_GAMA_B_COEF + cnt * 2), gamma_param->gamma_b_table[cnt+1], 12, 16);
	}

	gama_lut_sel = inp32(gamma_base + GAMA_LUT_SEL);
	gama_lut_sel^=0x1;

	if(gamma_param->pre_enable){
		if ((NULL == gamma_param->gamma_r_table_pre) ||
			(NULL == gamma_param->gamma_g_table_pre) ||
			(NULL == gamma_param->gamma_b_table_pre)) {
			HISI_FB_INFO("fb%d, gamma table pre is null!\n", hisifd->index);
			goto err_ret;
			}

		set_reg(dpp_top_base + DUAL_LCD_TOP_LEFT, gamma_param->gamma_dual_lcd_top_left, 32, 0);
		set_reg(dpp_top_base + DUAL_LCD_BOT_RIGHT, gamma_param->gamma_dual_lcd_bot_right, 32, 0);

		//Update Gamma pre LUT
		for (cnt = 0; cnt < GAMMA_LUT_LEN; cnt = cnt + 2) {
			set_reg(gamma_pre_lut_base + (U_GAMA_PRE_R_COEF + cnt * 2), gamma_param->gamma_r_table_pre[cnt], 12, 0);
			set_reg(gamma_pre_lut_base + (U_GAMA_PRE_G_COEF + cnt * 2), gamma_param->gamma_g_table_pre[cnt], 12, 0);
			set_reg(gamma_pre_lut_base + (U_GAMA_PRE_B_COEF + cnt * 2), gamma_param->gamma_b_table_pre[cnt], 12, 0);
			if (cnt != GAMMA_LUT_LEN - 1) {
				set_reg(gamma_pre_lut_base + (U_GAMA_PRE_R_COEF + cnt * 2), gamma_param->gamma_r_table_pre[cnt+1], 12, 16);
				set_reg(gamma_pre_lut_base + (U_GAMA_PRE_G_COEF + cnt * 2), gamma_param->gamma_g_table_pre[cnt+1], 12, 16);
				set_reg(gamma_pre_lut_base + (U_GAMA_PRE_B_COEF + cnt * 2), gamma_param->gamma_b_table_pre[cnt+1], 12, 16);
			}
		}
		gama_lut_sel^=0x2;
	}

	set_reg(gamma_base + GAMA_LUT_SEL, gama_lut_sel & 0x3, 2, 0);

	//Enable Gamma
	set_reg(gamma_base + GAMA_EN,  (gamma_param->enable | gamma_param->pre_enable << 1) & 0x3, 2, 0);

err_ret:
	hisifd->effect_updated_flag.gamma_effect_updated = false;
	//free_gamma_table(gamma_param);

	spin_unlock(&g_gamma_effect_lock);

	return;
}


void hisi_effect_color_dimming_acm_reg_init(struct hisi_fb_data_type *hisifd) {
	return;
}

#define ARSR1P_MIN_SIZE 16
#define ARSR1P_MAX_SIZE 8192
#define ARSR1P_MAX_SRC_WIDTH_SIZE 3840
static void config_arsr1p_param(dss_arsr1p_t *dst_arsr1p, struct arsr1p_info *src_arsr1p)
{

	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, ~src_arsr1p->enable, 1, 0);
	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, src_arsr1p->sharp_enable, 1, 1);
	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, src_arsr1p->shoot_enable, 1, 2);
	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, src_arsr1p->skin_enable, 1, 3);

	dst_arsr1p->skin_thres_y = src_arsr1p->skin_thres_y;
	dst_arsr1p->skin_thres_u = src_arsr1p->skin_thres_u;
	dst_arsr1p->skin_thres_v = src_arsr1p->skin_thres_v;
	dst_arsr1p->skin_expected = src_arsr1p->skin_expected;
	dst_arsr1p->skin_cfg = src_arsr1p->skin_cfg;
	dst_arsr1p->shoot_cfg1 = src_arsr1p->shoot_cfg1;
	dst_arsr1p->shoot_cfg2 = src_arsr1p->shoot_cfg2;
	dst_arsr1p->shoot_cfg3 = src_arsr1p->shoot_cfg3;
	dst_arsr1p->sharp_cfg1_h = src_arsr1p->sharp_cfg1_h;
	dst_arsr1p->sharp_cfg1_l = src_arsr1p->sharp_cfg1_l;
	dst_arsr1p->sharp_cfg2_h = src_arsr1p->sharp_cfg2_h;
	dst_arsr1p->sharp_cfg2_l = src_arsr1p->sharp_cfg2_l;
	dst_arsr1p->sharp_cfg3 = src_arsr1p->sharp_cfg3;
	dst_arsr1p->sharp_cfg4 = src_arsr1p->sharp_cfg4;
	dst_arsr1p->sharp_cfg5 = src_arsr1p->sharp_cfg5;
	dst_arsr1p->sharp_cfg6 = src_arsr1p->sharp_cfg6;
	dst_arsr1p->sharp_cfg6_cut = src_arsr1p->sharp_cfg6_cut;
	dst_arsr1p->sharp_cfg7 = src_arsr1p->sharp_cfg7;
	dst_arsr1p->sharp_cfg7_ratio = src_arsr1p->sharp_cfg7_ratio;
	dst_arsr1p->sharp_cfg8 = src_arsr1p->sharp_cfg8;
	dst_arsr1p->sharp_cfg9 = src_arsr1p->sharp_cfg9;
	dst_arsr1p->sharp_cfg10 = src_arsr1p->sharp_cfg10;
	dst_arsr1p->sharp_cfg11 = src_arsr1p->sharp_cfg11;
	dst_arsr1p->diff_ctrl = src_arsr1p->diff_ctrl;
	dst_arsr1p->skin_slop_y = src_arsr1p->skin_slop_y;
	dst_arsr1p->skin_slop_u = src_arsr1p->skin_slop_u;
	dst_arsr1p->skin_slop_v = src_arsr1p->skin_slop_v;

	dst_arsr1p->sharp_level = src_arsr1p->sharp_level;
	dst_arsr1p->sharp_gain_low = src_arsr1p->sharp_gain_low;
	dst_arsr1p->sharp_gain_mid = src_arsr1p->sharp_gain_mid;
	dst_arsr1p->sharp_gain_high = src_arsr1p->sharp_gain_high;
	dst_arsr1p->sharp_gainctrl_sloph_mf = src_arsr1p->sharp_gainctrl_sloph_mf;
	dst_arsr1p->sharp_gainctrl_slopl_mf = src_arsr1p->sharp_gainctrl_slopl_mf;
	dst_arsr1p->sharp_gainctrl_sloph_hf = src_arsr1p->sharp_gainctrl_sloph_hf;
	dst_arsr1p->sharp_gainctrl_slopl_hf = src_arsr1p->sharp_gainctrl_slopl_hf;
	dst_arsr1p->sharp_mf_lmt = src_arsr1p->sharp_mf_lmt;
	dst_arsr1p->sharp_gain_mf = src_arsr1p->sharp_gain_mf;
	dst_arsr1p->sharp_mf_b = src_arsr1p->sharp_mf_b;
	dst_arsr1p->sharp_hf_lmt = src_arsr1p->sharp_hf_lmt;
	dst_arsr1p->sharp_gain_hf = src_arsr1p->sharp_gain_hf;
	dst_arsr1p->sharp_hf_b = src_arsr1p->sharp_hf_b;
	dst_arsr1p->sharp_lf_ctrl = src_arsr1p->sharp_lf_ctrl;
	dst_arsr1p->sharp_lf_var = src_arsr1p->sharp_lf_var;
	dst_arsr1p->sharp_lf_ctrl_slop = src_arsr1p->sharp_lf_ctrl_slop;
	dst_arsr1p->sharp_hf_select = src_arsr1p->sharp_hf_select;

	dst_arsr1p->force_clk_on_cfg = 0x0;
}


static int set_arsr1p_param(struct hisi_fb_data_type *hisifd, dss_arsr1p_t *post_scf, struct arsr1p_info *arsr1p_param, dss_overlay_t *pov_req)
{
	struct hisi_panel_info *pinfo = NULL;
	struct arsr1p_info *arsr1p_rog = NULL;

	pinfo = &(hisifd->panel_info);

	if (!hisifd->effect_ctl.arsr1p_sharp_support)
	{
		HISI_FB_DEBUG("hisifd, arsr1p not support.\n");
		return 0;
	}

	if ((pov_req->res_updt_rect.w != pinfo->xres)
		|| (pov_req->res_updt_rect.h != pinfo->yres)) {
		if ((pov_req->res_updt_rect.w == 720)) {
			arsr1p_rog = &(hisifd->effect_info.arsr1p[2]);
			HISI_FB_DEBUG("[effect] ROG HD mode config arsr1p.\n");
			if (!(hisifd->effect_info.arsr1p_rog_initialized & ARSR1P_ROG_HD_FLAG)) {
				arsr1p_rog_init(arsr1p_rog);
				hisifd->effect_info.arsr1p_rog_initialized |= ARSR1P_ROG_HD_FLAG;
			}
		} else {
			arsr1p_rog = &(hisifd->effect_info.arsr1p[1]);
			HISI_FB_DEBUG("[effect] ROG FHD mode config arsr1p.\n");
			if (!(hisifd->effect_info.arsr1p_rog_initialized & ARSR1P_ROG_FHD_FLAG)) {
				arsr1p_rog_init(arsr1p_rog);
				hisifd->effect_info.arsr1p_rog_initialized |= ARSR1P_ROG_FHD_FLAG;
			}
		}

		config_arsr1p_param(post_scf, arsr1p_rog);
	} else {
		config_arsr1p_param(post_scf, arsr1p_param);
		hisifd->effect_updated_flag.arsr1p_effect_updated = false;
		HISI_FB_DEBUG("[effect] normal mode config arsr1p.\n");
	}

	return 0;
}

int hisi_arsr1p_set_rect(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req,dss_arsr1p_t *post_scf, struct hisi_panel_info *pinfo)
{
	int32_t ihinc = 0;
	int32_t ivinc = 0;
	int32_t ihleft = 0;
	int32_t ihright = 0;
	int32_t ihleft1 = 0;
	int32_t ihright1 = 0;
	int32_t ivtop = 0;
	int32_t ivbottom = 0;
	int32_t extraw = 0;
	int32_t extraw_left = 0;
	int32_t extraw_right = 0;
	dss_rect_t src_rect = {0};
	dss_rect_t dst_rect = {0};

	/*if((pov_req->res_updt_rect.w != hisifd->ov_req_prev.res_updt_rect.w)
	|| (pov_req->res_updt_rect.h != hisifd->ov_req_prev.res_updt_rect.h))
	{
		hisifd->ov_req_prev.res_updt_rect = pov_req->res_updt_rect;
	}*/

	if (pov_req->dirty_rect.w == 0 || pov_req->dirty_rect.h == 0) {
		dst_rect.x = 0;
		dst_rect.y = 0;
		dst_rect.w = pinfo->xres;
		dst_rect.h = pinfo->yres;
	} else {
		dst_rect.x = 0;
		dst_rect.y = 0;
		dst_rect.w = pov_req->dirty_rect.w;
		dst_rect.h = pov_req->dirty_rect.h;
	}

	if (((pov_req->dirty_rect.w > 0) && (pov_req->dirty_rect.h > 0)) ||
		((pov_req->res_updt_rect.w == 0) || (pov_req->res_updt_rect.h == 0))) {
		src_rect = dst_rect;
	} else {
		src_rect = pov_req->res_updt_rect;
	}

	hisifd->dss_module.post_scf_used = 1;
	if ((src_rect.w < ARSR1P_MIN_SIZE) || (src_rect.h < ARSR1P_MIN_SIZE)
		|| (src_rect.w > ARSR1P_MAX_SRC_WIDTH_SIZE) || (src_rect.h > ARSR1P_MAX_SIZE)
		|| (dst_rect.w > ARSR1P_MAX_SIZE) || (dst_rect.h > ARSR1P_MAX_SIZE)) {
		HISI_FB_ERR("fb%d, invalid input size: src_rect(%d,%d,%d,%d) should be larger than 16*16, less than 3840*8192!\n"
			"invalid output size: dst_rect(%d,%d,%d,%d) should be less than 8192*8192!\n",
			hisifd->index,
			src_rect.x, src_rect.y, src_rect.w, src_rect.h,
			dst_rect.x, dst_rect.y, dst_rect.w, dst_rect.h);
		// bypass
		post_scf->mode = 0x1;
		return -1;
	}

	ihinc = (int32_t)(ARSR1P_INC_FACTOR * (uint64_t)src_rect.w / dst_rect.w);
	ivinc = (int32_t)(ARSR1P_INC_FACTOR * (uint64_t)src_rect.h / dst_rect.h);

	// 0x2000<=ihinc<=ARSR1P_INC_FACTOR; 0x2000<=ivinc<=ARSR1P_INC_FACTOR;
	if ((ihinc < 0x2000) || (ihinc > ARSR1P_INC_FACTOR)
		|| (ivinc < 0x2000) || (ivinc > ARSR1P_INC_FACTOR)) {
		HISI_FB_ERR("invalid ihinc(0x%x), ivinc(0x%x)!\n", ihinc, ivinc);
		// bypass
		post_scf->mode = 0x1;
		return -1;
	}

	extraw = (8 * ARSR1P_INC_FACTOR) / ihinc;
	extraw_left = (extraw % 2) ? (extraw + 1) : (extraw);
	extraw = (2 * ARSR1P_INC_FACTOR) / ihinc;
	extraw_right = (extraw % 2) ? (extraw + 1) : (extraw);

	//ihleft1 = (startX_o * ihinc) - (ov_startX0 << 16)
	ihleft1 = dst_rect.x * ihinc - src_rect.x * ARSR1P_INC_FACTOR;
	if (ihleft1 < 0)
		ihleft1 = 0;
	//ihleft = ihleft1 - even(8 * 65536 / ihinc) * ihinc;
	ihleft = ihleft1 - extraw_left * ihinc;
	if (ihleft < 0)
		ihleft = 0;

	//ihright1 = ihleft1 + (oww-1) * ihinc
	ihright1 = ihleft1 + (dst_rect.w - 1) * ihinc;
	//ihright = ihright1 + even(2 * 65536/ihinc) * ihinc
	ihright = ihright1 + extraw_right * ihinc;
	//ihright >= img_width * ihinc
	if (ihright >= src_rect.w * ARSR1P_INC_FACTOR)
		ihright = src_rect.w * ARSR1P_INC_FACTOR - 1;

	//ivtop = (startY_o * ivinc) - (ov_startY0<<16)
	ivtop = dst_rect.y * ivinc - src_rect.y * ARSR1P_INC_FACTOR;
	if (ivtop < 0)
		ivtop = 0;
	//ivbottom = ivtop + (ohh - 1) * ivinc
	ivbottom = ivtop + (dst_rect.h - 1) * ivinc;
	//ivbottom >= img_height * ivinc
	if (ivbottom >= src_rect.h * ARSR1P_INC_FACTOR)
		ivbottom = src_rect.h * ARSR1P_INC_FACTOR - 1;

	//(ihleft1 - ihleft) % (ihinc) == 0;
	if ((ihleft1 - ihleft) % (ihinc)) {
		HISI_FB_ERR("(ihleft1(%d)-ihleft(%d))  ihinc(%d) != 0, invalid!\n",
			ihleft1, ihleft, ihinc);
		post_scf->mode = 0x1;
		return -1;
	}

	//(ihright1 - ihleft1) % ihinc == 0;
	if ((ihright1 - ihleft1) % ihinc) {
		HISI_FB_ERR("(ihright1(%d)-ihleft1(%d))  ihinc(%d) != 0, invalid!\n",
			ihright1, ihleft1, ihinc);
		post_scf->mode = 0x1;
		return -1;
	}

	/* use default param if not config param*/
	post_scf->mode &= 0xFFFFFFFE; /*cancel arsr1p bypass*/
	post_scf->mode |= 0xc;/*skinctrl, shootdetect*/
	post_scf->mode |= 0x20;/*enable direction*/
	post_scf->mode |= 0x2;/*enable sharpness*/
	if ((ihinc < ARSR1P_INC_FACTOR) || (ivinc < ARSR1P_INC_FACTOR)) {
		post_scf->mode |= 0x10;/*enable diintplen*/
	} else {
		post_scf->mode |= 0x40;/*only sharp, enable nointplen*/
	}


	post_scf->ihleft = set_bits32(post_scf->ihleft, ihleft, 32, 0);
	post_scf->ihright = set_bits32(post_scf->ihright, ihright, 32, 0);
	post_scf->ihleft1 = set_bits32(post_scf->ihleft1, ihleft1, 32, 0);
	post_scf->ihright1 = set_bits32(post_scf->ihright1, ihright1, 32, 0);
	post_scf->ivtop = set_bits32(post_scf->ivtop, ivtop, 32, 0);
	post_scf->ivbottom = set_bits32(post_scf->ivbottom, ivbottom, 32, 0);
	post_scf->ihinc = set_bits32(post_scf->ihinc, ihinc, 32, 0);
	post_scf->ivinc = set_bits32(post_scf->ivinc, ivinc, 32, 0);

	post_scf->dpp_img_size_bef_sr = set_bits32(post_scf->dpp_img_size_bef_sr,
		(DSS_HEIGHT((uint32_t)src_rect.h) << 16) | DSS_WIDTH((uint32_t)src_rect.w), 32, 0);
	post_scf->dpp_img_size_aft_sr = set_bits32(post_scf->dpp_img_size_aft_sr,
		(DSS_HEIGHT((uint32_t)dst_rect.h) << 16) | DSS_WIDTH((uint32_t)dst_rect.w), 32, 0);
	post_scf->dpp_used = 1;

	return 0;
}

int hisi_effect_arsr1p_config(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req)
{
	struct arsr1p_info *arsr1p_param = NULL;
	struct hisi_panel_info *pinfo = NULL;
	dss_arsr1p_t *post_scf = NULL;
	int ret = 0;

	if ((NULL == hisifd) || (NULL == pov_req)) {
		HISI_FB_ERR("hisifd or pov_req is NULL!");
		return -EINVAL;
	}


	if ((!HISI_DSS_SUPPORT_DPP_MODULE_BIT(DPP_MODULE_POST_SCF))
		|| (PRIMARY_PANEL_IDX != hisifd->index)){
		return 0;
	}

	pinfo = &(hisifd->panel_info);
	arsr1p_param = &(hisifd->effect_info.arsr1p[0]);
	post_scf = &(hisifd->dss_module.post_scf);


	if ((arsr1p_param->enable != 1) &&
		((pov_req->res_updt_rect.w == pinfo->xres)
		&& (pov_req->res_updt_rect.h == pinfo->yres))) {
		hisifd->dss_module.post_scf_used = 1;
		post_scf->mode = 0x1;
		return 0;
	}

	if ((pov_req->res_updt_rect.w < 0) || (pov_req->res_updt_rect.h < 0)) {
		HISI_FB_ERR("fb%d, res_updt_rect[%d,%d, %d,%d] is invalid!\n", hisifd->index,
			pov_req->res_updt_rect.x, pov_req->res_updt_rect.y,
			pov_req->res_updt_rect.w, pov_req->res_updt_rect.h);
		return -EINVAL;
	}

	if (!spin_can_lock(&hisifd->effect_lock)) {
		HISI_FB_DEBUG("fb%d, dss effect param is being updated, delay set reg to next frame!\n", hisifd->index);
		return 0;
	}

	spin_lock(&hisifd->effect_lock);

	/*update arsr1p rect*/
	if (hisi_arsr1p_set_rect(hisifd, pov_req, post_scf, pinfo)) {
		ret = -EINVAL;
		goto err_return;
	}

	/*update arsr1p effect para*/
	if (set_arsr1p_param(hisifd, post_scf, arsr1p_param, pov_req)) {
		HISI_FB_ERR("fb%d, failed to set arsr1p param.\n", hisifd->index);
		ret = -EINVAL;
		goto err_return;
	}

err_return:
	spin_unlock(&hisifd->effect_lock);
	return ret;
}

static void hisi_effect_arsr2p_update(struct hisi_fb_data_type *hisifd, struct dss_arsr2p *arsr2p) {
	if (hisifd == NULL || arsr2p == NULL) {
		HISI_FB_ERR("hisifd or arsr2p is null. return\n");
		return;
	}

	if (hisifd->effect_info.arsr2p[0].update == 1) {
		memcpy(&(arsr2p->arsr2p_effect), &(hisifd->effect_info.arsr2p[0]), sizeof(struct arsr2p_info));
		hisifd->effect_info.arsr2p[0].update = 0;
	}

	if (hisifd->effect_info.arsr2p[1].update == 1) {
		memcpy(&(arsr2p->arsr2p_effect_scale_up), &(hisifd->effect_info.arsr2p[1]), sizeof(struct arsr2p_info));
		hisifd->effect_info.arsr2p[1].update = 0;
	}

	if (hisifd->effect_info.arsr2p[2].update == 1) {
		memcpy(&(arsr2p->arsr2p_effect_scale_down), &(hisifd->effect_info.arsr2p[2]), sizeof(struct arsr2p_info));
		hisifd->effect_info.arsr2p[2].update = 0;
	}
}

int hisi_effect_arsr2p_config(struct arsr2p_info *arsr2p_effect_dst, int ih_inc, int iv_inc)
{
	struct hisi_fb_data_type *hisifd_primary = NULL;
	struct dss_arsr2p *arsr2p = NULL;

	hisifd_primary = hisifd_list[PRIMARY_PANEL_IDX];
	if (NULL == hisifd_primary) {
		HISI_FB_ERR("hisifd_primary is NULL pointer, return!\n");
		return -EINVAL;
	}

	if (NULL == arsr2p_effect_dst) {
		HISI_FB_ERR("arsr2p_effect_dst is NULL pointer, return!\n");
		return -EINVAL;
	}

	arsr2p = &(hisifd_primary->dss_module_default.arsr2p[DSS_RCHN_V0]);

	hisi_effect_arsr2p_update(hisifd_primary, arsr2p);

	if ((ih_inc == ARSR2P_INC_FACTOR) && (iv_inc == ARSR2P_INC_FACTOR)) {
		memcpy(arsr2p_effect_dst, &(arsr2p->arsr2p_effect), sizeof(struct arsr2p_info));
	} else if ((ih_inc < ARSR2P_INC_FACTOR) || (iv_inc < ARSR2P_INC_FACTOR)) {
		memcpy(arsr2p_effect_dst, &(arsr2p->arsr2p_effect_scale_up), sizeof(struct arsr2p_info));
	} else {
		memcpy(arsr2p_effect_dst, &(arsr2p->arsr2p_effect_scale_down), sizeof(struct arsr2p_info));
	}

	return 0;
}
int hisifb_ce_service_enable_hiace(struct fb_info *info, void __user *argp)
{
	struct hisi_panel_info *pinfo = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;
	dss_ce_info_t *ce_info = NULL;
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_metadata_t *metadata_ctrl = NULL;
	int enable = 0;
	int mode = 0;
	int ret;
	if (NULL == info) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}
	if (NULL == argp) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}
	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}
	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		EFFECT_DEBUG_LOG(DEBUG_EFFECT_ENTRY, "[effect] HIACE is not supported!\n");
		return -1;
	}
	if (hisifd->index == PRIMARY_PANEL_IDX) {
		ce_ctrl = &(hisifd->ce_ctrl);
		ce_info = &(hisifd->hiace_info);
		metadata_ctrl = &(hisifd->metadata_ctrl);
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return -1;
	}
	ret = (int)copy_from_user(&enable, argp, sizeof(enable));
	if (ret) {
		HISI_FB_ERR("[effect] arg is invalid");
		return -EINVAL;
	}
	mode = enable;
	if (mode < 0) {
		mode = 0;
	} else if (mode >= CE_MODE_COUNT) {
		mode = CE_MODE_COUNT - 1;
	}
	if (mode != ce_ctrl->ctrl_ce_mode) {
		mutex_lock(&(ce_ctrl->ctrl_lock));
		ce_ctrl->ctrl_ce_mode = mode;
		mutex_unlock(&(ce_ctrl->ctrl_lock));
		if (mode == CE_MODE_DISABLE && hisifd->panel_power_on) {
			ce_info->gradual_frames = EFFECT_GRADUAL_REFRESH_FRAMES;
			ce_info->to_stop_hdr = true;
		}
		enable_hiace(hisifd, mode);
	}
	return 0;
}
int hisifb_get_reg_val(struct fb_info *info, void __user *argp) {
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	struct dss_reg reg;
	uint32_t addr;
	int ret = 0;
	if (NULL == info) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}
	if (NULL == argp) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}
	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->panel_power_on == false) {
		HISI_FB_ERR("[effect] panel power off\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (!pinfo->hiace_support) {
		EFFECT_DEBUG_LOG(DEBUG_EFFECT_ENTRY, "[effect] Don't support HIACE\n");
		return -EINVAL;
	}
	EFFECT_DEBUG_LOG(DEBUG_EFFECT_FRAME, "[effect] step in\n");
	ret = (int)copy_from_user(&reg, argp, sizeof(struct dss_reg));
	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(param) failed! ret=%d.\n", ret);
		return -2;
	}

	switch(reg.tag) {
		case TAG_ARSR_1P_ENABLE:
			addr = DSS_POST_SCF_OFFSET + ARSR_POST_MODE;
			break;
		case TAG_LCP_XCC_ENABLE:
			addr = DSS_DPP_XCC_OFFSET + XCC_EN;
			break;
		case TAG_LCP_GMP_ENABLE:
			addr = DSS_DPP_GMP_OFFSET + GMP_EN;
			break;
		case TAG_LCP_IGM_ENABLE:
			addr = DSS_DPP_DEGAMMA_OFFSET + DEGAMA_EN;
			break;
		case TAG_GAMMA_ENABLE:
			addr = DSS_DPP_GAMA_OFFSET + GAMA_EN;
			break;
		case TAG_HIACE_LHIST_SFT:
			addr = DSS_HI_ACE_OFFSET + DPE_LHIST_SFT;
			break;
		default:
			HISI_FB_ERR("[effect] invalid tag : %u", reg.tag);
			return -EINVAL;
	}

	reg.value = (uint32_t)inp32(hisifd->dss_base + addr);

	ret = (int)copy_to_user(argp, &reg, sizeof(struct dss_reg));
	if (ret) {
		HISI_FB_ERR("[effect] copy_to_user failed(param)! ret=%d.\n", ret);
		ret = -EINVAL;
	}
	return 0;
}

int hisifb_hiace_info_set(struct hisi_fb_data_type *hisifd, struct hiace_info *hiace){
	int ret = 0;
	struct hiace_info *hiace_dst=NULL;
	if (NULL == hisifd) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (NULL == hiace) {
		HISI_FB_ERR("fb%d, hiace is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	hisifd->effect_info.hiace.lhist_sft = hiace->lhist_sft;
	hisifd->effect_info.hiace.roi_start_point = hiace->roi_start_point;
	hisifd->effect_info.hiace.roi_width_high = hiace->roi_width_high;
	hisifd->effect_info.hiace.roi_mode_ctrl = hiace->roi_mode_ctrl;
	hisifd->effect_info.hiace.roi_hist_stat_mode = hiace->roi_hist_stat_mode;
	hisifd->effect_info.hiace.hue = hiace->hue;
	hisifd->effect_info.hiace.saturation = hiace->saturation;
	hisifd->effect_info.hiace.value = hiace->value;
	hisifd->effect_info.hiace.skin_gain = hiace->skin_gain;
	hisifd->effect_info.hiace.up_low_th = hiace->up_low_th;
	hisifd->effect_info.hiace.rgb_blend_weight = hiace->rgb_blend_weight;
	hisifd->effect_info.hiace.fna_statistic = hiace->fna_statistic;
	hisifd->effect_info.hiace.up_cnt = hiace->up_cnt;
	hisifd->effect_info.hiace.low_cnt = hiace->low_cnt;
	hisifd->effect_info.hiace.sum_saturation = hiace->sum_saturation;
	hisifd->effect_info.hiace.lhist_en = hiace->lhist_en;
	hisifd->effect_info.hiace.gamma_w = hiace->gamma_w;
	hisifd->effect_info.hiace.gamma_r = hiace->gamma_r;
	hisifd->effect_info.hiace.fna_addr = hiace->fna_addr;
	hisifd->effect_info.hiace.fna_data = hiace->fna_data;
	hisifd->effect_info.hiace.update_fna = hiace->update_fna;
	hisifd->effect_info.hiace.fna_valid = hiace->fna_valid;
	hisifd->effect_info.hiace.db_pipe_cfg = hiace->db_pipe_cfg;
	hisifd->effect_info.hiace.db_pipe_ext_width = hiace->db_pipe_ext_width;
	hisifd->effect_info.hiace.db_pipe_full_img_width = hiace->db_pipe_full_img_width;
	hisifd->effect_info.hiace.bypass_nr = hiace->bypass_nr;
	hisifd->effect_info.hiace.bypass_nr_gain= hiace->bypass_nr_gain;
	hisifd->effect_info.hiace.s3_some_brightness01 = hiace->s3_some_brightness01;
	hisifd->effect_info.hiace.s3_some_brightness23 = hiace->s3_some_brightness23;
	hisifd->effect_info.hiace.s3_some_brightness4 = hiace->s3_some_brightness4;
	hisifd->effect_info.hiace.s3_min_max_sigma = hiace->s3_min_max_sigma;
	hisifd->effect_info.hiace.s3_green_sigma03 = hiace->s3_green_sigma03;
	hisifd->effect_info.hiace.s3_green_sigma45 = hiace->s3_green_sigma45;
	hisifd->effect_info.hiace.s3_red_sigma03 = hiace->s3_red_sigma03;
	hisifd->effect_info.hiace.s3_red_sigma45 = hiace->s3_red_sigma45;
	hisifd->effect_info.hiace.s3_blue_sigma03 = hiace->s3_blue_sigma03;
	hisifd->effect_info.hiace.s3_blue_sigma45 = hiace->s3_blue_sigma45;
	hisifd->effect_info.hiace.s3_white_sigma03 = hiace->s3_white_sigma03;
	hisifd->effect_info.hiace.s3_white_sigma45 = hiace->s3_white_sigma45;
	hisifd->effect_info.hiace.s3_filter_level = hiace->s3_filter_level;
	hisifd->effect_info.hiace.s3_similarity_coeff = hiace->s3_similarity_coeff;
	hisifd->effect_info.hiace.s3_v_filter_weight_adj = hiace->s3_v_filter_weight_adj;
	hisifd->effect_info.hiace.s3_hue = hiace->s3_hue;
	hisifd->effect_info.hiace.s3_saturation = hiace->s3_saturation;
	hisifd->effect_info.hiace.s3_value = hiace->s3_value;
	hisifd->effect_info.hiace.s3_skin_gain = hiace->s3_skin_gain;
	hisifd->effect_info.hiace.param_update = hiace->param_update;
	hisifd->effect_info.hiace.enable = hiace->enable;
	hisifd->effect_info.hiace.enable_update = hiace->enable_update;
	hisifd->effect_info.hiace.lut_update = hiace->lut_update;
	hisifd->effect_info.hiace.hdr10_en = hiace->hdr10_en;
	hisifd->effect_info.hiace.loglum_max = hiace->loglum_max;
	hisifd->effect_info.hiace.hist_modev = hiace->hist_modev;
	hisifd->effect_info.hiace.end_point = hiace->end_point;
	hisifd->effect_info.hiace.table_update = hiace->table_update;

	if(hisifd->effect_info.hiace.table_update){
		g_table_update = hisifd->effect_info.hiace.table_update;
	}

	if(g_table_update){
		hiace_dst=&(hisifd->effect_info.hiace);
		ret = (int)hisi_effect_alloc_and_copy(&hiace_dst->detail_weight_table, hiace->detail_weight_table, HIACE_DETAIL_WEIGHT_TABLE_LEN, true);
		if (ret) {
			HISI_FB_ERR("[effect] copy_from_user(detail_weight) failed! ret=%d.\n", ret);
			ret = -2;
		}

		ret = (int)hisi_effect_alloc_and_copy(&hiace_dst->loglum_eotf_table, hiace->loglum_eotf_table, HIACE_LOGLUM_EOTF_TABLE_LEN, true);
		if (ret) {
			HISI_FB_ERR("[effect] copy_from_user(LogLumEOTFLUT) failed! ret=%d.\n", ret);
			ret = -2;
		}

		ret = (int)hisi_effect_alloc_and_copy(&hiace_dst->luma_gamma_table, hiace->luma_gamma_table, HIACE_LUMA_GAMA_TABLE_LEN, true);
		if (ret) {
			HISI_FB_ERR("[effect] copy_from_user(LumEOTFGammaLUT) failed! ret=%d.\n", ret);
			ret = -2;
		}
	}
	return 0;
}
int hisifb_ce_service_set_param(struct fb_info *info, void __user *argp) {
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	int ret = 0;
	struct hiace_info hiace;

	if (runmode_is_factory()) {
		return ret;
	}

	if ((NULL == info) || (NULL == argp)) {
		HISI_FB_ERR("info or argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (NULL == hisifd) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}
	pinfo = &(hisifd->panel_info);
	if (!pinfo->hiace_support) {
		EFFECT_DEBUG_LOG(DEBUG_EFFECT_ENTRY, "[effect] Don't support HIACE\n");
		return -EINVAL;
	}
	EFFECT_DEBUG_LOG(DEBUG_EFFECT_FRAME, "[effect] step in\n");

	spin_lock(&g_hiace_table_lock);
	ret = (int)copy_from_user(&hiace, argp, sizeof(struct hiace_info));
	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(param) failed! ret=%d.\n", ret);
		spin_unlock(&g_hiace_table_lock);
		return -2;
	}

	ret=hisifb_hiace_info_set(hisifd, &hiace);
	if(ret){
		HISI_FB_ERR("[effect] hiace info set failed! ret=%d.\n", ret);
		spin_unlock(&g_hiace_table_lock);
		return -2;
	}
	spin_unlock(&g_hiace_table_lock);
	hisifd->effect_updated_flag.hiace_effect_updated = true;
	return ret;
}
static int set_hiace_param(struct hisi_fb_data_type *hisifd) {
	char __iomem *hiace_base = NULL;
	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -1;
	}
	if (hisifd->index == PRIMARY_PANEL_IDX) {
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_DEBUG("[effect] fb%d, not support!", hisifd->index);
		return 0;
	}
	if (hisifd->fb_shutdown == true || hisifd->panel_power_on == false) {
		HISI_FB_ERR("[effect] fb_shutdown or panel power down");
		return -EINVAL;
	}
	if (hisifd->effect_updated_flag.hiace_effect_updated) {
		spin_lock(&g_hiace_table_lock);
		//set_reg(hiace_base + DPE_LHIST_SFT, hisifd->effect_info.hiace.lhist_sft, 32, 0);
		set_reg(hiace_base + DPE_ROI_START_POINT, hisifd->effect_info.hiace.roi_start_point, 32, 0);
		set_reg(hiace_base + DPE_ROI_WIDTH_HIGH, hisifd->effect_info.hiace.roi_width_high, 32, 0);
		set_reg(hiace_base + DPE_ROI_MODE_CTRL, hisifd->effect_info.hiace.roi_mode_ctrl, 32, 0);
		set_reg(hiace_base + DPE_ROI_HIST_STAT_MODE, hisifd->effect_info.hiace.roi_hist_stat_mode, 32, 0);
		set_reg(hiace_base + DPE_HUE, hisifd->effect_info.hiace.hue, 32, 0);
		set_reg(hiace_base + DPE_SATURATION, hisifd->effect_info.hiace.saturation, 32, 0);
		set_reg(hiace_base + DPE_VALUE, hisifd->effect_info.hiace.value, 32, 0);
		set_reg(hiace_base + DPE_SKIN_GAIN, hisifd->effect_info.hiace.skin_gain, 32, 0);
		set_reg(hiace_base + DPE_UP_LOW_TH, hisifd->effect_info.hiace.up_low_th, 32, 0);
		set_reg(hiace_base + DPE_RGB_BLEND_WEIGHT, hisifd->effect_info.hiace.rgb_blend_weight, 32, 0);
		set_reg(hiace_base + DPE_FNA_STATISTIC, hisifd->effect_info.hiace.fna_statistic, 32, 0);
		set_reg(hiace_base + DPE_UP_CNT, hisifd->effect_info.hiace.up_cnt, 32, 0);
		set_reg(hiace_base + DPE_LOW_CNT, hisifd->effect_info.hiace.low_cnt, 32, 0);
		set_reg(hiace_base + DPE_SUM_SATURATION, hisifd->effect_info.hiace.sum_saturation, 32, 0);
		//set_reg(hiace_base + DPE_LHIST_EN, hisifd->effect_info.hiace.lhist_en, 32, 0);
		set_reg(hiace_base + DPE_GAMMA_W, hisifd->effect_info.hiace.gamma_w, 32, 0);
		set_reg(hiace_base + DPE_GAMMA_R, hisifd->effect_info.hiace.gamma_r, 32, 0);
		set_reg(hiace_base + DPE_FNA_ADDR, hisifd->effect_info.hiace.fna_addr, 32, 0);
		set_reg(hiace_base + DPE_FNA_DATA, hisifd->effect_info.hiace.fna_data, 32, 0);
		set_reg(hiace_base + DPE_UPDATE_FNA, hisifd->effect_info.hiace.update_fna, 32, 0);
		set_reg(hiace_base + DPE_FNA_VALID, hisifd->effect_info.hiace.fna_valid, 32, 0);
		set_reg(hiace_base + DPE_DB_PIPE_CFG, hisifd->effect_info.hiace.db_pipe_cfg, 32, 0);
		set_reg(hiace_base + DPE_DB_PIPE_EXT_WIDTH, hisifd->effect_info.hiace.db_pipe_ext_width, 32, 0);
		set_reg(hiace_base + DPE_DB_PIPE_FULL_IMG_WIDTH, hisifd->effect_info.hiace.db_pipe_full_img_width, 32, 0);
		set_reg(hiace_base + DPE_BYPASS_NR, (hisifd->effect_info.hiace.bypass_nr | (hisifd->effect_info.hiace.bypass_nr_gain << 1)), 32, 0);
		set_reg(hiace_base + DPE_S3_SOME_BRIGHTNESS01, hisifd->effect_info.hiace.s3_some_brightness01, 32, 0);
		set_reg(hiace_base + DPE_S3_SOME_BRIGHTNESS23, hisifd->effect_info.hiace.s3_some_brightness23, 32, 0);
		set_reg(hiace_base + DPE_S3_SOME_BRIGHTNESS4, hisifd->effect_info.hiace.s3_some_brightness4, 32, 0);
		set_reg(hiace_base + DPE_S3_MIN_MAX_SIGMA, hisifd->effect_info.hiace.s3_min_max_sigma, 32, 0);
		set_reg(hiace_base + DPE_S3_GREEN_SIGMA03, hisifd->effect_info.hiace.s3_green_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_GREEN_SIGMA45, hisifd->effect_info.hiace.s3_green_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_RED_SIGMA03, hisifd->effect_info.hiace.s3_red_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_RED_SIGMA45, hisifd->effect_info.hiace.s3_red_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_BLUE_SIGMA03, hisifd->effect_info.hiace.s3_blue_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_BLUE_SIGMA45, hisifd->effect_info.hiace.s3_blue_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_WHITE_SIGMA03, hisifd->effect_info.hiace.s3_white_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_WHITE_SIGMA45, hisifd->effect_info.hiace.s3_white_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_FILTER_LEVEL, hisifd->effect_info.hiace.s3_filter_level, 32, 0);
		set_reg(hiace_base + DPE_S3_SIMILARITY_COEFF, hisifd->effect_info.hiace.s3_similarity_coeff, 32, 0);
		set_reg(hiace_base + DPE_S3_V_FILTER_WEIGHT_ADJ, hisifd->effect_info.hiace.s3_v_filter_weight_adj, 32, 0);
		set_reg(hiace_base + DPE_S3_HUE, hisifd->effect_info.hiace.s3_hue, 32, 0);
		set_reg(hiace_base + DPE_S3_SATURATION, hisifd->effect_info.hiace.s3_saturation, 32, 0);
		set_reg(hiace_base + DPE_S3_VALUE, hisifd->effect_info.hiace.s3_value, 32, 0);
		set_reg(hiace_base + DPE_S3_SKIN_GAIN, hisifd->effect_info.hiace.s3_skin_gain, 32, 0);

		set_reg(hiace_base + DPE_HDR10_EN, hisifd->effect_info.hiace.hdr10_en, 32, 0);
		set_reg(hiace_base + DPE_LOGLUM_MAX, hisifd->effect_info.hiace.loglum_max, 32, 0);
		set_reg(hiace_base + DPE_HIST_MODEV, hisifd->effect_info.hiace.hist_modev, 32, 0);
		set_reg(hiace_base + DPE_END_POINT, hisifd->effect_info.hiace.end_point, 32, 0);

		hisi_dss_dpp_hiace_set_lut_reg(hisifd, hiace_base);
		spin_unlock(&g_hiace_table_lock);
	}
	hisifd->effect_updated_flag.hiace_effect_updated = false;
	return 0;
}
int hisi_effect_hiace_config(struct hisi_fb_data_type *hisifd) {
	char __iomem *hiace_base = NULL;
	struct hisi_panel_info *pinfo = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -1;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		return 0;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_DEBUG("[effect] fb%d, not support!", hisifd->index);
		return 0;
	}

	if (hiace_enable_status != hisifd->hiace_info.hiace_enable) {
		if (hisifd->hiace_info.hiace_enable) {
			if (hisifd->dirty_region_updt_enable == 0) {
				set_reg(hiace_base + HIACE_BYPASS_ACE, 0x0, 1, 0);
				set_reg(hiace_base + HIACE_INT_STAT, 0x1, 1, 0);
				hiace_enable_status = hisifd->hiace_info.hiace_enable;
			}
		} else {
			set_reg(hiace_base + HIACE_BYPASS_ACE, 0x1, 1, 0);
			hiace_enable_status = hisifd->hiace_info.hiace_enable;
		}
	}

	return set_hiace_param(hisifd);
}
/*lint +e571, +e573, +e737, +e732, +e850, +e730, +e713, +e529, +e574, +e679, +e732, +e845, +e570,
+e774 +e568 +e587 +e685*/
//lint +e747, +e838
